### RemoteIQ Permissions/Admin Review Bundle
# Generated: 2025-11-07 00:56:04 -05:00
# RepoRoot: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\migrations\20251106_permissions_schema.sql
================================================================================
-- 20251106_permissions_schema.sql
-- Creates roles.description, permissions, and role_permissions (idempotent)

BEGIN;

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 1) Roles: add description column if missing
ALTER TABLE public.roles
  ADD COLUMN IF NOT EXISTS description text;

-- 2) Permissions master table
CREATE TABLE IF NOT EXISTS public.permissions (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  key         text UNIQUE NOT NULL,         -- e.g. 'users.read'
  label       text NOT NULL,                -- human label
  group_key   text NOT NULL,                -- e.g. 'users'
  group_label text NOT NULL,                -- e.g. 'Users'
  created_at  timestamptz NOT NULL DEFAULT now()
);

-- Helpful indexes
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes
    WHERE schemaname='public' AND indexname='permissions_group_key_idx'
  ) THEN
    CREATE INDEX permissions_group_key_idx ON public.permissions (group_key);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes
    WHERE schemaname='public' AND indexname='permissions_key_idx'
  ) THEN
    CREATE INDEX permissions_key_idx ON public.permissions (key);
  END IF;
END$$;

-- 3) Role ↔ Permission link table (composite PK)
CREATE TABLE IF NOT EXISTS public.role_permissions (
  role_id       uuid NOT NULL REFERENCES public.roles(id) ON DELETE CASCADE,
  permission_id uuid NOT NULL REFERENCES public.permissions(id) ON DELETE CASCADE,
  PRIMARY KEY (role_id, permission_id)
);

COMMIT;

================================================================================
END FILE: remoteiq-minimal-e2e\backend\migrations\20251106_permissions_schema.sql
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\migrations\20251106_permissions_seed.sql
================================================================================
-- 20251106_permissions_seed.sql
-- Seeds standard permissions; ensures Owner/Admin roles and grants.
-- Safe to run multiple times.

BEGIN;

-- Helper upsert function for permissions
CREATE OR REPLACE FUNCTION public._upsert_permission(
  p_key text, p_label text, p_group_key text, p_group_label text
) RETURNS void AS $$
BEGIN
  INSERT INTO public.permissions (key, label, group_key, group_label)
  VALUES (p_key, p_label, p_group_key, p_group_label)
  ON CONFLICT (key) DO UPDATE
    SET label       = EXCLUDED.label,
        group_key   = EXCLUDED.group_key,
        group_label = EXCLUDED.group_label;
END
$$ LANGUAGE plpgsql;

-- ===== Users =====
SELECT public._upsert_permission('users.read',       'View users',         'users','Users');
SELECT public._upsert_permission('users.write',      'Create/edit users',  'users','Users');
SELECT public._upsert_permission('users.delete',     'Remove users',       'users','Users');
SELECT public._upsert_permission('users.2fa.reset',  'Reset 2FA',          'users','Users');

-- ===== Roles =====
SELECT public._upsert_permission('roles.read',   'roles.read',   'roles','Roles');
SELECT public._upsert_permission('roles.write',  'roles.write',  'roles','Roles');
SELECT public._upsert_permission('roles.delete', 'roles.delete', 'roles','Roles');

-- ===== Teams =====
SELECT public._upsert_permission('teams.read',   'teams.read',   'teams','Teams');
SELECT public._upsert_permission('teams.write',  'teams.write',  'teams','Teams');
SELECT public._upsert_permission('teams.delete', 'teams.delete', 'teams','Teams');

-- ===== Billing =====
SELECT public._upsert_permission('billing.read',  'billing.read',  'billing','Billing');
SELECT public._upsert_permission('billing.write', 'billing.write', 'billing','Billing');

-- ===== Settings =====
SELECT public._upsert_permission('settings.read',  'settings.read',  'settings','Settings');
SELECT public._upsert_permission('settings.write', 'settings.write', 'settings','Settings');

-- ===== Backups =====
SELECT public._upsert_permission('backups.manage',   'Manage backups (run/config)', 'backups','Backups');
SELECT public._upsert_permission('backups.restore',  'Restore from backups',        'backups','Backups');
SELECT public._upsert_permission('backups.download', 'Download backup artifacts',   'backups','Backups');

-- Cleanup helper
DROP FUNCTION IF EXISTS public._upsert_permission(text,text,text,text);

-- Ensure Owner/Admin roles exist (with descriptions)
INSERT INTO public.roles (id, name, description)
SELECT gen_random_uuid(), 'Owner', 'Full system access'
WHERE NOT EXISTS (SELECT 1 FROM public.roles WHERE lower(name)='owner');

INSERT INTO public.roles (id, name, description)
SELECT gen_random_uuid(), 'Admin', 'Administrative access'
WHERE NOT EXISTS (SELECT 1 FROM public.roles WHERE lower(name)='admin');

-- Grant Owner every permission
INSERT INTO public.role_permissions (role_id, permission_id)
SELECT r.id, p.id
FROM public.roles r
CROSS JOIN public.permissions p
WHERE lower(r.name)='owner'
  AND NOT EXISTS (
    SELECT 1 FROM public.role_permissions rp
    WHERE rp.role_id=r.id AND rp.permission_id=p.id
  );

-- Grant Admin a curated set (edit as needed)
WITH admin_role AS (
  SELECT id FROM public.roles WHERE lower(name)='admin'
),
wanted AS (
  SELECT id FROM public.permissions WHERE key IN (
    'users.read','users.write','users.delete','users.2fa.reset',
    'roles.read','roles.write','roles.delete',
    'teams.read','teams.write','teams.delete',
    'billing.read','billing.write',
    'settings.read','settings.write',
    'backups.manage','backups.restore','backups.download'
  )
)
INSERT INTO public.role_permissions (role_id, permission_id)
SELECT ar.id, w.id
FROM admin_role ar
JOIN wanted w ON TRUE
WHERE NOT EXISTS (
  SELECT 1 FROM public.role_permissions rp
  WHERE rp.role_id = ar.id AND rp.permission_id = w.id
);

COMMIT;

================================================================================
END FILE: remoteiq-minimal-e2e\backend\migrations\20251106_permissions_seed.sql
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\migrations\XXXX_roles_enhancements.sql
================================================================================
-- === Add missing columns on roles (idempotent) ===
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema='public' AND table_name='roles' AND column_name='description'
  ) THEN
    ALTER TABLE public.roles ADD COLUMN description text;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema='public' AND table_name='roles' AND column_name='permissions'
  ) THEN
    -- string[] to match your frontend
    ALTER TABLE public.roles ADD COLUMN permissions text[] NOT NULL DEFAULT ARRAY[]::text[];
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema='public' AND table_name='roles' AND column_name='updated_at'
  ) THEN
    ALTER TABLE public.roles ADD COLUMN updated_at timestamptz NOT NULL DEFAULT now();
  END IF;
END$$;

-- === Case-insensitive unique constraint on roles.name ===
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 
    FROM   pg_indexes 
    WHERE  schemaname='public' AND tablename='roles' AND indexname='roles_name_lower_key'
  ) THEN
    CREATE UNIQUE INDEX roles_name_lower_key ON public.roles (lower(name));
  END IF;
END$$;

-- === Trigger to keep updated_at fresh ===
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_proc WHERE proname = 'roles_set_updated_at'
  ) THEN
    CREATE OR REPLACE FUNCTION roles_set_updated_at()
    RETURNS trigger LANGUAGE plpgsql AS $fn$
    BEGIN
      NEW.updated_at := now();
      RETURN NEW;
    END;
    $fn$;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_roles_set_updated_at'
  ) THEN
    CREATE TRIGGER trg_roles_set_updated_at
    BEFORE UPDATE ON public.roles
    FOR EACH ROW EXECUTE FUNCTION roles_set_updated_at();
  END IF;
END$$;

-- === (Optional) Seed common roles if missing ===
INSERT INTO public.roles (name, description, permissions)
SELECT r.name, r.description, r.permissions
FROM (VALUES
  ('Owner', 'System owner', ARRAY[
    'users.read','users.write','users.delete','users.2fa.reset',
    'roles.read','roles.write','roles.delete',
    'teams.read','teams.write','teams.delete',
    'billing.read','billing.write',
    'settings.read','settings.write'
  ]::text[]),
  ('Admin', 'Administrator', ARRAY[
    'users.read','users.write','users.2fa.reset',
    'roles.read','roles.write',
    'teams.read','teams.write',
    'billing.read',
    'settings.read','settings.write'
  ]::text[]),
  ('User', 'Standard user', ARRAY[
    'users.read','roles.read','teams.read','billing.read','settings.read'
  ]::text[])
) AS r(name, description, permissions)
WHERE NOT EXISTS (SELECT 1 FROM public.roles x WHERE lower(x.name)=lower(r.name));

-- === Convenience view for fast list with counts ===
CREATE OR REPLACE VIEW public.roles_with_counts AS
SELECT
  ro.id,
  ro.name,
  ro.description,
  ro.permissions,
  ro.created_at,
  ro.updated_at,
  COALESCE(u.cnt, 0)::int AS users_count
FROM public.roles ro
LEFT JOIN LATERAL (
  SELECT COUNT(*) AS cnt
  FROM public.users u
  WHERE lower(u.role) = lower(ro.name)
) u ON TRUE;

================================================================================
END FILE: remoteiq-minimal-e2e\backend\migrations\XXXX_roles_enhancements.sql
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\migrations\XXXX_add_users_roles.sql
================================================================================
-- migrations/XXXX_add_users_roles.sql
-- Users & Roles schema (idempotent)
-- Needed for gen_random_uuid() in some Postgres setups
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- -----------------------------
-- roles
-- -----------------------------
CREATE TABLE IF NOT EXISTS roles (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text UNIQUE NOT NULL,
    description text
);

-- Seed common roles (no duplicates)
INSERT INTO
    roles (name, description)
VALUES
    (
        'Owner',
        'Full access to all organization settings and data'
    ),
    (
        'Admin',
        'Manage users, settings, billing; full device access'
    ),
    ('User', 'Standard access') ON CONFLICT (name) DO NOTHING;

-- -----------------------------
-- users
-- -----------------------------
CREATE TABLE IF NOT EXISTS users (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL,
    email text UNIQUE NOT NULL,
    role text NOT NULL DEFAULT 'User',
    status text NOT NULL DEFAULT 'active',
    -- 'active' | 'suspended'
    two_factor_enabled boolean NOT NULL DEFAULT false,
    last_seen timestamptz,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- Useful indexes
CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);

CREATE INDEX IF NOT EXISTS idx_users_role ON users (role);

CREATE INDEX IF NOT EXISTS idx_users_status ON users (status);

-- -----------------------------
-- updated_at trigger
-- -----------------------------
CREATE
OR REPLACE FUNCTION set_users_updated_at() RETURNS trigger LANGUAGE plpgsql AS $ func $ BEGIN NEW.updated_at := now();

RETURN NEW;

END $ func $;

DROP TRIGGER IF EXISTS trg_users_updated_at ON users;

CREATE TRIGGER trg_users_updated_at BEFORE
UPDATE
    ON users FOR EACH ROW EXECUTE FUNCTION set_users_updated_at();

-- -----------------------------
-- Optional: seed a demo user if you want (email must be unique).
-- Comment out if you don't want any seed user here.
-- -----------------------------
INSERT INTO
    users (name, email, role, status, two_factor_enabled)
SELECT
    'Demo User',
    'demo@example.com',
    'User',
    'active',
    false
WHERE
    NOT EXISTS (
        SELECT
            1
        FROM
            users
        WHERE
            email = 'demo@example.com'
    );

================================================================================
END FILE: remoteiq-minimal-e2e\backend\migrations\XXXX_add_users_roles.sql
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\auth\policy.ts
================================================================================
export type PermissionGroup = {
    key: string;
    label: string;
    items: readonly {
        key: string;
        label: string;
        description?: string;
    }[];
};

export const PERMISSION_GROUPS = [
    {
        key: "users",
        label: "Users",
        items: [
            { key: "users.read", label: "View users" },
            { key: "users.write", label: "Create/edit users" },
            { key: "users.delete", label: "Remove users" },
            { key: "users.2fa.reset", label: "Reset 2FA" },
        ] as const,
    },
    {
        key: "roles",
        label: "Roles",
        items: [
            { key: "roles.read", label: "View roles" },
            { key: "roles.write", label: "Create/edit roles" },
            { key: "roles.delete", label: "Delete roles" },
        ] as const,
    },
    {
        key: "teams",
        label: "Teams",
        items: [
            { key: "teams.read", label: "View teams" },
            { key: "teams.write", label: "Create/edit teams" },
            { key: "teams.delete", label: "Delete teams" },
        ] as const,
    },
    {
        key: "billing",
        label: "Billing",
        items: [
            { key: "billing.read", label: "View billing" },
            { key: "billing.write", label: "Manage billing" },
        ] as const,
    },
    {
        key: "settings",
        label: "Settings",
        items: [
            { key: "settings.read", label: "View settings" },
            { key: "settings.write", label: "Manage settings" },
        ] as const,
    },
    {
        key: "backups",
        label: "Backups",
        items: [
            { key: "backups.read", label: "View config and history" },
            { key: "backups.run", label: "Start, retry or cancel backups" },
            { key: "backups.prune", label: "Prune artifacts" },
            { key: "backups.manage", label: "Configure/test destinations" },
            { key: "backups.restore", label: "Initiate restores" },
            { key: "backups.download", label: "Download artifacts" },
        ] as const,
    },
] as const satisfies readonly PermissionGroup[];

type PermissionItem = (typeof PERMISSION_GROUPS)[number]["items"][number];

export type Permission = PermissionItem["key"];

export type PermissionDefinition = PermissionItem & {
    groupKey: string;
    groupLabel: string;
};

export const PERMISSION_DEFINITIONS: PermissionDefinition[] = PERMISSION_GROUPS.flatMap(
    (group) =>
        group.items.map((item) => ({
            ...item,
            groupKey: group.key,
            groupLabel: group.label,
        }))
);

export const ALL_PERMISSIONS: Permission[] = PERMISSION_DEFINITIONS.map((d) => d.key);

// Optional role names if you still use a role -> default-permissions map somewhere
export type Role = "owner" | "admin" | "operator" | "viewer";

// Advisory defaults for built-in roles (guards still check req.user permissions).
export const rolePermissions: Record<Role, Permission[]> = {
    owner: [...ALL_PERMISSIONS],
    admin: [...ALL_PERMISSIONS],
    operator: [
        "users.read",
        "roles.read",
        "teams.read",
        "billing.read",
        "settings.read",
        "backups.read",
        "backups.run",
        "backups.download",
    ],
    viewer: [
        "users.read",
        "roles.read",
        "teams.read",
        "billing.read",
        "settings.read",
        "backups.read",
    ],
};

// ---- Helpers (optional, used by some older code paths) ----
export function permsForRoles(roles: string[] | undefined | null): Set<Permission> {
    const out = new Set<Permission>();
    if (!roles) return out;
    for (const r of roles) {
        const key = r as Role;
        const list = rolePermissions[key];
        if (list) list.forEach((p) => out.add(p));
    }
    return out;
}

export function hasPerm(roles: string[] | undefined | null, perm: Permission): boolean {
    return permsForRoles(roles).has(perm);
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\auth\policy.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\auth\permissions.guard.ts
================================================================================
import {
    CanActivate,
    ExecutionContext,
    ForbiddenException,
    Injectable,
} from "@nestjs/common";
import { Reflector } from "@nestjs/core";
import { REQUIRE_PERM_KEY, RequirePermMetadata } from "./require-perm.decorator";
import { PgPoolService } from "../storage/pg-pool.service";
import { permsForRoles } from "./policy";

@Injectable()
export class PermissionsGuard implements CanActivate {
    constructor(
        private readonly reflector: Reflector,
        private readonly db: PgPoolService
    ) { }

    async canActivate(ctx: ExecutionContext): Promise<boolean> {
        const req = ctx.switchToHttp().getRequest<any>();

        const required: RequirePermMetadata | undefined =
            this.reflector.getAllAndOverride<RequirePermMetadata>(REQUIRE_PERM_KEY, [
                ctx.getHandler(),
                ctx.getClass(),
            ]);

        const apiKey = req.header?.("x-admin-api-key") ?? req.headers?.["x-admin-api-key"];
        if (apiKey && process.env.ADMIN_API_KEY && apiKey === process.env.ADMIN_API_KEY) {
            return true;
        }

        const user = req.user;
        if (!user) throw new ForbiddenException("Not authenticated");

        if (!required || required.length === 0) return true;

        let userPerms = this.normalizePerms(user.permissions);

        if (userPerms.length === 0) {
            const roleHints = this.extractRoleNames(user);
            if (roleHints.length) {
                const defaults = permsForRoles(roleHints);
                if (defaults.size) {
                    userPerms = Array.from(defaults);
                }
            }
        }

        if (userPerms.length === 0 && user.id) {
            userPerms = await this.loadPermsFromRoles(user.id);
        }

        const userSet = new Set(userPerms.map((p) => p.toLowerCase()));

        for (const r of required) {
            const key = String(r).toLowerCase();
            if (!userSet.has(key)) {
                throw new ForbiddenException("Insufficient permissions");
            }
        }

        return true;
    }

    private normalizePerms(val: any): string[] {
        if (!val) return [];
        if (Array.isArray(val)) return val.map((x) => String(x).toLowerCase());
        if (typeof val === "object") return Object.keys(val).map((k) => k.toLowerCase());
        const s = String(val);
        if (s.includes(",")) {
            return s.split(",").map((x) => x.trim().toLowerCase()).filter(Boolean);
        }
        return [s.toLowerCase()];
    }

    private async loadPermsFromRoles(userId: string): Promise<string[]> {
        try {
            const { rows } = await this.db.query<{ permission_key: string }>(
                `SELECT DISTINCT rp.permission_key
           FROM public.user_roles ur
           JOIN public.role_permissions rp ON rp.role_id = ur.role_id
          WHERE ur.user_id = $1`,
                [userId],
            );
            return rows.map((r) => r.permission_key.toLowerCase());
        } catch {
            return [];
        }
    }

    private extractRoleNames(user: any): string[] {
        const out = new Set<string>();
        const push = (val: unknown) => {
            if (!val) return;
            const name = String(val).trim();
            if (name) out.add(name.toLowerCase());
        };

        if (Array.isArray(user?.roles)) user.roles.forEach(push);
        push(user?.role);
        push(user?.roleName);
        push(user?.role_name);
        if (user?.role?.name) push(user.role.name);

        return Array.from(out);
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\auth\permissions.guard.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\auth\require-perm.decorator.ts
================================================================================
import { SetMetadata } from "@nestjs/common";
import type { Permission } from "./policy";

/**
 * Metadata key consumed by the PermissionsGuard.
 * Always normalized to an array of Permission strings.
 */
export const REQUIRE_PERM_KEY = "require_perm";

/**
 * Attach one or more required permissions to a route or controller.
 *
 * Usage:
 *   @RequirePerm("backups.manage")
 *   @RequirePerm(["backups.read", "backups.download"])
 */
export const RequirePerm = (perm: Permission | Permission[]) =>
    SetMetadata(REQUIRE_PERM_KEY, Array.isArray(perm) ? perm : [perm]);

export type RequirePermMetadata = Permission[];

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\auth\require-perm.decorator.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\auth\auth-cookie.guard.ts
================================================================================
import {
    CanActivate,
    ExecutionContext,
    Injectable,
    UnauthorizedException,
} from "@nestjs/common";
import type { Request, Response } from "express";
import { JwtService } from "@nestjs/jwt";
import { PgPoolService } from "../storage/pg-pool.service";
import { randomUUID, createHash } from "crypto";

function parseCookieMaxAge(): number {
    const v = process.env.AUTH_COOKIE_MAX_AGE_MS;
    const n = Number(v);
    return Number.isFinite(n) && n > 0 ? n : 7 * 24 * 60 * 60 * 1000;
}

function hashToken(token: string): string {
    return createHash("sha256").update(token, "utf8").digest("hex");
}

type DbUserRow = {
    id: string;
    email: string;
    first_name: string | null;
    last_name: string | null;
    status: string;
    organization_id: string;
    roles: any;
    permissions: string[] | null;
};

function buildDisplayName(first: string | null, last: string | null, fallback?: string | null): string | null {
    const parts = [first?.trim(), last?.trim()].filter(Boolean) as string[];
    if (parts.length > 0) return parts.join(" ");
    return fallback ?? null;
}

@Injectable()
export class AuthCookieGuard implements CanActivate {
    constructor(
        private readonly jwt: JwtService,
        private readonly pg: PgPoolService,
    ) { }

    async canActivate(context: ExecutionContext): Promise<boolean> {
        const req = context.switchToHttp().getRequest<Request>();
        const res = context.switchToHttp().getResponse<Response>();

        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        const tokenFromCookie =
            (req as any).cookies?.[cookieName] ||
            (req as any).cookies?.["auth_token"];
        const tokenFromHeader =
            req.headers.authorization?.replace(/^Bearer\s+/i, "") || null;

        const token = tokenFromCookie || tokenFromHeader;
        if (!token) throw new UnauthorizedException("No auth token provided");

        let payload: any;
        try {
            payload = await this.jwt.verifyAsync(token, {
                secret: process.env.JWT_SECRET ?? "dev-secret",
            });
        } catch {
            throw new UnauthorizedException("Invalid token");
        }
        if (!payload?.sub) throw new UnauthorizedException("Invalid token payload");

        const userRow = await this.loadUserById(String(payload.sub));
        if (!userRow || userRow.status !== "active") {
            throw new UnauthorizedException("Account disabled");
        }

        const roles: string[] = Array.isArray(userRow.roles)
            ? userRow.roles.map((r: any) => String(r.name ?? r).trim()).filter(Boolean)
            : [];
        const permissions = Array.isArray(userRow.permissions)
            ? userRow.permissions.map((p) => String(p).toLowerCase())
            : [];
        const displayName = buildDisplayName(userRow.first_name, userRow.last_name, payload.name);
        const primaryRole = roles[0] || payload.role || "user";

        (req as any).user = {
            id: userRow.id,
            email: userRow.email,
            name: displayName,
            organizationId: userRow.organization_id,
            roles,
            role: primaryRole,
            permissions,
        };

        let jti: string | null = payload?.jti != null ? String(payload.jti) : null;
        if (!jti) {
            jti = randomUUID();
            const newToken = await this.jwt.signAsync({
                sub: payload.sub,
                email: payload.email,
                name: displayName,
                role: primaryRole,
                org: userRow.organization_id,
            perms: permissions,
                jti,
            });

            res.cookie(cookieName, newToken, {
                httpOnly: true,
                sameSite: "lax",
                secure: process.env.NODE_ENV === "production",
                path: "/",
                maxAge: parseCookieMaxAge(),
            });

            const ipHdr = (req.headers["x-forwarded-for"] as string) || "";
            const ip = (ipHdr.split(",")[0] || req.ip || "").trim() || null;
            const ua = req.get("user-agent") || null;

            await this.upsertSession(userRow.id, jti, ua, ip, hashToken(newToken));
        }

        (req as any).jti = jti;

        if (jti) {
            const ipHdr = (req.headers["x-forwarded-for"] as string) || "";
            const ip = (ipHdr.split(",")[0] || req.ip || "").trim() || null;
            const ua = req.get("user-agent") || null;
            this.pg
                .query(
                    `UPDATE sessions
             SET last_seen_at = now(),
                 ip_address = COALESCE($2, ip_address),
                 user_agent = COALESCE($3, user_agent)
           WHERE id = $1 AND revoked_at IS NULL`,
                    [jti, ip, ua],
                )
                .catch(() => { });
        }

        return true;
    }

    private async upsertSession(userId: string, sessionId: string, ua: string | null, ip: string | null, tokenHash: string) {
        await this.pg.query(
            `
        INSERT INTO sessions (id, user_id, refresh_token, user_agent, ip_address)
        VALUES ($2, $1, $3, $4, $5)
        ON CONFLICT (id) DO UPDATE
           SET last_seen_at = now(),
               user_agent   = COALESCE(EXCLUDED.user_agent, sessions.user_agent),
               ip_address   = COALESCE(EXCLUDED.ip_address, sessions.ip_address),
               refresh_token = EXCLUDED.refresh_token
        `,
            [userId, sessionId, tokenHash, ua || null, ip || null],
        );
    }

    private async loadUserById(userId: string): Promise<DbUserRow | null> {
        try {
            const { rows } = await this.pg.query<DbUserRow>(
                `SELECT
                    u.id,
                    u.email,
                    u.first_name,
                    u.last_name,
                    u.status,
                    u.organization_id,
                    COALESCE(jsonb_agg(DISTINCT jsonb_build_object('id', r.id, 'name', r.name))
                             FILTER (WHERE r.id IS NOT NULL), '[]'::jsonb) AS roles,
                    COALESCE(array_agg(DISTINCT rp.permission_key)
                             FILTER (WHERE rp.permission_key IS NOT NULL), '{}'::text[]) AS permissions
                 FROM public.users u
                 LEFT JOIN public.user_roles ur ON ur.user_id = u.id
                 LEFT JOIN public.roles r ON r.id = ur.role_id
                 LEFT JOIN public.role_permissions rp ON rp.role_id = r.id
                 WHERE u.id = $1
                 GROUP BY u.id`,
                [userId],
            );
            if (!rows.length) return null;
            const row = rows[0];
            return {
                ...row,
                roles: Array.isArray(row.roles) ? row.roles : [],
                permissions: Array.isArray(row.permissions) ? row.permissions : [],
            };
        } catch {
            return null;
        }
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\auth\auth-cookie.guard.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\common\guards\admin-api.guard.ts
================================================================================
import {
    CanActivate,
    ExecutionContext,
    Injectable,
    UnauthorizedException,
} from "@nestjs/common";

/**
 * Simple header-based guard:
 * - If ADMIN_API_KEY is not set, allow (dev-friendly)
 * - If set, require header: x-admin-api-key: <ADMIN_API_KEY>
 */
@Injectable()
export class AdminApiGuard implements CanActivate {
    canActivate(ctx: ExecutionContext): boolean {
        const req = ctx.switchToHttp().getRequest();
        const provided = req.headers["x-admin-api-key"] as string | undefined;

        // Dev fallback: no key set => allow
        const expected = process.env.ADMIN_API_KEY?.trim();
        if (!expected) return true;

        if (provided && provided === expected) return true;
        throw new UnauthorizedException("Invalid admin API key");
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\common\guards\admin-api.guard.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\common\admin-api.guard.ts
================================================================================
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from "@nestjs/common";

@Injectable()
export class AdminApiGuard implements CanActivate {
  canActivate(ctx: ExecutionContext): boolean {
    const req = ctx.switchToHttp().getRequest();
    const key = req.header("x-admin-api-key");
    const expected = process.env.ADMIN_API_KEY || "";
    if (!expected || key !== expected) {
      throw new UnauthorizedException("Invalid or missing x-admin-api-key");
    }
    return true;
  }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\common\admin-api.guard.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\roles\roles.service.ts
================================================================================
import {
    Injectable,
    BadRequestException,
    NotFoundException,
    ConflictException,
} from '@nestjs/common';
import { PgPoolService } from '../storage/pg-pool.service';
import { OrganizationContextService } from '../storage/organization-context.service';
import { ALL_PERMISSIONS, Permission } from '../auth/policy';

export type RoleDto = {
    id: string;
    name: string;
    description?: string;
    permissions: string[];
    usersCount: number;
    createdAt: string;
    updatedAt: string;
};

export type CreateRoleDto = {
    name: string;
    description?: string;
    permissions?: string[];
};

export type UpdateRoleDto = Partial<{
    name: string;
    description: string | null;
    permissions: string[]; // full replace
}>;

const PROTECTED_NAMES = new Set(['owner', 'admin']);
const FULL_LOCK_NAME = 'owner';
const VALID_PERMISSIONS = new Set<Permission>(ALL_PERMISSIONS);

type RoleRecord = {
    id: string;
    name: string;
    scope: 'system' | 'organization';
    organization_id: string | null;
    description: string | null;
};

function isUuid(v: string) {
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);
}

function normalizePermissions(perms?: string[]): Permission[] {
    if (!perms || !perms.length) return [];
    const invalid: string[] = [];
    const out = new Set<Permission>();

    for (const raw of perms) {
        if (!raw) continue;
        const key = raw.trim().toLowerCase() as Permission;
        if (!VALID_PERMISSIONS.has(key)) {
            invalid.push(raw);
            continue;
        }
        out.add(key);
    }

    if (invalid.length) {
        throw new BadRequestException(`Unknown permission(s): ${invalid.join(', ')}`);
    }

    return Array.from(out);
}

@Injectable()
export class RolesService {
    constructor(
        private readonly db: PgPoolService,
        private readonly orgs: OrganizationContextService,
    ) { }

    async list(): Promise<RoleDto[]> {
        const orgId = await this.orgs.getDefaultOrganizationId();
        const sql = `
      SELECT
        r.id,
        r.name,
        COALESCE(r.description, '') AS description,
        COALESCE(array_agg(DISTINCT rp.permission_key)
                 FILTER (WHERE rp.permission_key IS NOT NULL),
                 '{}'::text[]) AS permissions,
        (
          SELECT COUNT(*)::int
          FROM public.user_roles ur
          WHERE ur.role_id = r.id
        ) AS "usersCount",
        r.created_at AS "createdAt",
        r.updated_at AS "updatedAt"
      FROM public.roles r
      LEFT JOIN public.role_permissions rp
        ON rp.role_id = r.id
      WHERE
        (r.scope = 'system')
        OR (r.organization_id = $1)
      GROUP BY r.id
      ORDER BY lower(r.name) ASC;
    `;
        const { rows } = await this.db.query(sql, [orgId]);
        return rows.map((r: any) => ({
            id: r.id,
            name: r.name,
            description: r.description ?? undefined,
            permissions: Array.isArray(r.permissions) ? r.permissions : [],
            usersCount: Number(r.usersCount ?? 0),
            createdAt: r.createdAt,
            updatedAt: r.updatedAt,
        }));
    }

    async create(payload: CreateRoleDto): Promise<{ id: string }> {
        const name = (payload.name ?? '').trim();
        if (name.length < 2 || name.length > 64) {
            throw new BadRequestException('Name must be 2–64 characters.');
        }

        const orgId = await this.orgs.getDefaultOrganizationId();
        const exists = await this.db.query(
            `SELECT 1
         FROM public.roles
        WHERE lower(name) = lower($2)
          AND ((scope = 'organization' AND organization_id = $1) OR scope = 'system')
        LIMIT 1;`,
            [orgId, name],
        );
        if ((exists.rows?.length ?? 0) > 0) {
            throw new ConflictException('Role name must be unique (case-insensitive).');
        }

        const desc = payload.description?.trim() || null;
        const perms = normalizePermissions(payload.permissions);

        const insRole = await this.db.query(
            `INSERT INTO public.roles (organization_id, scope, name, description)
             VALUES ($1, 'organization', $2, $3)
             RETURNING id;`,
            [orgId, name, desc],
        );
        const id = insRole.rows[0].id as string;

        await this.replaceRolePermissions(id, perms);

        return { id };
    }

    async getById(id: string): Promise<{ id: string; name: string }> {
        if (!isUuid(id)) throw new BadRequestException('Invalid role id.');
        const role = await this.fetchRoleById(id);
        return { id: role.id, name: role.name };
    }

    async update(id: string, patch: UpdateRoleDto): Promise<void> {
        const { name: newNameRaw, description, permissions } = patch;
        const role = await this.fetchRoleById(id);

        const oldLower = role.name.trim().toLowerCase();
        const normalizedPerms = permissions === undefined ? null : normalizePermissions(permissions ?? []);

        if (newNameRaw !== undefined) {
            const newName = newNameRaw.trim();
            if (newName.length < 2 || newName.length > 64) {
                throw new BadRequestException('Name must be 2–64 characters.');
            }
            if (role.scope === 'system' || oldLower === FULL_LOCK_NAME) {
                throw new BadRequestException('The "Owner" role cannot be renamed.');
            }
            if (newName.toLowerCase() !== oldLower) {
                const exists = await this.db.query(
                    `SELECT 1
             FROM public.roles
            WHERE id <> $1
              AND lower(name)=lower($2)
              AND ((scope='organization' AND organization_id = $3) OR scope='system')
            LIMIT 1;`,
                    [id, newName, role.organization_id],
                );
                if ((exists.rows?.length ?? 0) > 0) {
                    throw new ConflictException('Role name must be unique (case-insensitive).');
                }

                await this.db.query(`UPDATE public.roles SET name=$1 WHERE id=$2;`, [newName, id]);
                role.name = newName;
            }
        }

        if (description !== undefined) {
            await this.db.query(
                `UPDATE public.roles SET description = $1 WHERE id = $2`,
                [description ?? null, id],
            );
        }

        if (normalizedPerms !== null) {
            await this.replaceRolePermissions(id, normalizedPerms);
        }
    }

    // Fixed: implement remove(...) and remove the stray duplicate method signature.
    async remove(roleId: string): Promise<void> {
        if (!isUuid(roleId)) throw new BadRequestException('Invalid role id.');

        const role = await this.fetchRoleById(roleId);
        const lower = role.name.trim().toLowerCase();
        if (role.scope === 'system' || PROTECTED_NAMES.has(lower)) {
            throw new BadRequestException('This role is protected and cannot be deleted.');
        }

        const assigned = await this.db.query(
            `SELECT 1 FROM public.user_roles WHERE role_id = $1 LIMIT 1;`,
            [roleId],
        );
        if (assigned.rows.length > 0) {
            throw new BadRequestException('Cannot delete a role that still has users assigned.');
        }

        await this.db.query(`DELETE FROM public.roles WHERE id=$1;`, [roleId]);
    }

    private async replaceRolePermissions(roleId: string, permissions: Permission[]): Promise<void> {
        await this.db.query(`DELETE FROM public.role_permissions WHERE role_id=$1;`, [roleId]);
        if (!permissions.length) return;
        await this.db.query(
            `INSERT INTO public.role_permissions (role_id, permission_key)
             SELECT $1, perm
             FROM unnest($2::text[]) AS perm`,
            [roleId, permissions],
        );
    }

    private async fetchRoleById(id: string): Promise<RoleRecord> {
        const { rows } = await this.db.query<RoleRecord>(
            `SELECT id, name, scope, organization_id, description
             FROM public.roles
             WHERE id = $1
             LIMIT 1`,
            [id],
        );
        if (!rows.length) throw new NotFoundException('Role not found.');
        return rows[0];
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\roles\roles.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\roles\permissions-introspect.service.ts
================================================================================
import { Injectable, Logger, OnModuleInit } from "@nestjs/common";
import { randomUUID } from "crypto";
import { PgPoolService } from "../storage/pg-pool.service";
import { OrganizationContextService } from "../storage/organization-context.service";
import {
    ALL_PERMISSIONS,
    PERMISSION_DEFINITIONS,
    PERMISSION_GROUPS,
    PermissionDefinition,
    rolePermissions,
} from "../auth/policy";

export type PermissionGroupDto = {
    key: string;
    label: string;
    items: { key: string; label: string; description?: string }[];
};

@Injectable()
export class PermissionsIntrospectService implements OnModuleInit {
    private readonly logger = new Logger(PermissionsIntrospectService.name);

    constructor(
        private readonly db: PgPoolService,
        private readonly orgs: OrganizationContextService,
    ) { }

    async onModuleInit(): Promise<void> {
        try {
            const tablesReady = await this.ensureAclTablesExist();
            if (!tablesReady) return;
            await this.syncPermissionCatalog();
            await this.ensureBuiltInRoles();
        } catch (err) {
            this.logger.warn(`Failed to seed permissions catalog: ${(err as Error)?.message ?? err}`);
        }
    }

    listDistinctPermissionKeys(): Promise<string[]> {
        return Promise.resolve([...ALL_PERMISSIONS]);
    }

    listPermissionDefinitions(): Promise<PermissionDefinition[]> {
        return Promise.resolve([...PERMISSION_DEFINITIONS]);
    }

    listPermissionGroups(): Promise<PermissionGroupDto[]> {
        const groups: PermissionGroupDto[] = PERMISSION_GROUPS.map((group) => ({
            key: group.key,
            label: group.label,
            items: group.items.map((item) => ({
                key: item.key,
                label: item.label,
                description: item.description,
            })),
        }));
        return Promise.resolve(groups);
    }

    private async ensureAclTablesExist(): Promise<boolean> {
        const { rows } = await this.db.query(
            `SELECT
         to_regclass('public.permissions')  AS permissions,
         to_regclass('public.role_permissions') AS role_permissions,
         to_regclass('public.user_roles') AS user_roles,
         to_regclass('public.roles') AS roles`
        );
        const hasAll = Boolean(
            rows?.[0]?.permissions && rows?.[0]?.role_permissions && rows?.[0]?.roles && rows?.[0]?.user_roles
        );
        if (!hasAll) {
            this.logger.warn("ACL tables missing; skip permission seeding until migrations run.");
        }
        return hasAll;
    }

    private async syncPermissionCatalog(): Promise<void> {
        const payload = JSON.stringify(
            PERMISSION_DEFINITIONS.map((d) => ({
                permission_key: d.key,
                label: d.label,
                group_key: d.groupKey,
                group_label: d.groupLabel,
            }))
        );

        await this.db.query(
            `WITH defs AS (
        SELECT *
        FROM jsonb_to_recordset($1::jsonb)
          AS x(permission_key text, label text, group_key text, group_label text)
      )
      INSERT INTO public.permissions (permission_key, label, group_key, group_label)
      SELECT permission_key, label, group_key, group_label
      FROM defs
      ON CONFLICT (permission_key) DO UPDATE
        SET label = EXCLUDED.label,
            group_key = EXCLUDED.group_key,
            group_label = EXCLUDED.group_label`,
            [payload],
        );
    }

    private async ensureBuiltInRoles(): Promise<void> {
        const orgId = await this.orgs.getDefaultOrganizationId();
        const defaults: Array<{ name: string; description: string; perms: string[] }> = [
            { name: "Owner", description: "Full system access", perms: rolePermissions.owner },
            { name: "Admin", description: "Administrative access", perms: rolePermissions.admin },
        ];

        for (const def of defaults) {
            const res = await this.db.query<{ id: string }>(
                `SELECT id FROM public.roles
                 WHERE lower(name)=lower($1)
                   AND ((scope='organization' AND organization_id=$2) OR scope='system')
                 LIMIT 1`,
                [def.name, orgId]
            );

            let roleId = res.rows?.[0]?.id;
            if (!roleId) {
                roleId = randomUUID();
                await this.db.query(
                    `INSERT INTO public.roles (id, organization_id, scope, name, description)
                     VALUES ($1, $2, 'organization', $3, $4)
                     ON CONFLICT (id) DO NOTHING`,
                    [roleId, orgId, def.name, def.description]
                );
            } else {
                await this.db.query(
                    `UPDATE public.roles
                        SET description = COALESCE($2, description)
                      WHERE id = $1`,
                    [roleId, def.description],
                );
            }

            await this.replacePermissions(roleId, def.perms);
        }
    }

    private async replacePermissions(roleId: string, perms: string[]): Promise<void> {
        await this.db.query(`DELETE FROM public.role_permissions WHERE role_id = $1`, [roleId]);
        if (!perms.length) return;
        await this.db.query(
            `INSERT INTO public.role_permissions (role_id, permission_key)
             SELECT $1, perm
             FROM unnest($2::text[]) AS perm`,
            [roleId, perms],
        );
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\roles\permissions-introspect.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\roles\roles.controller.ts
================================================================================
import {
    Body,
    Controller,
    Delete,
    Get,
    Param,
    ParseUUIDPipe,
    Patch,
    Post,
    UseGuards,
} from '@nestjs/common';
import { RolesService } from './roles.service';
import { CreateRoleDto, UpdateRoleDto } from './dto';
import { PermissionsGuard } from '../auth/permissions.guard';
import { RequirePerm } from '../auth/require-perm.decorator';

@UseGuards(PermissionsGuard)
@Controller('api/roles')
export class RolesController {
    constructor(private readonly svc: RolesService) { }

    @Get()
    @RequirePerm('roles.read')
    list() {
        return this.svc.list();
    }

    @Post()
    @RequirePerm('roles.write')
    create(@Body() body: CreateRoleDto) {
        return this.svc.create(body);
    }

    @Patch(':id')
    @RequirePerm('roles.write')
    async update(
        @Param('id', new ParseUUIDPipe({ version: '4' })) id: string,
        @Body() body: UpdateRoleDto,
    ) {
        await this.svc.update(id, body);
        return { ok: true };
    }

    @Delete(':id')
    @RequirePerm('roles.delete')
    async remove(@Param('id', new ParseUUIDPipe({ version: '4' })) id: string) {
        await this.svc.remove(id);
        return { ok: true };
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\roles\roles.controller.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\users\me.controller.ts
================================================================================
//backend\src\users\me.controller.ts

import {
    Controller,
    Get,
    Patch,
    Body,
    UseInterceptors,
    UploadedFile,
    Post,
    Delete,
    Req,
    BadRequestException,
    UnauthorizedException,
} from "@nestjs/common";
import { FileInterceptor } from "@nestjs/platform-express";
import { diskStorage } from "multer";
import type { Request } from "express";
import { MeService } from "./me.service";

/* ----------------------------- MIME → EXT map ----------------------------- */
const EXT_BY_MIME: Record<string, string> = {
    "image/png": ".png",
    "image/jpeg": ".jpg",
    "image/webp": ".webp",
    "image/gif": ".gif",
};

/* ----------------------------- Rate limit (simple) ----------------------------- */
/** Allow one upload per user every 5 seconds (in-memory, per-instance). */
const UPLOAD_RATE_MS = 5_000;
const lastUploadByUser = new Map<string, number>();

/* ----------------------------- Multer callbacks ----------------------------- */
/** filename: (req, file, cb: (err: Error|null, filename: string) => void) => void */
function filenameCb(
    _req: any,
    file: Express.Multer.File,
    callback: (error: Error | null, filename: string) => void,
) {
    // derive extension from mime for consistency and safety
    const ext = EXT_BY_MIME[file.mimetype] ?? ".bin";
    // remove suspicious chars from provided name (if we keep it), and trim to avoid gigantic filenames
    const base =
        (file.originalname || "upload")
            .replace(/[^\w.\-]+/g, "_")
            .replace(/\.[A-Za-z0-9]+$/, "") // strip user-provided extension
            .slice(0, 80) || "upload";
    const safe = `${Date.now()}_${base}${ext}`;
    callback(null, safe);
}

/** fileFilter: (req, file, cb: (err: Error|null, accept: boolean) => void) => void */
function imageFilter(
    _req: any,
    file: Express.Multer.File,
    callback: (error: Error | null, acceptFile: boolean) => void,
) {
    const ok = !!EXT_BY_MIME[file.mimetype];
    if (!ok) return callback(new BadRequestException("Unsupported file type"), false);
    return callback(null, true);
}

/* ----------------------------- URL Builder ----------------------------- */
/**
 * Build an ABSOLUTE URL to the static mount that always works and never double-prefixes.
 * Rules:
 * - If PUBLIC_BASE_URL is set, use it as the host origin (no trailing slash).
 * - Otherwise derive protocol/host from the request.
 * - Ensure exactly one '/static' segment before '/uploads/...'.
 *
 * Examples that all yield a single '/static/uploads/...':
 *   PUBLIC_BASE_URL=http://localhost:3001         -> http://localhost:3001/static/uploads/<file>
 *   PUBLIC_BASE_URL=http://localhost:3001/static  -> http://localhost:3001/static/uploads/<file>
 *   PUBLIC_BASE_URL not set                       -> http(s)://<req host>/static/uploads/<file>
 */
function buildStaticUploadUrl(req: Request, filename: string): string {
    const raw = (process.env.PUBLIC_BASE_URL || "").trim().replace(/\/+$/, ""); // strip trailing '/'
    let origin: string;
    if (raw) {
        // If the env already ends with '/static', keep it; else append '/static'
        const staticBase = raw.endsWith("/static") ? raw : `${raw}/static`;
        origin = staticBase;
    } else {
        // derive from request
        const proto =
            (req.headers["x-forwarded-proto"] as string) ||
            (req.protocol || "http");
        const host = req.get("host") || "localhost:3001";
        origin = `${proto}://${host}/static`;
    }
    return `${origin}/uploads/${encodeURIComponent(filename)}`;
}

@Controller("/api/users")
export class MeController {
    constructor(private readonly me: MeService) { }

    // Current user profile
    @Get("me")
    async getMe(@Req() req: any) {
        const userId = req.user?.id; // set by your cookie middleware
        if (!userId) throw new UnauthorizedException("Not authenticated");
        return this.me.getMe(userId);
    }

    // Partial update
    @Patch("me")
    async patchMe(@Req() req: any, @Body() body: any) {
        const userId = req.user?.id;
        if (!userId) throw new UnauthorizedException("Not authenticated");
        return this.me.updateMe(userId, body);
    }

    // Upload avatar (multipart/form-data; field name: "file")
    @Post("me/avatar")
    @UseInterceptors(
        FileInterceptor("file", {
            storage: diskStorage({
                destination: "public/uploads",
                filename: filenameCb,
            }),
            limits: {
                fileSize: Math.max(
                    1,
                    (Number(process.env.AVATAR_MAX_MB) || 5) * 1024 * 1024,
                ), // default 5 MB
            },
            fileFilter: imageFilter,
        }),
    )
    async uploadAvatar(@Req() req: Request & { user?: any }, @UploadedFile() file: Express.Multer.File) {
        const userId = req.user?.id;
        if (!userId) throw new UnauthorizedException("Not authenticated");
        if (!file) throw new BadRequestException("No file uploaded");

        // rate-limit: N ms between uploads per user
        const now = Date.now();
        const last = lastUploadByUser.get(userId) || 0;
        if (now - last < UPLOAD_RATE_MS) {
            throw new BadRequestException("You're uploading too fast. Please wait a moment and try again.");
        }
        lastUploadByUser.set(userId, now);

        // Build a correct, absolute URL that points to ServeStatic '/static'
        const url = buildStaticUploadUrl(req, file.filename);

        // Save in DB; also sets avatar_thumb_url (same as main for now) and deletes previous local file if any
        await this.me.replaceAvatarUrl(userId, url);

        return { url };
    }

    // Remove avatar
    @Delete("me/avatar")
    async deleteAvatar(@Req() req: any) {
        const userId = req.user?.id;
        if (!userId) throw new UnauthorizedException("Not authenticated");

        await this.me.replaceAvatarUrl(userId, null);
        return { ok: true };
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\users\me.controller.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\users\me.service.ts
================================================================================
import { Injectable } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";
import * as fs from "fs/promises";
import * as path from "path";

@Injectable()
export class MeService {
    constructor(private readonly pg: PgPoolService) { }

    // Compose a public URL for files served from /public (not used by controller anymore, but kept for compatibility)
    makePublicUrl(filename: string) {
        const base = (process.env.PUBLIC_BASE_URL || "").replace(/\/+$/, "");
        const staticBase = base ? (base.endsWith("/static") ? base : `${base}/static`) : "";
        return staticBase ? `${staticBase}/uploads/${filename}` : `/static/uploads/${filename}`;
    }

    /* ------------------------------ Helpers for local file cleanup ------------------------------ */

    /** Extract a local filesystem path for files under `/static/uploads/<name>` or `/uploads/<name>` */
    private toLocalUploadPathFromUrl(url?: string | null): string | null {
        if (!url) return null;
        let pathname = "";
        try {
            // absolute http(s) url
            const u = new URL(url);
            pathname = u.pathname;
        } catch {
            // not a full URL; treat as pathname-like
            pathname = url;
        }

        // Normalize where '/uploads/...' might appear (with or without /static prefix)
        const idx = pathname.indexOf("/uploads/");
        if (idx === -1) return null;

        const filename = pathname.substring(idx + "/uploads/".length);
        if (!filename || filename.includes("..")) return null;

        // Resolve to <project>/public/uploads/<filename>
        const uploadsDir = path.join(__dirname, "..", "public", "uploads");
        const abs = path.join(uploadsDir, filename);

        // Ensure file stays inside uploads dir (avoid traversal)
        const normUploads = path.normalize(uploadsDir + path.sep);
        const normFile = path.normalize(abs);
        if (!normFile.startsWith(normUploads)) return null;

        return normFile;
    }

    private async tryDeleteLocalFile(filePath: string | null) {
        if (!filePath) return;
        try {
            await fs.unlink(filePath);
        } catch {
            // swallow (file may not exist or we lack perms; not fatal)
        }
    }

    /* ------------------------------------ Profile CRUD ------------------------------------ */

    async getMe(userId: string) {
        const q = `
      select id, name, email,
             coalesce(phone, '') as phone,
             coalesce(timezone, '') as timezone,
             coalesce(locale, '') as locale,
             coalesce(avatar_url, '') as "avatarUrl",
             coalesce(avatar_thumb_url, '') as "avatarThumbUrl",
             coalesce(address1, '') as address1,
             coalesce(address2, '') as address2,
             coalesce(city, '') as city,
             coalesce(state, '') as state,
             coalesce(postal, '') as postal,
             coalesce(country, '') as country
      from users
      where id = $1
      limit 1
    `;
        const { rows } = await this.pg.query(q, [userId]);
        return rows[0] || {};
    }

    async updateMe(userId: string, patch: Record<string, any>) {
        // Only accept known columns; convert avatarUrl -> avatar_url
        const map: Record<string, string> = {
            name: "name",
            email: "email",
            phone: "phone",
            timezone: "timezone",
            locale: "locale",
            avatarUrl: "avatar_url",
            address1: "address1",
            address2: "address2",
            city: "city",
            state: "state",
            postal: "postal",
            country: "country",
        };

        const sets: string[] = [];
        const vals: any[] = [];
        let i = 1;

        for (const [k, v] of Object.entries(patch || {})) {
            const col = map[k];
            if (!col) continue;
            sets.push(`${col} = $${i++}`);
            vals.push(v);
            // keep thumb in sync if avatarUrl is set directly through PATCH
            if (col === "avatar_url") {
                sets.push(`avatar_thumb_url = $${i++}`);
                vals.push(v);
            }
        }
        if (sets.length === 0) {
            return this.getMe(userId);
        }
        vals.push(userId);

        const sql = `update users set ${sets.join(", ")}, updated_at = now() where id = $${i} returning id`;
        await this.pg.query(sql, vals);
        return this.getMe(userId);
    }

    /**
     * Replace avatar URLs and delete the previous local file (if any and if it was under /uploads).
     * If `nextUrl` is null, clears both avatar fields and removes old local file.
     */
    async replaceAvatarUrl(userId: string, nextUrl: string | null) {
        // first, read previous urls
        const { rows: prevRows } = await this.pg.query<{ avatar_url: string | null; avatar_thumb_url: string | null }>(
            `select avatar_url, avatar_thumb_url from users where id = $1 limit 1`,
            [userId],
        );
        const prev = prevRows[0] || { avatar_url: null, avatar_thumb_url: null };

        // upsert new URL(s); for now thumb mirrors the main url
        await this.pg.query(
            `update users
         set avatar_url = $2,
             avatar_thumb_url = $3,
             updated_at = now()
       where id = $1`,
            [userId, nextUrl, nextUrl],
        );

        // delete the previous local file if it lived under /uploads and is different than new
        const oldUrl = prev.avatar_url;
        if (oldUrl && oldUrl !== nextUrl) {
            const localPath = this.toLocalUploadPathFromUrl(oldUrl);
            await this.tryDeleteLocalFile(localPath);
        }

        // return updated profile
        return this.getMe(userId);
    }

    /** Kept for compatibility with earlier calls; now delegates to replaceAvatarUrl */
    async setAvatarUrl(userId: string, url: string | null) {
        return this.replaceAvatarUrl(userId, url);
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\users\me.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\app.module.ts
================================================================================
// remoteiq-minimal-e2e/backend/src/app.module.ts

import { Module, MiddlewareConsumer, NestModule } from "@nestjs/common";
import { ServeStaticModule } from "@nestjs/serve-static";
import { join } from "path";

import { CommonModule } from "./common/common.module";
import { AuthModule } from "./auth/auth.module";
import { WsModule } from "./ws/ws.module";
import { AgentsModule } from "./agents/agents.module";
import { JobsModule } from "./jobs/jobs.module";
import { DevicesModule } from "./devices/devices.module";
import { HealthModule } from "./health/health.module";
import { AdminModule } from "./admin/admin.module";
import { CompanyModule } from "./company/company.module";
import { BrandingModule } from "./branding/branding.module";
import { LocalizationModule } from "./localization/localization.module";
import { SupportModule } from "./support/support.module";
import { SupportLegalModule } from "./support-legal/support-legal.module";
import { UsersModule } from "./users/users.module";
import { RolesModule } from "./roles/roles.module";
import { SmtpModule } from "./smtp/smtp.module";
import { ScheduleModule } from "@nestjs/schedule";
import { ImapModule } from "./imap/imap.module";
import { SessionCleanerService } from "./maintenance/session-cleaner.service";
import { CustomersModule } from "./customers/customers.module";
import { BackupsModule } from "./backups/backups.module";

import { JwtModule } from "@nestjs/jwt";

// ✅ correct path: the middleware file is under /auth, not /common
import { AuthCookieMiddleware } from "./auth/auth-cookie.middleware";

// ✅ bring PgPoolService into the AppModule DI context
import { StorageModule } from "./storage/storage.module";

// ✅ NEW: Tickets
import { TicketsModule } from "./tickets/tickets.module";

@Module({
    imports: [
        // Static files mounted at /static -> maps to /public
        ServeStaticModule.forRoot({
            rootPath: join(__dirname, "..", "public"),
            serveRoot: "/static",
        }),

        // JwtService for middleware
        JwtModule.register({
            secret: process.env.JWT_SECRET ?? "dev-secret",
        }),

        // Base/shared
        CommonModule,

        // ✅ Storage (PgPoolService) must be available for main.ts interceptor registration
        StorageModule,

        // Feature modules
        BrandingModule,
        AuthModule,
        WsModule,
        AgentsModule,
        JobsModule,
        DevicesModule,
        HealthModule,
        AdminModule,
        CompanyModule,
        LocalizationModule,
        SupportModule,
        SupportLegalModule,
        UsersModule,
        RolesModule,
        CustomersModule,

        // Backups Module
        BackupsModule,

        // ✅ Tickets module
        TicketsModule,

        // SMTP + IMAP
        SmtpModule,
        ScheduleModule.forRoot(),
        ImapModule,
    ],
    providers: [
        // Daily cleanup of revoked sessions
        SessionCleanerService,
    ],
})
export class AppModule implements NestModule {
    configure(consumer: MiddlewareConsumer) {
        // Apply cookie->req.user middleware to everything except obvious public/static routes
        consumer
            .apply(AuthCookieMiddleware)
            .exclude(
                "healthz",
                "docs",
                "docs/(.*)",
                "static/(.*)",      // static files
                "api/auth/login",   // login doesn’t need req.user
                "api/auth/logout"   // logout doesn’t need req.user
            )
            .forRoutes("*");
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\app.module.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\admin\admin.module.ts
================================================================================
// backend/src/admin/admin.module.ts
// (No company imports here; this module is only for "admin" endpoints like database config.)
import { Module } from "@nestjs/common";
import { DatabaseController } from "./database.controller";
import { DatabaseService } from "./database.service";
import { StorageModule } from "../storage/storage.module";

@Module({
    imports: [StorageModule],
    controllers: [DatabaseController],
    providers: [DatabaseService],
    exports: [DatabaseService],
})
export class AdminModule { }

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\admin\admin.module.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\admin\database.controller.ts
================================================================================
// backend/src/admin/database.controller.ts
import { Body, Controller, Get, HttpCode, Post, UsePipes, ValidationPipe } from "@nestjs/common";
import { DatabaseConfigDto, TestResultDto } from "./database.dto";
import { DatabaseService } from "./database.service";

@UsePipes(new ValidationPipe({ whitelist: true, transform: true }))
@Controller("/api/admin/database")
export class DatabaseController {
    constructor(private readonly svc: DatabaseService) { }

    @Get()
    async getConfig(): Promise<DatabaseConfigDto | { enabled: false }> {
        const cfg = this.svc.getConfig() ?? (await this.svc.loadConfig());
        return cfg ?? { enabled: false } as any;
    }

    @Post("test")
    @HttpCode(200)
    async test(@Body() body: DatabaseConfigDto): Promise<TestResultDto> {
        return this.svc.testConnection(body);
    }

    @Post("save")
    @HttpCode(204)
    async save(@Body() body: DatabaseConfigDto): Promise<void> {
        // Optional: you could also re-test here and reject on failure
        await this.svc.saveConfig(body);
    }

    // Stub endpoint your UI can call for the "Dry-run migration" button
    @Post("migrate/dry-run")
    async dryRun(): Promise<{ ok: true; destructive: false; steps: string[] }> {
        return {
            ok: true,
            destructive: false,
            steps: [
                "Verify connectivity to primary",
                "Check presence of required tables/collections",
                "Plan non-destructive CREATEs/INDEXes if missing",
            ],
        };
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\admin\database.controller.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\admin\database.dto.ts
================================================================================
// backend/src/admin/database.dto.ts
import { IsBoolean, IsEnum, IsInt, IsObject, IsOptional, IsString, Max, Min } from "class-validator";
import { Transform, Type } from "class-transformer";

export type DbEngine = "postgresql" | "mysql" | "mssql" | "sqlite" | "mongodb";
export type DbAuthMode = "fields" | "url";
export type StorageDomain =
    | "users" | "roles" | "sessions" | "audit_logs" | "devices" | "policies" | "email_queue";

export class DatabaseMappingsDto {
    @IsString() users!: string;
    @IsString() roles!: string;
    @IsString() sessions!: string;
    @IsString() audit_logs!: string;
    @IsString() devices!: string;
    @IsString() policies!: string;
    @IsString() email_queue!: string;
}

export class DatabaseConfigDto {
    @IsBoolean() enabled!: boolean;

    @IsEnum(["postgresql", "mysql", "mssql", "sqlite", "mongodb"])
    engine!: DbEngine;

    @IsEnum(["fields", "url"])
    authMode!: DbAuthMode;

    // url mode
    @IsOptional() @IsString() url?: string;

    // fields mode
    @IsOptional() @IsString() host?: string;

    @IsOptional()
    @IsInt() @Min(1) @Max(65535)
    @Transform(({ value }) => (value != null ? parseInt(value, 10) : undefined))
    port?: number;

    @IsOptional() @IsString() dbName?: string;
    @IsOptional() @IsString() username?: string;
    @IsOptional() @IsString() password?: string;

    @IsBoolean() ssl!: boolean;

    @IsInt() @Min(0) @Max(1000) poolMin!: number;
    @IsInt() @Min(1) @Max(5000) poolMax!: number;

    @IsOptional() @IsString()
    readReplicas?: string; // comma-separated URLs

    @IsObject() @Type(() => DatabaseMappingsDto)
    mappings!: DatabaseMappingsDto;
}

export class TestResultDto {
    ok!: boolean;
    engine!: DbEngine;
    primary!: { ok: boolean; message?: string };
    replicas?: Array<{ url: string; ok: boolean; message?: string }>;
    note?: string;
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\admin\database.dto.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\admin\database.service.ts
================================================================================
// backend/src/admin/database.service.ts
import { Injectable } from "@nestjs/common";
import { DatabaseConfigDto, TestResultDto, DbEngine } from "./database.dto";
import * as fs from "node:fs/promises";
import * as path from "node:path";

const CONFIG_DIR = path.resolve(process.cwd(), "config");
const CONFIG_PATH = path.join(CONFIG_DIR, "database.json");

// Redact helpers
const redact = (s?: string | null) => (s ? "****" : s);

@Injectable()
export class DatabaseService {
    private current: DatabaseConfigDto | null = null;

    async loadConfig(): Promise<DatabaseConfigDto | null> {
        try {
            const raw = await fs.readFile(CONFIG_PATH, "utf-8");
            this.current = JSON.parse(raw);
            return this.current;
        } catch {
            return null;
        }
    }

    async saveConfig(cfg: DatabaseConfigDto): Promise<void> {
        await fs.mkdir(CONFIG_DIR, { recursive: true });
        await fs.writeFile(CONFIG_PATH, JSON.stringify(cfg, null, 2), "utf-8");
        this.current = cfg;
    }

    getConfig(): DatabaseConfigDto | null {
        return this.current;
    }

    // Build a connection URL from "fields" mode if needed
    buildUrl(cfg: DatabaseConfigDto): string | null {
        if (cfg.authMode === "url") return cfg.url || null;
        const host = cfg.host ?? "localhost";
        const port = cfg.port ?? this.defaultPort(cfg.engine);
        const db = cfg.dbName ?? "";
        const user = cfg.username ?? "";
        const pass = cfg.password ? encodeURIComponent(cfg.password) : "";
        switch (cfg.engine) {
            case "postgresql":
                return user
                    ? `postgres://${user}:${pass}@${host}:${port}/${db}${cfg.ssl ? "?sslmode=require" : ""}`
                    : `postgres://${host}:${port}/${db}${cfg.ssl ? "?sslmode=require" : ""}`;
            case "mysql":
                return user
                    ? `mysql://${user}:${pass}@${host}:${port}/${db}`
                    : `mysql://${host}:${port}/${db}`;
            case "mssql":
                return user
                    ? `mssql://${user}:${pass}@${host}:${port}/${db}`
                    : `mssql://${host}:${port}/${db}`;
            case "sqlite":
                // dbName serves as filepath
                return `file:${db || "remoteiq.sqlite"}?mode=rwc`;
            case "mongodb":
                return user
                    ? `mongodb://${user}:${pass}@${host}:${port}/${db}${cfg.ssl ? "?tls=true" : ""}`
                    : `mongodb://${host}:${port}/${db}${cfg.ssl ? "?tls=true" : ""}`;
            default:
                return null;
        }
    }

    defaultPort(engine: DbEngine): number {
        switch (engine) {
            case "postgresql": return 5432;
            case "mysql": return 3306;
            case "mssql": return 1433;
            case "mongodb": return 27017;
            case "sqlite": return 0;
        }
        // satisfy TS: all paths return
        return 0;
    }

    parseReplicas(csv?: string): string[] {
        return (csv || "")
            .split(",")
            .map(s => s.trim())
            .filter(Boolean);
    }

    /**
     * Attempt real connection(s). Drivers are loaded dynamically, so you only
     * need to install the one(s) you actually use.
     */
    async testConnection(cfg: DatabaseConfigDto): Promise<TestResultDto> {
        const url = this.buildUrl(cfg);
        const replicas = this.parseReplicas(cfg.readReplicas);
        const result: TestResultDto = {
            ok: false,
            engine: cfg.engine,
            primary: { ok: false },
            replicas: replicas.length ? [] : undefined,
            note: "Drivers are loaded dynamically; install only what you use.",
        };

        // Primary
        result.primary = await this.tryConnect(cfg.engine, url, cfg);

        // Replicas
        for (const ru of replicas) {
            const r = await this.tryConnect(cfg.engine, ru, cfg);
            result.replicas!.push({ url: ru, ok: r.ok, message: r.message });
        }

        result.ok =
            result.primary.ok &&
            (result.replicas ? result.replicas.every(r => r.ok) : true);

        return result;
    }

    private async tryConnect(
        engine: DbEngine,
        url: string | null,
        cfg: DatabaseConfigDto
    ): Promise<{ ok: boolean; message?: string }> {
        try {
            switch (engine) {
                case "postgresql": {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    const { Client } = (await import("pg")) as any;
                    const client = new Client({ connectionString: url || undefined, ssl: cfg.ssl ? { rejectUnauthorized: false } : undefined });
                    await client.connect();
                    await client.query("SELECT 1");
                    await client.end();
                    return { ok: true };
                }
                case "mysql": {
                    const mysql = (await import("mysql2/promise")) as any;
                    const conn = await mysql.createConnection(url!);
                    await conn.query("SELECT 1");
                    await conn.end();
                    return { ok: true };
                }
                case "mssql": {
                    const mssql = (await import("mssql")) as any;
                    const pool = await mssql.connect(url!);
                    await pool.request().query("SELECT 1");
                    await pool.close();
                    return { ok: true };
                }
                case "sqlite": {
                    // Prefer better-sqlite3
                    try {
                        const bsql = (await import("better-sqlite3")) as any;
                        const db = new bsql.default((cfg.dbName || "remoteiq.sqlite"), { fileMustExist: false });
                        db.prepare("CREATE TABLE IF NOT EXISTS _ping (id INTEGER)").run();
                        db.prepare("SELECT 1").get();
                        db.close();
                        return { ok: true };
                    } catch {
                        // fallback to sqlite3/sqlite
                        try {
                            const sqlite3 = (await import("sqlite3")) as any;
                            const { open } = (await import("sqlite")) as any;
                            const db = await open({ filename: (cfg.dbName || "remoteiq.sqlite"), driver: sqlite3.Database });
                            await db.exec("CREATE TABLE IF NOT EXISTS _ping (id INTEGER)");
                            await db.close();
                            return { ok: true };
                        } catch (e2: any) {
                            return { ok: false, message: `Install 'better-sqlite3' OR 'sqlite3' + 'sqlite': ${e2?.message || e2}` };
                        }
                    }
                }
                case "mongodb": {
                    const { MongoClient } = (await import("mongodb")) as any;
                    const client = new MongoClient(url!, { serverSelectionTimeoutMS: 4000 });
                    await client.connect();
                    await client.db().command({ ping: 1 });
                    await client.close();
                    return { ok: true };
                }
                default:
                    return { ok: false, message: "Unsupported engine" };
            }
        } catch (e: any) {
            return { ok: false, message: e?.message || String(e) };
        }
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\admin\database.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\branding\branding.controller.ts
================================================================================
// backend/src/branding/branding.controller.ts
import {
    Controller,
    Get,
    Post,
    Body,
    UploadedFile,
    UseInterceptors,
    BadRequestException,
    Req,
} from '@nestjs/common';
import { ApiConsumes, ApiOkResponse, ApiTags } from '@nestjs/swagger';
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { existsSync, mkdirSync } from 'fs';
import { join, extname } from 'path';
import type { Request } from 'express';

import { BrandingService } from "./branding.service";
import { UpdateBrandingDto } from './dto/update-branding.dto';


@ApiTags('branding')
@Controller('api/branding')
export class BrandingController {
    constructor(private readonly service: BrandingService) { }

    /* ------------------------------------------------------------------ */
    /* Read / Write settings                                               */
    /* ------------------------------------------------------------------ */

    @Get()
    @ApiOkResponse({ description: 'Current branding settings' })
    getBranding() {
        return this.service.getBranding();
    }

    @Post()
    @ApiOkResponse({ description: 'Updated branding settings' })
    updateBranding(@Body() dto: UpdateBrandingDto) {
        return this.service.updateBranding(dto);
    }

    /* ------------------------------------------------------------------ */
    /* Uploads                                                             */
    /* - General images (logos, backgrounds) -> /api/branding/upload       */
    /* - Favicon (.ico only)             -> /api/branding/upload-favicon   */
    /* Files are written to ./public/uploads and served at /static/uploads */
    /* ------------------------------------------------------------------ */

    /** Upload general image (logos, login backgrounds). Field name: `file` */
    @Post('upload')
    @ApiConsumes('multipart/form-data')
    @UseInterceptors(
        FileInterceptor('file', {
            storage: diskStorage({
                destination: (_req, _file, cb) => {
                    const dest = join(process.cwd(), 'public', 'uploads');
                    if (!existsSync(dest)) mkdirSync(dest, { recursive: true });
                    cb(null, dest);
                },
                filename: (_req, file, cb) => {
                    const ts = Date.now();
                    const safe = file.originalname.replace(/[^a-zA-Z0-9._-]/g, '_');
                    cb(null, `${ts}_${safe}`);
                },
            }),
            fileFilter: (_req, file, cb) => {
                if (!/^image\//.test(file.mimetype)) {
                    return cb(new BadRequestException('Only image files are allowed'), false);
                }
                cb(null, true);
            },
            limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
        }),
    )
    uploadImage(@UploadedFile() file: Express.Multer.File, @Req() req: Request) {
        if (!file) throw new BadRequestException('No file uploaded');

        const base =
            process.env.PUBLIC_BASE_URL ||
            `${req.protocol}://${req.get('host')}`;

        // NOTE: main.ts must call app.useStaticAssets(..., { prefix: '/static/' })
        return { url: `${base}/static/uploads/${file.filename}` };
    }

    /** Upload favicon (.ico only). Field name: `file` */
    @Post('upload-favicon')
    @ApiConsumes('multipart/form-data')
    @UseInterceptors(
        FileInterceptor('file', {
            storage: diskStorage({
                destination: (_req, _file, cb) => {
                    const dest = join(process.cwd(), 'public', 'uploads');
                    if (!existsSync(dest)) mkdirSync(dest, { recursive: true });
                    cb(null, dest);
                },
                filename: (_req, file, cb) => {
                    const ts = Date.now();
                    const safe = file.originalname.replace(/[^a-zA-Z0-9._-]/g, '_');
                    cb(null, `${ts}_${safe}`);
                },
            }),
            fileFilter: (_req, file, cb) => {
                const isIco =
                    file.mimetype === 'image/x-icon' ||
                    file.mimetype === 'image/vnd.microsoft.icon' ||
                    extname(file.originalname).toLowerCase() === '.ico';
                if (!isIco) {
                    return cb(new BadRequestException('Only .ico files are allowed'), false);
                }
                cb(null, true);
            },
            limits: { fileSize: 512 * 1024 }, // 512KB
        }),
    )
    uploadFavicon(@UploadedFile() file: Express.Multer.File, @Req() req: Request) {
        if (!file) throw new BadRequestException('No file uploaded');

        const base =
            process.env.PUBLIC_BASE_URL ||
            `${req.protocol}://${req.get('host')}`;

        return { url: `${base}/static/uploads/${file.filename}` };
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\branding\branding.controller.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\branding\branding.module.ts
================================================================================
// backend/src/branding/branding.module.ts
import { Module } from '@nestjs/common';
import { BrandingController } from './branding.controller';
import { BrandingService } from './branding.service';
// If you switch BrandingService to use PgPoolService, also:
// import { StorageModule } from '../storage/storage.module';

@Module({
    // imports: [StorageModule], // <- only if BrandingService uses PgPoolService
    controllers: [BrandingController],
    providers: [BrandingService],
    exports: [BrandingService],
})
export class BrandingModule { }

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\branding\branding.module.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\branding\branding.service.ts
================================================================================
// backend/src/branding/branding.service.ts
import { Injectable, OnModuleDestroy, InternalServerErrorException } from '@nestjs/common';
import { UpdateBrandingDto } from './dto/update-branding.dto';

// eslint-disable-next-line @typescript-eslint/no-var-requires
const { Pool } = require('pg');

type BrandingRow = {
    primary_color: string | null;
    secondary_color: string | null;
    logo_light_url: string | null;
    logo_dark_url: string | null;
    login_background_url: string | null;
    favicon_url: string | null;
    email_header: string | null;
    email_footer: string | null;
    custom_css: string | null;
    allow_client_theme_toggle: boolean | null;
};

@Injectable()
export class BrandingService implements OnModuleDestroy {
    private pool: any;

    constructor() {
        const connectionString = process.env.DATABASE_URL;
        if (connectionString) {
            this.pool = new Pool({
                connectionString,
                ssl: process.env.PGSSL === 'true' ? { rejectUnauthorized: false } : undefined,
            });
        } else {
            this.pool = new Pool({
                host: process.env.PGHOST ?? 'localhost',
                port: Number(process.env.PGPORT ?? 5432),
                user: process.env.PGUSER ?? 'postgres',
                password: process.env.PGPASSWORD ?? undefined,
                database: process.env.PGDATABASE ?? 'remoteiq',
                ssl: process.env.PGSSL === 'true' ? { rejectUnauthorized: false } : undefined,
            });
        }
    }

    async onModuleDestroy() {
        try {
            await this.pool.end();
        } catch {
            /* no-op */
        }
    }

    private rowToApi(row: BrandingRow) {
        return {
            primaryColor: row?.primary_color ?? null,
            secondaryColor: row?.secondary_color ?? null,
            logoLightUrl: row?.logo_light_url ?? null,
            logoDarkUrl: row?.logo_dark_url ?? null,
            loginBackgroundUrl: row?.login_background_url ?? null,
            faviconUrl: row?.favicon_url ?? null,
            emailHeader: row?.email_header ?? null,
            emailFooter: row?.email_footer ?? null,
            customCss: row?.custom_css ?? null,
            allowClientThemeToggle: row?.allow_client_theme_toggle ?? null,
        };
    }

    async getBranding() {
        try {
            const sql = `
        SELECT primary_color, secondary_color,
               logo_light_url, logo_dark_url, login_background_url, favicon_url,
               email_header, email_footer, custom_css, allow_client_theme_toggle
        FROM branding_settings
        ORDER BY id DESC
        LIMIT 1
      `;
            const res = await this.pool.query(sql);
            const rows = (res?.rows ?? []) as BrandingRow[];
            const row = rows[0];
            if (!row) {
                return {
                    primaryColor: null,
                    secondaryColor: null,
                    logoLightUrl: null,
                    logoDarkUrl: null,
                    loginBackgroundUrl: null,
                    faviconUrl: null,
                    emailHeader: null,
                    emailFooter: null,
                    customCss: null,
                    allowClientThemeToggle: null,
                };
            }
            return this.rowToApi(row);
        } catch (err: any) {
            throw new InternalServerErrorException(`Failed to load branding: ${err?.message ?? err}`);
        }
    }

    async updateBranding(input: UpdateBrandingDto) {
        try {
            const sql = `
        INSERT INTO branding_settings
          (id, primary_color, secondary_color, logo_light_url, logo_dark_url, login_background_url, favicon_url,
           email_header, email_footer, custom_css, allow_client_theme_toggle)
        VALUES
          (1, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        ON CONFLICT (id) DO UPDATE SET
          primary_color = EXCLUDED.primary_color,
          secondary_color = EXCLUDED.secondary_color,
          logo_light_url = EXCLUDED.logo_light_url,
          logo_dark_url = EXCLUDED.logo_dark_url,
          login_background_url = EXCLUDED.login_background_url,
          favicon_url = EXCLUDED.favicon_url,
          email_header = EXCLUDED.email_header,
          email_footer = EXCLUDED.email_footer,
          custom_css = EXCLUDED.custom_css,
          allow_client_theme_toggle = EXCLUDED.allow_client_theme_toggle
      `;
            const values = [
                input.primaryColor ?? null,
                input.secondaryColor ?? null,
                input.logoLightUrl ?? null,
                input.logoDarkUrl ?? null,
                input.loginBackgroundUrl ?? null,
                input.faviconUrl ?? null,
                input.emailHeader ?? null,
                input.emailFooter ?? null,
                input.customCss ?? null,
                input.allowClientThemeToggle ?? null,
            ];

            await this.pool.query(sql, values);
            return this.getBranding();
        } catch (err: any) {
            throw new InternalServerErrorException(`Failed to update branding: ${err?.message ?? err}`);
        }
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\branding\branding.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\admin.guard.ts
================================================================================
import { CanActivate, ExecutionContext, Injectable, ForbiddenException } from "@nestjs/common";

/** Tight default: only allow authenticated admins.
 * Replace with your existing RBAC once wired.
 */
@Injectable()
export class AdminGuard implements CanActivate {
    canActivate(ctx: ExecutionContext): boolean {
        const req = ctx.switchToHttp().getRequest();
        // Example: if you have req.user / req.session
        const user = req.user || req.session?.user;
        if (!user) throw new ForbiddenException("Not authenticated");
        if (!user.roles || !Array.isArray(user.roles) || !user.roles.includes("admin")) {
            throw new ForbiddenException("Admin role required");
        }
        return true;
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\admin.guard.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\backups.controller.ts
================================================================================
import {
    Body,
    Controller,
    Get,
    Post,
    Put,
    Param,
    Query,
    Res,
    HttpException,
    HttpStatus,
    UseGuards,
} from "@nestjs/common";
import { Response } from "express";
import { BackupsService } from "./backups.service";
import { HistoryQueryDto, BackupConfigDto } from "./dto";
import { PermissionsGuard } from "../auth/permissions.guard";
import { RequirePerm } from "../auth/require-perm.decorator";
import { WorkerService } from "./worker.service";

@Controller("/api/admin/backups")
@UseGuards(PermissionsGuard)
export class BackupsController {
    constructor(
        private readonly svc: BackupsService,
        private readonly worker: WorkerService
    ) { }

    /* ---------------- Config / Permissions ---------------- */

    @Get("config")
    @RequirePerm("backups.read")
    async getConfig() {
        return this.svc.getConfig();
    }

    @Put("config")
    @RequirePerm("backups.manage")
    async putConfig(@Body() body: BackupConfigDto) {
        this.svc.validateDestination((body as any).destination);
        return this.svc.saveConfig(body);
    }

    // Capability booleans for UI
    @Get("permissions")
    @RequirePerm("backups.read")
    async getPerms() {
        return this.svc.getPermissions();
    }

    /* ---------------- History ---------------- */

    @Get("history")
    @RequirePerm("backups.read")
    async history(@Query() q: HistoryQueryDto) {
        return this.svc.listHistory(q);
    }

    /* ---------------- Actions ---------------- */

    @Post("run")
    @RequirePerm("backups.run")
    async runNow() {
        const res = await this.svc.startBackupNow();
        // kick the worker (fire-and-forget)
        this.worker.runOneIfAny().catch(() => { });
        return res;
    }

    @Post("prune")
    @RequirePerm("backups.prune")
    async prune() {
        return this.svc.pruneOld();
    }

    @Post("test-destination")
    @RequirePerm("backups.manage")
    async testDest(@Body() body: any) {
        return this.svc.testDestination((body ?? {}).destination);
    }

    @Post(":id/retry")
    @RequirePerm("backups.run")
    async retry(@Param("id") id: string) {
        return this.svc.retryJob(id);
    }

    @Post(":id/cancel")
    @RequirePerm("backups.run")
    async cancel(@Param("id") id: string) {
        return this.svc.cancelJob(id);
    }

    @Post(":id/restore")
    @RequirePerm("backups.restore")
    async restore(@Param("id") id: string) {
        return this.svc.startRestore(id);
    }

    /* ---------------- Artifacts ---------------- */

    @Get(":id/log")
    @RequirePerm("backups.read")
    async log(@Param("id") id: string, @Res() res: Response) {
        const stream = await this.svc.openLogStream(id);
        if (!stream) throw new HttpException("Not found", HttpStatus.NOT_FOUND);
        res.setHeader("Content-Type", "text/plain; charset=utf-8");
        stream.pipe(res);
    }

    @Get(":id/manifest")
    @RequirePerm("backups.read")
    async manifest(@Param("id") id: string) {
        const m = await this.svc.getManifest(id);
        if (!m) throw new HttpException("Not found", HttpStatus.NOT_FOUND);
        return m;
    }

    @Get(":id/download")
    @RequirePerm("backups.download")
    async download(@Param("id") id: string, @Res() res: Response) {
        const out = await this.svc.getDownload(id);
        if (!out) throw new HttpException("Not found", HttpStatus.NOT_FOUND);

        if (out.stream) {
            res.setHeader(
                "Content-Disposition",
                `attachment; filename="${out.filename.replace(/"/g, "")}"`
            );
            res.setHeader("Content-Type", "application/octet-stream");
            out.stream.pipe(res);
            return;
        }
        if (out.presignedUrl) {
            res.redirect(out.presignedUrl);
            return;
        }
        throw new HttpException("Not found", HttpStatus.NOT_FOUND);
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\backups.controller.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\backups.module.ts
================================================================================
import { Module } from "@nestjs/common";
import { BackupsController } from "./backups.controller";
import { BackupsService } from "./backups.service";
import { CronPreviewService } from "./cron-preview.service";
import { PgPoolService } from "../storage/pg-pool.service";
import { OrganizationContextService } from "../storage/organization-context.service";
import { PermissionsGuard } from "../auth/permissions.guard";
import { Reflector } from "@nestjs/core";
import { SchedulerService } from "./scheduler.service";
import { WorkerService } from "./worker.service";
import { NotifierService } from "./notifier.service";

@Module({
    controllers: [BackupsController],
    providers: [
        BackupsService,
        CronPreviewService,
        PgPoolService,
        OrganizationContextService,
        PermissionsGuard,
        Reflector,
        SchedulerService,
        WorkerService,
        NotifierService,
    ],
    exports: [BackupsService],
})
export class BackupsModule { }

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\backups.module.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\backups.service.ts
================================================================================
import {
    BadRequestException,
    Injectable,
    NotFoundException,
} from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";
import { OrganizationContextService } from "../storage/organization-context.service";
import { BackupConfigDto, HistoryQueryDto } from "./dto";
import { Readable } from "stream";
import * as crypto from "crypto";
import { WorkerService } from "./worker.service";
import { NotifierService } from "./notifier.service";
import { s3PresignGet } from "./storage-clients";

type JobRow = {
    id: string;
    started_at: Date;
    finished_at: Date | null;
    status: "running" | "completed" | "failed" | "cancelled";
    note: string | null;
    size_bytes: number | null;
    duration_sec: number | null;
    verified: boolean | null;
};

type HistoryStatus = "success" | "failed" | "running";

function mapFilterStatus(status: HistoryStatus | undefined): string | undefined {
    if (!status) return undefined;
    if (status === "success") return "completed";
    return status;
}

function projectStatus(status: string): HistoryStatus {
    switch (status) {
        case "completed":
            return "success";
        case "failed":
        case "cancelled":
            return "failed";
        default:
            return "running";
    }
}

function isAbsolutePath(p: string) {
    return p.startsWith("/") || /^[A-Za-z]:\\/.test(p);
}
function sanitizeLocalPath(p: string) {
    if (!isAbsolutePath(p)) throw new BadRequestException("Path must be absolute");
    if (p.includes("..") || p.includes("\0")) throw new BadRequestException("Invalid path");
    return p;
}
function parseCursor(cur?: string | null): number {
    if (!cur) return 0;
    try {
        const { page } = JSON.parse(Buffer.from(cur, "base64").toString("utf8"));
        return Number(page) || 0;
    } catch {
        return 0;
    }
}
function makeCursor(page: number) {
    return Buffer.from(JSON.stringify({ page }), "utf8").toString("base64");
}

type PolicyRow = {
    id: string;
    schedule: string;
    retention: any;
    options: any;
    destination_id: string | null;
    destination_provider: string | null;
    destination_configuration: any | null;
};

type PolicyConfig = {
    policyId: string;
    enabled: boolean;
    targets: string[];
    schedule: string;
    cronExpr?: string;
    retentionDays: number;
    encrypt: boolean;
    destination: any | null;
    notifications: Record<string, any>;
    lastScheduledAt?: string | null;
};

@Injectable()
export class BackupsService {
    constructor(
        private readonly db: PgPoolService,
        private readonly notifier: NotifierService,
        private readonly worker: WorkerService,
        private readonly orgContext: OrganizationContextService,
    ) { }

    private async orgId(): Promise<string> {
        return this.orgContext.getDefaultOrganizationId();
    }

    private retentionDays(retention: any): number {
        if (!retention) return 30;
        if (typeof retention.days === "number") return retention.days;
        if (typeof retention.value === "number" && retention.unit === "days") {
            return retention.value;
        }
        return 30;
    }

    private parsePolicy(row: PolicyRow | null): PolicyConfig | null {
        if (!row) return null;
        const options = row.options && typeof row.options === "object" ? row.options : {};
        const destination =
            row.destination_configuration && typeof row.destination_configuration === "object"
                ? row.destination_configuration
                : null;

        const cronExpr = options.cronExpr ?? options.cron_expr ?? undefined;
        const notifications =
            options.notifications && typeof options.notifications === "object"
                ? options.notifications
                : {};

        const enabled = options.enabled ?? false;
        const rawTargets = Array.isArray(options.targets)
            ? options.targets.filter((t: any) => typeof t === "string" && t.trim().length)
            : [];
        const targets = rawTargets.length ? rawTargets : ["users", "roles", "devices", "settings"];
        const encrypt = options.encrypt ?? true;
        const lastScheduledAt = options.lastScheduledAt ?? options.last_scheduled_at ?? null;

        return {
            policyId: row.id,
            enabled,
            targets,
            schedule: row.schedule,
            cronExpr: cronExpr ?? undefined,
            retentionDays: this.retentionDays(row.retention),
            encrypt,
            destination,
            notifications,
            lastScheduledAt,
        };
    }

    private normalizeDestinationInput(dest: any): { provider: string; configuration: any } {
        if (!dest || typeof dest !== "object") {
            throw new BadRequestException("Destination required");
        }
        const provider = dest.kind === "remote" ? "sftp" : dest.kind;
        return {
            provider,
            configuration: { ...dest },
        };
    }

    private async fetchDefaultPolicyRow(): Promise<PolicyRow | null> {
        const orgId = await this.orgId();
        const { rows } = await this.db.query<PolicyRow>(
            `SELECT p.id,
                    p.schedule,
                    p.retention,
                    p.options,
                    p.destination_id,
                    d.provider AS destination_provider,
                    d.configuration AS destination_configuration
               FROM backup_policies p
          LEFT JOIN backup_destinations d ON d.id = p.destination_id
              WHERE p.organization_id = $1
           ORDER BY p.is_default DESC, p.created_at ASC
              LIMIT 1`,
            [orgId]
        );
        return rows[0] ?? null;
    }

    private async fetchDefaultPolicy(): Promise<PolicyConfig | null> {
        const row = await this.fetchDefaultPolicyRow();
        return this.parsePolicy(row);
    }

    private async upsertDestination(
        orgId: string,
        dest: any,
    ): Promise<{ id: string; provider: string; configuration: any }> {
        const { provider, configuration } = this.normalizeDestinationInput(dest);
        const { rows } = await this.db.query<{ id: string; provider: string; configuration: any }>(
            `INSERT INTO backup_destinations (organization_id, name, provider, configuration)
             VALUES ($1, $2, $3, $4::jsonb)
             ON CONFLICT (organization_id, name)
             DO UPDATE SET provider = EXCLUDED.provider,
                           configuration = EXCLUDED.configuration,
                           updated_at = NOW()
             RETURNING id, provider, configuration`,
            [orgId, "Default Backup Destination", provider, JSON.stringify(configuration)]
        );
        return rows[0];
    }

    private async upsertPolicy(
        orgId: string,
        destinationId: string,
        cfg: BackupConfigDto,
        existingOptions: Record<string, any>,
    ): Promise<PolicyConfig | null> {
        const mergedOptions = {
            ...existingOptions,
            enabled: !!cfg.enabled,
            targets: cfg.targets,
            cronExpr: cfg.schedule === "cron" ? cfg.cronExpr ?? null : null,
            cron_expr: cfg.schedule === "cron" ? cfg.cronExpr ?? null : null,
            encrypt: !!cfg.encrypt,
            notifications: cfg.notifications ?? {},
        };
        if (mergedOptions.cronExpr == null) delete (mergedOptions as any).cronExpr;
        if (mergedOptions.cron_expr == null) delete (mergedOptions as any).cron_expr;
        const inserted = await this.db.query<{ id: string }>(
            `INSERT INTO backup_policies (
                 organization_id,
                 name,
                 description,
                 schedule,
                 retention,
                 destination_id,
                 target_type,
                 target_id,
                 options,
                 is_default)
             VALUES (
                 $1,
                 $2,
                 $3,
                 $4,
                 $5::jsonb,
                 $6,
                 'organization',
                 NULL,
                 $7::jsonb,
                 TRUE)
             ON CONFLICT (organization_id, name)
             DO UPDATE SET
                 description = EXCLUDED.description,
                 schedule = EXCLUDED.schedule,
                 retention = EXCLUDED.retention,
                 destination_id = EXCLUDED.destination_id,
                 target_type = EXCLUDED.target_type,
                 target_id = EXCLUDED.target_id,
                 options = EXCLUDED.options,
                 is_default = TRUE,
                 updated_at = NOW()
             RETURNING id`,
            [
                orgId,
                "Default Backup Policy",
                "Normalized default backups policy",
                cfg.schedule,
                JSON.stringify({ days: cfg.retentionDays }),
                destinationId,
                JSON.stringify(mergedOptions),
            ]
        );
        const policyId = inserted.rows[0]?.id;
        if (!policyId) {
            return null;
        }

        const detail = await this.db.query<PolicyRow>(
            `SELECT p.id,
                    p.schedule,
                    p.retention,
                    p.options,
                    p.destination_id,
                    d.provider AS destination_provider,
                    d.configuration AS destination_configuration
               FROM backup_policies p
          LEFT JOIN backup_destinations d ON d.id = p.destination_id
              WHERE p.id = $1`,
            [policyId]
        );
        return this.parsePolicy(detail.rows[0] ?? null);
    }

    private async ensurePolicyAndDestination(cfg?: BackupConfigDto): Promise<PolicyConfig | null> {
        if (!cfg) {
            return this.fetchDefaultPolicy();
        }
        const orgId = await this.orgId();
        const currentRow = await this.fetchDefaultPolicyRow();
        const existingOptions =
            currentRow && currentRow.options && typeof currentRow.options === "object"
                ? currentRow.options
                : {};

        const destination = await this.upsertDestination(orgId, cfg.destination);
        return this.upsertPolicy(orgId, destination.id, cfg, existingOptions);
    }

    /* ---------------- Permissions (UI helper) --------------- */
    async getPermissions() {
        // Controller derives real booleans via RBAC; keep this as a safe default fallback.
        return { restore: true, download: true };
    }

    /* ---------------- Config --------------------- */
    async getConfig() {
        const policy = await this.fetchDefaultPolicy();
        if (!policy) {
            return {
                enabled: false,
                targets: ["users", "roles", "devices", "settings"],
                schedule: "daily",
                cronExpr: "0 3 * * *",
                retentionDays: 30,
                encrypt: true,
                destination: { kind: "local", path: "/var/remoteiq/backups" },
                notifications: { email: false, webhook: false, slack: false },
            };
        }

        return {
            enabled: policy.enabled,
            targets: policy.targets,
            schedule: policy.schedule as any,
            cronExpr: policy.cronExpr,
            retentionDays: policy.retentionDays,
            encrypt: policy.encrypt,
            destination: policy.destination ?? { kind: "local", path: "/var/remoteiq/backups" },
            notifications: policy.notifications,
        };
    }

    validateDestination(dest: any) {
        if (!dest || typeof dest !== "object" || !dest.kind) {
            throw new BadRequestException("Destination required");
        }
        switch (dest.kind) {
            case "local":
                sanitizeLocalPath(String(dest.path || ""));
                break;
            case "s3":
            case "nextcloud":
            case "gdrive":
            case "remote":
                if (!dest.connectionId || !/^[0-9a-f-]{36}$/i.test(dest.connectionId)) {
                    throw new BadRequestException("Valid connectionId required");
                }
                if (dest.kind === "nextcloud") {
                    const p = String(dest.path || "");
                    if (!p.startsWith("/"))
                        throw new BadRequestException("Nextcloud path must start with '/'");
                }
                if (dest.kind === "remote") {
                    const p = String(dest.path || "");
                    if (!isAbsolutePath(p))
                        throw new BadRequestException("Remote path must be absolute");
                }
                break;
            default:
                throw new BadRequestException("Unsupported destination");
        }
    }

    async saveConfig(cfg: BackupConfigDto) {
        if (cfg.schedule === "cron" && !cfg.cronExpr) {
            throw new BadRequestException("cronExpr required for schedule=cron");
        }
        const policy = await this.ensurePolicyAndDestination(cfg);
        return {
            ok: true,
            policyId: policy?.policyId,
        };
    }

    /* ---------------- History -------------------- */
    async listHistory(q: HistoryQueryDto) {
        const pageSize = 50;
        const page = parseCursor(q.cursor);
        const offset = page * pageSize;

        const params: any[] = [];
        const where: string[] = [];

        const policy = await this.fetchDefaultPolicy();
        if (policy?.policyId) {
            params.push(policy.policyId);
            where.push(`(policy_id = $${params.length} OR policy_id IS NULL)`);
        }
        const statusFilter = mapFilterStatus(q.status as HistoryStatus | undefined);
        if (statusFilter) {
            params.push(statusFilter);
            where.push(`status = $${params.length}`);
        }
        if (q.q?.trim()) {
            params.push(`%${q.q.trim()}%`);
            where.push(`(id::text ILIKE $${params.length} OR note ILIKE $${params.length})`);
        }
        if (q.from) {
            params.push(q.from);
            where.push(`started_at >= $${params.length}::date`);
        }
        if (q.to) {
            params.push(q.to);
            where.push(`started_at < ($${params.length}::date + INTERVAL '1 day')`);
        }
        const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";

        const sql = `
      SELECT id, started_at, status, note, size_bytes, duration_sec, verified
      FROM backup_jobs
      ${whereSql}
      ORDER BY started_at DESC
      LIMIT ${pageSize + 1}
      OFFSET ${offset}
    `;

        const { rows } = await this.db.query<JobRow>(sql, params);
        const items = rows.slice(0, pageSize).map((r) => ({
            id: r.id,
            at: r.started_at.toISOString().slice(0, 16).replace("T", " "),
            status: projectStatus(r.status),
            note: r.note ?? undefined,
            sizeBytes: r.size_bytes ?? undefined,
            durationSec: r.duration_sec ?? undefined,
            verified: r.verified ?? undefined,
        }));

        const hasMore = rows.length > pageSize;
        return { items, nextCursor: hasMore ? makeCursor(page + 1) : undefined };
    }

    /* ---------------- Scheduler hooks ------------- */
    async markScheduledOnce(now: Date) {
        const policy = await this.fetchDefaultPolicyRow();
        if (!policy) return { updated: false };

        const { rows } = await this.db.query(
            `UPDATE backup_policies
                SET options = jsonb_set(
                    COALESCE(options, '{}'::jsonb),
                    '{lastScheduledAt}',
                    to_jsonb(($2)::timestamptz),
                    true
                )
             WHERE id = $1
               AND (
                    options->>'lastScheduledAt' IS NULL
                 OR (options->>'lastScheduledAt')::timestamptz < ($2)::timestamptz - interval '30 seconds'
               )
             RETURNING 1`,
            [policy.id, now.toISOString()]
        );
        return { updated: rows.length > 0 };
    }

    async kickWorker() {
        await this.worker.runOneIfAny();
    }

    /* ---------------- Actions -------------------- */
    async startBackupNow() {
        const policy = await this.ensurePolicyAndDestination();
        if (!policy) {
            throw new BadRequestException("Backups not configured");
        }
        if (!policy.enabled) {
            throw new BadRequestException("Backups disabled");
        }

        const id = crypto.randomUUID();
        await this.db.query(
            `INSERT INTO backup_jobs (id, policy_id, started_at, status, note)
             VALUES ($1, $2, NOW(), 'running', 'Manual run')`,
            [id, policy.policyId]
        );
        // Start immediately
        await this.worker.runOneIfAny();
        return { id, startedAt: new Date().toISOString() };
    }

    async pruneOld() {
        const policy = await this.fetchDefaultPolicy();
        if (!policy) {
            return { removed: 0 };
        }

        const params: any[] = [String(policy.retentionDays)];
        let sql = `DELETE FROM backup_jobs
             WHERE COALESCE(finished_at, started_at) < (NOW() - ($1 || ' days')::interval)
               AND status IN ('completed','failed','cancelled')`;

        if (policy.policyId) {
            params.push(policy.policyId);
            sql += ` AND (policy_id = $2 OR policy_id IS NULL)`;
        }

        const { rows } = await this.db.query(sql + ` RETURNING 1`, params);
        return { removed: rows.length };
    }

    // Real destination testing (local & S3), probes for others via helper module.
    async testDestination(dest: any) {
        if (dest.kind === "local") {
            sanitizeLocalPath(dest.path);
            const { ensureDir } = await import("./storage-clients");
            const fs = await import("fs/promises");
            const p = require("path").join(dest.path, ".remoteiq_probe.txt");
            await ensureDir(dest.path);
            await fs.writeFile(p, "probe");
            const r = await fs.readFile(p, "utf8");
            await fs.unlink(p);
            return { ok: r === "probe", phases: { write: true, read: r === "probe", delete: true } };
        }

        if (dest.kind === "s3") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='s3'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("S3 connection not found");
            const cfgS3 = { ...(row.config || {}), ...(row.secrets || {}) };
            const bucket = dest.bucket || cfgS3.bucket;
            const prefix = (dest.prefix || cfgS3.prefix || "").replace(/^\/+|\/+$/g, "");
            const key = (prefix ? `${prefix}/` : "") + ".remoteiq_probe.txt";
            const { s3PutObject, s3Head, s3Delete } = await import("./storage-clients");
            await s3PutObject(cfgS3, bucket, key, Buffer.from("probe"));
            const head = await s3Head(cfgS3, bucket, key);
            const ok = !!head;
            await s3Delete(cfgS3, bucket, key);
            return { ok, phases: { write: true, read: ok, delete: true } };
        }

        if (dest.kind === "nextcloud") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='nextcloud'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("Nextcloud connection not found");
            const { webdavProbe } = await import("./storage-clients");
            const url = row.config?.url;
            const username = row.secrets?.username;
            const password = row.secrets?.password;
            const path = dest.path;
            const phases = await webdavProbe({ url, username, password, path });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        if (dest.kind === "remote") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='sftp'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("SFTP connection not found");
            const { sftpProbe } = await import("./storage-clients");
            const host = row.config?.host;
            const port = row.config?.port;
            const username = row.secrets?.username;
            const password = row.secrets?.password;
            const privateKey = row.secrets?.privateKey;
            const passphrase = row.secrets?.passphrase;
            const phases = await sftpProbe({
                host,
                port,
                username,
                password,
                privateKey,
                passphrase,
                testPath: dest.path,
            });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        if (dest.kind === "gdrive") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='gdrive'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("GDrive connection not found");
            const { gdriveProbe } = await import("./storage-clients");
            const credentialsJson = row.secrets?.serviceAccountJson;
            const folderId = row.config?.folderId || undefined;
            const phases = await gdriveProbe({ credentialsJson, folderId });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        throw new BadRequestException("Unsupported destination");
    }

    async testNotification() {
        await this.notifier.send(
            { email: true, slack: true, webhook: true },
            "RemoteIQ Backups: Test",
            "This is a test notification."
        );
        return { sent: true };
    }

    async retryJob(id: string) {
        const { rows } = await this.db.query(
            `UPDATE backup_jobs
         SET status='running', note='Retry queued', finished_at=NULL, cancelled=false
       WHERE id=$1 AND status='failed'
       RETURNING 1`,
            [id]
        );
        if (!rows.length) throw new BadRequestException("Job not in failed state");
        await this.worker.runOneIfAny();
        return { queued: true };
    }

    async cancelJob(id: string) {
        const { rows } = await this.db.query(
            `UPDATE backup_jobs
         SET cancelled=true, status='cancelled', finished_at=NOW(), note='Cancelled by user'
       WHERE id=$1 AND status='running'
       RETURNING 1`,
            [id]
        );
        if (!rows.length) throw new BadRequestException("Job not running");
        return { sent: true };
    }

    async startRestore(id: string) {
        const { rows } = await this.db.query(
            `SELECT id, status FROM backup_jobs WHERE id=$1 LIMIT 1`,
            [id]
        );
        if (!rows.length) throw new NotFoundException("Backup not found");
        if (rows[0].status !== "completed")
            throw new BadRequestException("Backup not successful");

        await this.db.query(
            `INSERT INTO backup_restores (id, backup_job_id, status)
       VALUES ($1, $2, 'running')`,
            [crypto.randomUUID(), id]
        );
        return { started: true };
    }

    /* ---------------- Artifacts ------------------- */
    async openLogStream(id: string): Promise<Readable | null> {
        const { rows } = await this.db.query(
            `SELECT log_text FROM backup_job_logs WHERE job_id=$1`,
            [id]
        );
        if (!rows.length) return null;
        const text: string = rows[0].log_text ?? "";
        return Readable.from(text);
    }

    async getManifest(id: string): Promise<any | null> {
        const { rows } = await this.db.query(
            `SELECT manifest FROM backup_job_manifests WHERE job_id=$1`,
            [id]
        );
        if (!rows.length) return null;
        return rows[0].manifest;
    }

    async getDownload(id: string): Promise<{ presignedUrl?: string; stream?: Readable; filename: string } | null> {
        const { rows } = await this.db.query(
            `SELECT j.status,
                    j.artifact_location,
                    d.configuration AS destination_configuration
               FROM backup_jobs j
          LEFT JOIN backup_policies p ON j.policy_id = p.id
          LEFT JOIN backup_destinations d ON d.id = p.destination_id
              WHERE j.id=$1`,
            [id]
        );
        if (!rows.length) return null;
        if (rows[0].status !== "completed")
            throw new BadRequestException("Backup not successful");

        const loc = rows[0].artifact_location || {};
        if (loc.kind === "local") {
            const fs = await import("fs");
            if (!fs.existsSync(loc.path)) return null;
            const filename = String(loc.path).split(/[\\/]/).pop() || "backup.tar.gz";
            return { filename, stream: fs.createReadStream(loc.path) };
        }
        if (loc.kind === "s3") {
            const destConfig = rows[0].destination_configuration || {};
            const connectionId = loc.connectionId || destConfig.connectionId;
            if (!connectionId) throw new BadRequestException("S3 connection missing");
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='s3'`,
                [connectionId]
            )).rows[0];
            if (!row) throw new BadRequestException("S3 connection missing");
            const s3Cfg = { ...(row.config || {}), ...(row.secrets || {}) };
            const bucket = loc.bucket || destConfig.bucket || s3Cfg.bucket;
            const key = loc.key || destConfig.key;
            if (!bucket || !key) throw new BadRequestException("S3 location incomplete");
            const url = await s3PresignGet(s3Cfg, bucket, key, 60 * 10);
            const filename = String(key || "").split("/").pop() || "backup.tar.gz";
            return { presignedUrl: url, filename };
        }
        return null;
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\backups.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\cron-preview.service.ts
================================================================================
import { Injectable, BadRequestException } from "@nestjs/common";
import * as cronParser from "cron-parser"; // namespace import works across CJS/ESM builds

@Injectable()
export class CronPreviewService {
    nextRuns(expr: string, tz: string, count = 5): string[] {
        try {
            const parse = (cronParser as any).parseExpression as
                | ((e: string, o?: any) => any)
                | undefined;

            if (typeof parse !== "function") {
                throw new Error("cron-parser: parseExpression is not available");
            }

            const interval = parse(expr, { tz });
            const out: string[] = [];
            for (let i = 0; i < count; i++) {
                const d = interval.next().toDate();
                out.push(
                    d.toLocaleString("en-US", {
                        timeZone: tz,
                        weekday: "short",
                        hour: "2-digit",
                        minute: "2-digit",
                    })
                );
            }
            return out;
        } catch (e: any) {
            throw new BadRequestException(e?.message ?? "Invalid cron");
        }
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\cron-preview.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\dto.ts
================================================================================
import {
    IsArray, IsBoolean, IsIn, IsInt, IsNumber, IsOptional, IsString,
    IsUUID, Min, Max, ValidateNested, IsObject, Matches
} from "class-validator";
import { Type } from "class-transformer";

export const SCHEDULES = ["hourly", "daily", "weekly", "cron"] as const;
export type ScheduleKind = typeof SCHEDULES[number];

export type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";
export type Destination =
    | { kind: "local"; path: string }
    | { kind: "s3"; connectionId: string; bucket?: string; prefix?: string }
    | { kind: "nextcloud"; connectionId: string; path: string }
    | { kind: "gdrive"; connectionId: string; subfolder?: string }
    | { kind: "remote"; connectionId: string; path: string };

export class NotificationsDto {
    @IsOptional() @IsBoolean() email?: boolean;
    @IsOptional() @IsBoolean() webhook?: boolean;
    @IsOptional() @IsBoolean() slack?: boolean;
}

export class LocalDestDto {
    @IsIn(["local"]) kind!: "local";
    @IsString() path!: string;
}

export class S3DestDto {
    @IsIn(["s3"]) kind!: "s3";
    @IsUUID() connectionId!: string;
    @IsOptional() @IsString() bucket?: string;
    @IsOptional() @IsString() prefix?: string;
}

export class NextcloudDestDto {
    @IsIn(["nextcloud"]) kind!: "nextcloud";
    @IsUUID() connectionId!: string;
    @IsString() path!: string;
}

export class GDriveDestDto {
    @IsIn(["gdrive"]) kind!: "gdrive";
    @IsUUID() connectionId!: string;
    @IsOptional() @IsString() subfolder?: string;
}

export class RemoteDestDto {
    @IsIn(["remote"]) kind!: "remote";
    @IsUUID() connectionId!: string;
    @IsString() path!: string;
}

export class DestinationDto {
    @IsIn(["local", "s3", "nextcloud", "gdrive", "remote"])
    kind!: Destination["kind"];
}

export class BackupConfigDto {
    @IsBoolean() enabled!: boolean;

    @IsArray() @IsString({ each: true })
    targets!: string[]; // UI-enforced values

    @IsIn(SCHEDULES as unknown as string[]) schedule!: ScheduleKind;

    @IsOptional()
    @Matches(/^(\S+\s+){4}\S+$/)
    cronExpr?: string;

    @IsInt() @Min(1) @Max(3650)
    retentionDays!: number;

    @IsBoolean() encrypt!: boolean;

    @IsObject()
    destination!: Destination;

    @IsOptional() @ValidateNested()
    @Type(() => NotificationsDto)
    notifications?: NotificationsDto;
}

export class HistoryQueryDto {
    @IsOptional() @IsString() cursor?: string;
    @IsOptional() @IsIn(["success", "failed", "running"]) status?: "success" | "failed" | "running";
    @IsOptional() @IsString() q?: string;
    @IsOptional() @Matches(/^\d{4}-\d{2}-\d{2}$/) from?: string;
    @IsOptional() @Matches(/^\d{4}-\d{2}-\d{2}$/) to?: string;
}

export class TestDestinationDto {
    @ValidateNested() @Type(() =>
        Object
    ) destination!: Destination;
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\dto.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\notifier.service.ts
================================================================================
import { Injectable, Logger } from "@nestjs/common";
import nodemailer from "nodemailer";
import axios from "axios";

type Channels = { email?: boolean; slack?: boolean; webhook?: boolean };

@Injectable()
export class NotifierService {
    private log = new Logger("BackupsNotifier");

    async send(channels: Channels, subject: string, body: string) {
        const promises: Promise<any>[] = [];
        if (channels.email) promises.push(this.sendEmail(subject, body));
        if (channels.slack) promises.push(this.sendSlack(body));
        if (channels.webhook) promises.push(this.sendWebhook({ subject, body }));
        await Promise.allSettled(promises);
    }

    private async sendEmail(subject: string, body: string) {
        const { SMTP_HOST, SMTP_PORT, SMTP_SECURE, SMTP_USER, SMTP_PASS, SMTP_FROM, SMTP_TO } = process.env as any;
        if (!SMTP_HOST || !SMTP_FROM || !SMTP_TO) return;
        const transporter = nodemailer.createTransport({
            host: SMTP_HOST,
            port: Number(SMTP_PORT ?? 587),
            secure: String(SMTP_SECURE ?? "false") === "true",
            auth: SMTP_USER && SMTP_PASS ? { user: SMTP_USER, pass: SMTP_PASS } : undefined,
        });
        await transporter.sendMail({
            from: SMTP_FROM,
            to: SMTP_TO,
            subject,
            text: body,
        });
    }

    private async sendSlack(text: string) {
        const url = process.env.SLACK_WEBHOOK_URL;
        if (!url) return;
        await axios.post(url, { text });
    }

    private async sendWebhook(payload: any) {
        const url = process.env.BACKUPS_WEBHOOK_URL;
        if (!url) return;
        await axios.post(url, payload, { timeout: 5000 });
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\notifier.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\scheduler.service.ts
================================================================================
import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from "@nestjs/common";
import * as cronParser from "cron-parser";
import { BackupsService } from "./backups.service";
import { WorkerService } from "./worker.service";

@Injectable()
export class SchedulerService implements OnModuleInit, OnModuleDestroy {
    private cronTimer?: NodeJS.Timeout;
    private workerTimer?: NodeJS.Timeout;
    private log = new Logger("BackupsScheduler");

    constructor(
        private readonly svc: BackupsService,
        private readonly worker: WorkerService
    ) { }

    onModuleInit() {
        // Check cron schedule every 30s
        this.cronTimer = setInterval(
            () => this.tickCron().catch((e) => this.log.error(e?.message || e)),
            30_000
        );
        // Worker pump every 5s to process any running jobs
        this.workerTimer = setInterval(
            () => this.worker.runOneIfAny().catch(() => { }),
            5_000
        );
    }

    onModuleDestroy() {
        if (this.cronTimer) clearInterval(this.cronTimer);
        if (this.workerTimer) clearInterval(this.workerTimer);
    }

    private async tickCron() {
        const cfg = await this.svc.getConfig();
        if (!cfg.enabled) return;

        const now = new Date();
        let due = false;

        if (cfg.schedule === "hourly") {
            due = now.getMinutes() === 0;
        } else if (cfg.schedule === "daily") {
            due = now.getHours() === 3 && now.getMinutes() === 0;
        } else if (cfg.schedule === "weekly") {
            due = now.getDay() === 0 && now.getHours() === 3 && now.getMinutes() === 0;
        } else if (cfg.schedule === "cron" && cfg.cronExpr) {
            const parse = (cronParser as any).parseExpression as
                | ((expr: string, opts?: any) => { prev(): { toDate(): Date } })
                | undefined;
            if (typeof parse !== "function") {
                this.log.warn("cron-parser parseExpression not available");
            } else {
                const it = parse(cfg.cronExpr, {
                    tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
                });
                const prev = it.prev().toDate();
                // fire if previous occurrence is within last minute
                due = +now - +prev < 60_000;
            }
        }

        if (!due) return;

        this.log.log("Cron window due → starting backup job");
        await this.svc.startBackupNow();
        // Immediately try to process it
        this.worker.runOneIfAny().catch(() => { });
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\scheduler.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\storage-clients.ts
================================================================================
import {
    S3Client,
    PutObjectCommand,
    HeadObjectCommand,
    DeleteObjectCommand,
    GetObjectCommand,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import SftpClient from "ssh2-sftp-client";
import { createClient as createWebdavClient } from "webdav";
import { google } from "googleapis";
import * as fs from "fs";
import * as fsp from "fs/promises";
import * as path from "path";
import * as crypto from "crypto";
import type { Readable as NodeReadable } from "stream";

export type LocalLoc = { kind: "local"; path: string };
export type S3Loc = { kind: "s3"; bucket: string; key: string; region?: string; endpoint?: string };
export type ArtifactLoc = LocalLoc | S3Loc;

export type S3Secret = {
    region?: string;
    bucket?: string;
    endpoint?: string; // optional for compatible S3 (e.g., MinIO, Wasabi)
    accessKeyId?: string;
    secretAccessKey?: string;
    sessionToken?: string;
    forcePathStyle?: boolean;
    kmsKeyId?: string; // (not used here, but reserved)
};

export async function ensureDir(p: string) {
    await fsp.mkdir(p, { recursive: true });
}

/* ---------------- Local ---------------- */
export async function localWriteStream(absDir: string, filename: string) {
    await ensureDir(absDir);
    const full = path.join(absDir, filename);
    return { stream: fs.createWriteStream(full), fullPath: full };
}

export function localArtifactLoc(fullPath: string): LocalLoc {
    return { kind: "local", path: fullPath };
}

/* ---------------- S3 ---------------- */
function makeS3Client(secret: S3Secret) {
    const cfg: any = { region: secret.region ?? "us-east-1" };
    if (secret.endpoint) cfg.endpoint = secret.endpoint;
    if (secret.accessKeyId && secret.secretAccessKey) {
        cfg.credentials = {
            accessKeyId: secret.accessKeyId,
            secretAccessKey: secret.secretAccessKey,
            sessionToken: secret.sessionToken,
        };
    }
    if (secret.forcePathStyle != null) cfg.forcePathStyle = secret.forcePathStyle;
    return new S3Client(cfg);
}

// ✅ Body type: Buffer | Uint8Array | Node Readable
export async function s3PutObject(
    secret: S3Secret,
    bucket: string,
    key: string,
    body: Buffer | Uint8Array | NodeReadable
) {
    const s3 = makeS3Client(secret);
    await s3.send(new PutObjectCommand({ Bucket: bucket, Key: key, Body: body as any }));
}

export async function s3Head(secret: S3Secret, bucket: string, key: string) {
    const s3 = makeS3Client(secret);
    return s3.send(new HeadObjectCommand({ Bucket: bucket, Key: key }));
}

export async function s3Delete(secret: S3Secret, bucket: string, key: string) {
    const s3 = makeS3Client(secret);
    await s3.send(new DeleteObjectCommand({ Bucket: bucket, Key: key }));
}

export async function s3PresignGet(
    secret: S3Secret,
    bucket: string,
    key: string,
    expiresSec = 60 * 10
) {
    const s3 = makeS3Client(secret);
    return getSignedUrl(
        s3,
        new GetObjectCommand({ Bucket: bucket, Key: key }),
        { expiresIn: expiresSec }
    );
}

/* ---------------- SFTP (probe only) ---------------- */
export async function sftpProbe(opts: {
    host: string;
    port?: number;
    username: string;
    password?: string;
    privateKey?: string;
    passphrase?: string;
    hostHash?: string;
    testPath: string;
}) {
    const client = new SftpClient();
    try {
        await client.connect({
            host: opts.host,
            port: opts.port ?? 22,
            username: opts.username,
            password: opts.password,
            privateKey: opts.privateKey,
            passphrase: opts.passphrase,
        });
        const file =
            opts.testPath.replace(/\/+$/, "") +
            "/remoteiq_probe_" +
            crypto.randomBytes(8).toString("hex") +
            ".txt";
        const data = Buffer.from("probe");
        await client.put(data, file);
        const read = (await client.get(file)) as Buffer;
        const okRead = read && read.length === data.length;
        await client.delete(file);
        return { write: true, read: okRead, delete: true };
    } finally {
        try {
            await client.end();
        } catch { }
    }
}

/* ---------------- WebDAV (probe only) ---------------- */
export async function webdavProbe(opts: {
    url: string;
    username: string;
    password: string;
    path: string;
}) {
    const client = createWebdavClient(opts.url, {
        username: opts.username,
        password: opts.password,
    });
    const base = opts.path.replace(/\/+$/, "");
    const name = "remoteiq_probe_" + crypto.randomBytes(8).toString("hex") + ".txt";
    const p = base + "/" + name;
    const data = "probe";
    await client.putFileContents(p, data, { overwrite: true });
    const read = await client.getFileContents(p, { format: "text" });
    const okRead = read === data;
    await client.deleteFile(p);
    return { write: true, read: okRead, delete: true };
}

/* ---------------- Google Drive (probe only) ---------------- */
export async function gdriveProbe(opts: { credentialsJson: any; folderId?: string }) {
    // ✅ Modern constructor signature with options object
    const auth = new google.auth.JWT({
        email: opts.credentialsJson.client_email,
        key: opts.credentialsJson.private_key,
        scopes: ["https://www.googleapis.com/auth/drive.file"],
    });
    const drive = google.drive({ version: "v3", auth });
    const name = "remoteiq_probe_" + crypto.randomBytes(8).toString("hex") + ".txt";

    const createRes = await drive.files.create({
        requestBody: { name, parents: opts.folderId ? [opts.folderId] : undefined },
        media: { mimeType: "text/plain", body: "probe" as any },
        fields: "id",
    });
    const id = createRes.data.id!;
    const get = await drive.files.get({ fileId: id, alt: "media" }, { responseType: "arraybuffer" });
    const okRead = Buffer.from(get.data as any).toString("utf8") === "probe";
    await drive.files.delete({ fileId: id });
    return { write: true, read: okRead, delete: true };
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\storage-clients.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-minimal-e2e\backend\src\backups\worker.service.ts
================================================================================
import { Injectable, Logger } from "@nestjs/common";
import * as fs from "fs";
import * as fsp from "fs/promises";
import * as os from "os";
import * as path from "path";
import archiver from "archiver";
import { PgPoolService } from "../storage/pg-pool.service";
import { s3PutObject, s3Head, ensureDir } from "./storage-clients";
import { NotifierService } from "./notifier.service";

type Job = { id: string; status: string; cancelled: boolean };

type JobConfig = {
    targets: string[];
    destination:
        | { kind: "local"; path: string }
        | { kind: "s3"; connectionId: string; bucket?: string; prefix?: string }
        | { kind: "nextcloud"; connectionId: string; path: string }
        | { kind: "gdrive"; connectionId: string; subfolder?: string }
        | { kind: "remote"; connectionId: string; path: string };
    notifications: { email?: boolean; slack?: boolean; webhook?: boolean };
};

@Injectable()
export class WorkerService {
    private log = new Logger("BackupsWorker");
    private running = false;

    constructor(
        private readonly db: PgPoolService,
        private readonly notifier: NotifierService
    ) { }

    /**
     * Picks the oldest running job (inserted as 'running' by BackupsService.startBackupNow)
     * and processes it. Re-entrant safe; returns immediately if a run is in progress.
     */
    async runOneIfAny() {
        if (this.running) return;
        const job = await this.pickJob();
        if (!job) return;

        this.running = true;
        try {
            await this.process(job.id);
        } finally {
            this.running = false;
        }
    }

    private async pickJob(): Promise<Job | null> {
        // Select oldest running job (already set to 'running' by the service)
        const { rows } = await this.db.query(
            `SELECT id, status, cancelled
         FROM backup_jobs
        WHERE status='running' AND cancelled=false
        ORDER BY started_at ASC
        LIMIT 1`
        );
        return rows[0] ?? null;
    }

    private async appendLog(jobId: string, chunk: string) {
        await this.db.query(
            `INSERT INTO backup_job_logs (job_id, log_text)
       VALUES ($1, $2)
       ON CONFLICT (job_id) DO UPDATE SET log_text = backup_job_logs.log_text || $2`,
            [jobId, chunk]
        );
    }

    /**
     * Process a single job:
     *  - export selected targets to NDJSON (skip missing)
     *  - tar.gz into an archive
     *  - write to local path or upload to S3
     *  - persist manifest/log
     *  - mark success
     */
    async process(jobId: string) {
        const started = Date.now();

        const cfg = await this.loadJobConfig(jobId);
        if (!cfg) {
            await this.fail(jobId, "Backup configuration missing");
            return;
        }

        const tmpRoot = await fsp.mkdtemp(path.join(os.tmpdir(), "remoteiq-bkp-"));
        const exportDir = path.join(tmpRoot, "export");
        await ensureDir(exportDir);

        try {
            // Export targets -> NDJSON files
            const targets: string[] = cfg.targets.length ? cfg.targets : ["users", "devices", "settings"];

            const manifest: any = {
                id: jobId,
                targets,
                files: [],
                counts: {},
                createdAt: new Date().toISOString(),
            };

            await this.appendLog(jobId, `Exporting targets: ${targets.join(", ")}\n`);

            for (const t of targets) {
                // Resolve an existing table/view for this logical target (or skip)
                const table = await this.resolveExistingTableForTarget(jobId, t);
                if (!table) {
                    await this.appendLog(
                        jobId,
                        `  - ${t}: skipped (no mapped table/view exists)\n`
                    );
                    manifest.counts[t] = 0;
                    continue;
                }

                // Export rows to NDJSON
                const file = path.join(exportDir, `${t}.ndjson`);
                const ws = fs.createWriteStream(file, { flags: "w" });

                try {
                    const { rows } = await this.db.query(`SELECT * FROM ${table}`);
                    let count = 0;
                    for (const row of rows) {
                        ws.write(JSON.stringify(row) + "\n");
                        count++;
                    }
                    await new Promise((r) => ws.end(r));
                    manifest.files.push(path.basename(file));
                    manifest.counts[t] = count;
                    await this.appendLog(jobId, `  - ${t}: ${count} rows (from ${table})\n`);
                } catch (e: any) {
                    // If the table disappeared between resolve and select, log and skip
                    await new Promise((r) => ws.end(r));
                    await this.appendLog(
                        jobId,
                        `  - ${t}: error reading ${table} → ${e?.message || e}; skipped\n`
                    );
                    manifest.counts[t] = 0;
                }
            }

            // Create archive (.tar.gz)
            const archiveName = `backup_${new Date()
                .toISOString()
                .replace(/[:]/g, "-")
                .replace(/\..+/, "")}.tar.gz`;
            const archivePath = path.join(tmpRoot, archiveName);
            await this.createTarGz(exportDir, archivePath);

            const stat = await fsp.stat(archivePath);
            await this.appendLog(
                jobId,
                `Archive created: ${archiveName} (${stat.size} bytes)\n`
            );

            // Upload per destination
            const dest = cfg.destination as any;
            let artifactLoc: any = null;

            if (dest.kind === "local") {
                const full = path.join(dest.path, path.basename(archivePath));
                await ensureDir(dest.path);
                await fsp.copyFile(archivePath, full);
                artifactLoc = { kind: "local", path: full };
                await this.appendLog(jobId, `Saved to local path: ${full}\n`);
            } else if (dest.kind === "s3") {
                // Pull secrets from storage_connections
                const cid = dest.connectionId;
                const conn = (
                    await this.db.query(
                        `SELECT config, secrets
               FROM storage_connections
              WHERE id=$1 AND kind='s3'`,
                        [cid]
                    )
                ).rows[0];
                if (!conn) throw new Error("S3 connection not found");
                const cfgS3 = { ...(conn.config || {}), ...(conn.secrets || {}) };
                const bucket = dest.bucket || cfgS3.bucket;
                if (!bucket) throw new Error("S3 bucket not specified");
                const prefix = (dest.prefix || cfgS3.prefix || "").replace(/^\/+|\/+$/g, "");
                const key = (prefix ? `${prefix}/` : "") + path.basename(archivePath);
                await s3PutObject(cfgS3, bucket, key, fs.createReadStream(archivePath));
                await s3Head(cfgS3, bucket, key);
                artifactLoc = {
                    kind: "s3",
                    bucket,
                    key,
                    connectionId: cid,
                    region: cfgS3.region,
                    endpoint: cfgS3.endpoint,
                };
                await this.appendLog(jobId, `Uploaded to s3://${bucket}/${key}\n`);
            } else {
                throw new Error(
                    `Destination kind '${dest.kind}' not supported for upload yet`
                );
            }

            // Save manifest & finalize
            await this.db.query(
                `INSERT INTO backup_job_manifests (job_id, manifest) VALUES ($1, $2)
         ON CONFLICT (job_id) DO UPDATE SET manifest=$2`,
                [jobId, JSON.stringify(manifest)]
            );

            const durationSec = Math.max(1, Math.round((Date.now() - started) / 1000));
            await this.db.query(
                `UPDATE backup_jobs
           SET finished_at=NOW(),
               status='completed',
               size_bytes=$2,
               duration_sec=$3,
               verified=true,
               artifact_location=$4
         WHERE id=$1`,
                [jobId, stat.size, durationSec, JSON.stringify(artifactLoc)]
            );

            await this.appendLog(jobId, `Done in ${durationSec}s\n`);

            // Notify (best-effort)
            await this.notify(
                cfg.notifications,
                `Backup ${jobId} success`,
                `Size=${stat.size} Duration=${durationSec}s`
            );
        } catch (e: any) {
            this.log.error(`Backup job ${jobId} failed: ${e?.message || e}`);
            await this.fail(jobId, e?.message || "Worker error");
            // try to notify failure, best-effort
            try {
                await this.notify(
                    cfg?.notifications ?? {},
                    `Backup ${jobId} failed`,
                    e?.message || "Worker error"
                );
            } catch { }
        } finally {
            // cleanup temp
            try {
                await fsp.rm(tmpRoot, { recursive: true, force: true });
            } catch { }
        }
    }

    private async fail(jobId: string, note: string) {
        await this.db.query(
            `UPDATE backup_jobs
          SET status='failed',
              finished_at=NOW(),
              note=$2
        WHERE id=$1`,
            [jobId, note]
        );
    }

    private async createTarGz(srcDir: string, outFile: string) {
        await new Promise<void>((resolve, reject) => {
            const output = fs.createWriteStream(outFile);
            const archive = archiver("tar", { gzip: true, gzipOptions: { level: 9 } });
            output.on("close", () => resolve());
            archive.on("error", (err) => reject(err));
            archive.pipe(output);
            archive.directory(srcDir, false);
            archive.finalize().catch(reject);
        });
    }

    /**
     * Map a logical target to candidate DB objects and return the first that exists.
     * Uses to_regclass to test existence safely (prevents injection via fixed mapping).
     */
    private async resolveExistingTableForTarget(jobId: string, target: string): Promise<string | null> {
        // Strict, explicit mapping only (no user input becomes SQL identifiers).
        // Add/adjust candidates here to match your schema names.
        const candidatesByTarget: Record<string, string[]> = {
            users: ["public.users", "users"],
            roles: ["public.roles", "roles"],
            devices: ["public.devices", "devices"],
            policies: ["public.policies", "policies"],
            audit_logs: ["public.audit_logs", "audit_logs", "public.auditlog", "auditlog"],
            settings: ["public.settings", "settings", "public.app_settings", "app_settings", "public.system_settings", "system_settings"],
            templates: ["public.templates", "templates"],
        };

        const candidates = candidatesByTarget[target] || [];
        for (const ident of candidates) {
            const reg = await this.db.query(`SELECT to_regclass($1) AS oid`, [ident]);
            const exists = !!reg.rows?.[0]?.oid;
            if (exists) return ident;
        }
        // log a one-liner for visibility
        await this.appendLog(jobId, `    (no table/view found for target "${target}")\n`);
        return null;
    }

    private async loadJobConfig(jobId: string): Promise<JobConfig | null> {
        const { rows } = await this.db.query(
            `SELECT j.id,
                    p.options,
                    d.configuration AS destination_configuration
               FROM backup_jobs j
          LEFT JOIN backup_policies p ON j.policy_id = p.id
          LEFT JOIN backup_destinations d ON d.id = p.destination_id
              WHERE j.id=$1`,
            [jobId]
        );
        if (!rows.length) {
            return null;
        }

        const options = rows[0].options && typeof rows[0].options === "object" ? rows[0].options : {};
        if (options.enabled === false) {
            return null;
        }

        const destination = rows[0].destination_configuration || {};
        if (!destination.kind) {
            return null;
        }

        const targets = Array.isArray(options.targets) ? options.targets.filter(Boolean) : [];
        const notifications =
            options.notifications && typeof options.notifications === "object"
                ? options.notifications
                : {};

        return {
            targets,
            destination,
            notifications,
        };
    }

    private async notify(
        channels: { email?: boolean; slack?: boolean; webhook?: boolean },
        subject: string,
        body: string
    ) {
        try {
            await this.notifier.send(channels || {}, subject, body);
        } catch (e) {
            this.log.warn(`Notify failed: ${e}`);
        }
    }
}

================================================================================
END FILE: remoteiq-minimal-e2e\backend\src\backups\worker.service.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\middleware.ts
================================================================================
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";

const PUBLIC_PATHS = new Set<string>([
    "/login",
    "/favicon.ico",
    "/robots.txt",
    "/sitemap.xml",
]);

export function middleware(req: NextRequest) {
    const { pathname } = req.nextUrl;

    // Normalize legacy route to the new one
    if (pathname === "/auth/login") {
        const url = req.nextUrl.clone();
        url.pathname = "/login";
        // default to home after login
        url.searchParams.set("next", "/");
        return NextResponse.redirect(url);
    }

    // Never run on /login or static assets (avoid loops)
    if (
        pathname === "/login" ||
        pathname.startsWith("/_next/") ||
        pathname.startsWith("/static/") ||
        pathname.startsWith("/images/") ||
        pathname.startsWith("/fonts/")
    ) {
        return NextResponse.next();
    }

    // Allow any frontend /api if you have them
    if (pathname.startsWith("/api/")) {
        return NextResponse.next();
    }

    if (PUBLIC_PATHS.has(pathname)) {
        return NextResponse.next();
    }

    const token = req.cookies.get("auth_token")?.value;

    if (!token) {
        const url = req.nextUrl.clone();
        url.pathname = "/login";
        // set next to the requested path; it’s sanitized on the login page
        url.searchParams.set("next", pathname || "/");
        return NextResponse.redirect(url);
    }

    return NextResponse.next();
}

export const config = {
    matcher: [
        "/((?!_next/static|_next/image|favicon.ico|robots.txt|sitemap.xml|login).*)",
    ],
};

================================================================================
END FILE: remoteiq-frontend\middleware.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\app\administration\layout.tsx
================================================================================
// app/administration/layout.tsx
import * as React from "react";
import TopBar from "@/components/top-bar";

export const metadata = {
    title: "Administration • RemoteIQ",
};

export default function AdministrationLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <>
            {/* Global fixed top bar */}
            <TopBar />

            {/* Scroll container for the admin area (no layout shift when scrollbar shows) */}
            <div
                className="bg-background h-[calc(100vh-3.5rem)] overflow-y-scroll"
                style={{ scrollbarGutter: "stable both-edges" }}
            >
                {/* keep the original top spacing so content clears the fixed TopBar */}
                <div className="pt-14">{children}</div>
            </div>
        </>
    );
}

================================================================================
END FILE: remoteiq-frontend\app\administration\layout.tsx
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\app\administration\page.tsx
================================================================================
// app/administration/page.tsx
"use client";

import * as React from "react";
import dynamic from "next/dynamic";
import { useRouter, useSearchParams } from "next/navigation";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    DialogDescription,
    DialogFooter,
} from "@/components/ui/dialog";
import {
    Shield,
    ShieldCheck,
    Users,
    KeyRound,
    ServerCog,
    FileText,
    Rocket,
    Mail,
    Database,
    Cloud,
    ArchiveRestore,
    FileSignature,
    Building2,
    CreditCard,
    ReceiptText,
    Palette,
    Languages,
    BellRing,
    LockKeyhole,
    Gavel,
    Plug,
    Laptop2,
    Workflow,
    ArrowRightLeft,
    ListPlus,
    Gem,
    UserCog,
    Ticket,
    Vault,
    Table,
    DatabaseZap,
    BarChart3,
    BookUser,
    CalendarClock,
    Lock,
    UserCheck,
    ChevronDown,
} from "lucide-react";
import { cn } from "@/lib/utils";

// API
import {
    getAdminUsers,
    getAdminRoles,
    removeUser,
    getLocalizationSettings,
    type UserDTO,
} from "@/lib/api";

// Shared UI types
import type { User as UiUser, LocalizationSettings } from "./types";

// Tabs (lazy)
const UsersTab = dynamic(() => import("./tabs/UsersTab"));
const RolesTab = dynamic(() => import("./tabs/RolesTab"));
const CompanyTab = dynamic(() => import("./tabs/CompanyTab"));
const BillingTab = dynamic(() => import("./tabs/BillingTab"));
const InvoicesTab = dynamic(() => import("./tabs/InvoicesTab"));
const SmtpTab = dynamic(() => import("./tabs/SmtpTab"));
const SystemTab = dynamic(() => import("./tabs/SystemTab"));
const SsoTab = dynamic(() => import("./tabs/SsoTab"));
const DatabaseTab = dynamic(() => import("./tabs/DatabaseTab"));
const StorageTab = dynamic(() => import("./tabs/StorageTab"));
const BackupsTab = dynamic(() => import("./tabs/BackupsTab"));
const EmailTemplatesTab = dynamic(() => import("./tabs/TemplatesTab"));
const AuditLogsTab = dynamic(() => import("./tabs/AuditLogsTab"));
const ApiTab = dynamic(() => import("./tabs/ApiTab"));
const FeatureFlagsTab = dynamic(() => import("./tabs/FlagsTab"));
const BrandingTab = dynamic(() => import("./tabs/BrandingTab"));
const LocalizationTab = dynamic(() => import("./tabs/LocalizationTab"));
const NotificationsTab = dynamic(() => import("./tabs/NotificationsTab"));
const SecurityPoliciesTab = dynamic(() => import("./tabs/SecurityPoliciesTab"));
const IntegrationsTab = dynamic(() => import("./tabs/IntegrationsTab"));
const SubscriptionTab = dynamic(() => import("./tabs/SubscriptionTab"));
const ClientPortalTab = dynamic(() => import("./tabs/ClientPortalTab"));
const ComplianceTab = dynamic(() => import("./tabs/ComplianceTab"));
const AgentsTab = dynamic(() => import("./tabs/AgentsTab"));
const WorkflowsTab = dynamic(() => import("./tabs/WorkflowsTab"));
const ImportExportTab = dynamic(() => import("./tabs/ImportExportTab"));
const CustomFieldsTab = dynamic(() => import("./tabs/CustomFieldsTab"));
const SlaTab = dynamic(() => import("./tabs/SlaTab"));
const TicketingTab = dynamic(() => import("./tabs/TicketingTab"));
const SecretsTab = dynamic(() => import("./tabs/SecretsTab"));
// ✅ Use the SessionsTab from account (has onDirtyChange/saveHandleRef)
const SessionsTab = dynamic(() => import("../account/tabs/SessionsTab"));
const RolesMatrixTab = dynamic(() => import("./tabs/RolesMatrixTab"));
const MigrationsTab = dynamic(() => import("./tabs/MigrationsTab"));
const SupportTab = dynamic(() => import("./tabs/SupportTab"));
const ReportsTab = dynamic(() => import("./tabs/ReportsTab"));

/* ---------------- Toasts ---------------- */
type Toast = {
    id: string;
    title: string;
    desc?: string;
    kind: "success" | "destructive" | "warning" | "default";
};

function useToasts() {
    const [toasts, setToasts] = React.useState<Toast[]>([]);
    const push = React.useCallback((t: Omit<Toast, "id">) => {
        const id = Math.random().toString(36).slice(2);
        setToasts((prev) => [...prev, { ...t, id }]);
        window.setTimeout(
            () => setToasts((prev) => prev.filter((x) => x.id !== id)),
            4200
        );
    }, []);
    return { toasts, push };
}

/* ---------------- Helpers ---------------- */
function mapUserDTO(u: UserDTO): UiUser {
    // keep API fields intact; UsersTab expects UiUser shape
    return { ...(u as any) } as unknown as UiUser;
}

// API base helper (so we can call /api/roles directly)
function getApiBase(): string {
    const raw = (process.env.NEXT_PUBLIC_API_BASE || "").replace(/\/+$/, "");
    if (!raw) return "/api";
    return raw.endsWith("/api") ? raw : `${raw}/api`;
}
const API_BASE = getApiBase();

// Coerce API firstDayOfWeek into the UI union: "sunday" | "monday"
function coerceFirstDay(apiVal: unknown): "sunday" | "monday" {
    if (typeof apiVal === "string") {
        const v = apiVal.toLowerCase();
        if (v === "sunday" || v === "monday") return v;
    }
    if (typeof apiVal === "number") {
        return apiVal === 0 ? "sunday" : "monday";
    }
    return "monday";
}

function mapLocalization(apiLoc: any): LocalizationSettings {
    const allowedLangs = new Set(["en-US", "en-GB", "es-ES", "fr-FR"]);
    const langRaw = apiLoc?.language;
    const language = allowedLangs.has(langRaw) ? langRaw : "en-US";

    return {
        language,
        timeZone: apiLoc?.timeZone ?? apiLoc?.timezone ?? "UTC",
        numberFormat: apiLoc?.numberFormat ?? "1,234.56",
        dateFormat: apiLoc?.dateFormat ?? "YYYY-MM-DD",
        timeFormat: apiLoc?.timeFormat ?? "24h",
        firstDayOfWeek: coerceFirstDay(apiLoc?.firstDayOfWeek),
    };
}

export default function AdministrationPage() {
    const { toasts, push: pushToast } = useToasts();
    const push = pushToast;

    // -------- tab state with URL + localStorage persistence --------
    const router = useRouter();
    const searchParams = useSearchParams();
    const [tab, setTab] = React.useState("company");

    // ===== SHARED DATA =====
    const [users, setUsers] = React.useState<UiUser[]>([]);
    const [roles, setRoles] = React.useState<any[]>([]); // pass-through; RolesTab normalizes
    const [loading, setLoading] = React.useState(false);
    const [loc, setLoc] = React.useState<LocalizationSettings | null>(null);

    const loadedRef = React.useRef(false);

    /* ---------------- Left Nav model (used for VALID_TABS) ---------------- */
    const navItemGroups = React.useMemo(
        () => [
            {
                title: "General",
                items: [
                    { v: "company", label: "Company", Icon: Building2 },
                    { v: "branding", label: "Branding", Icon: Palette },
                    { v: "localization", label: "Localization", Icon: Languages },
                    { v: "support", label: "Support & Legal", Icon: BookUser },
                ],
            },
            {
                title: "Access Management",
                items: [
                    { v: "users", label: "Users", Icon: Users },
                    { v: "roles", label: "Roles", Icon: ShieldCheck },
                    { v: "sso", label: "SSO", Icon: Lock },
                    { v: "security_policies", label: "Security Policies", Icon: LockKeyhole },
                    { v: "sessions", label: "Session Mgmt", Icon: UserCheck },
                    { v: "roles_matrix", label: "Roles Matrix", Icon: Table },
                ],
            },
            {
                title: "Billing",
                items: [
                    { v: "subscription", label: "Subscription", Icon: Gem },
                    { v: "billing", label: "Billing", Icon: CreditCard },
                    { v: "invoices", label: "Invoices", Icon: ReceiptText },
                ],
            },
            {
                title: "Communications",
                items: [
                    { v: "smtp", label: "SMTP", Icon: Mail },
                    { v: "notifications", label: "Notifications", Icon: BellRing },
                    { v: "templates", label: "Email Templates", Icon: FileSignature },
                ],
            },
            {
                title: "Infrastructure",
                items: [
                    { v: "system", label: "System", Icon: ServerCog },
                    { v: "database", label: "Database", Icon: Database },
                    { v: "storage", label: "Storage (S3)", Icon: Cloud },
                    { v: "backups", label: "Backups", Icon: ArchiveRestore },
                    { v: "agents", label: "Agents", Icon: Laptop2 },
                    { v: "migrations", label: "Data Migrations", Icon: DatabaseZap },
                ],
            },
            {
                title: "Advanced",
                items: [
                    { v: "audit", label: "Audit Logs", Icon: FileText },
                    { v: "api", label: "API", Icon: KeyRound },
                    { v: "integrations", label: "Integrations", Icon: Plug },
                    { v: "secrets", label: "Secrets", Icon: Vault },
                    { v: "workflows", label: "Workflows", Icon: Workflow },
                    { v: "import_export", label: "Import / Export", Icon: ArrowRightLeft },
                    { v: "custom_fields", label: "Custom Fields", Icon: ListPlus },
                    { v: "client_portal", label: "Client Portal", Icon: UserCog },
                    { v: "sla", label: "SLA", Icon: CalendarClock },
                    { v: "ticketing", label: "Ticketing", Icon: Ticket },
                    { v: "reports", label: "Reports", Icon: BarChart3 },
                    { v: "flags", label: "Feature Flags", Icon: Rocket },
                    { v: "compliance", label: "Compliance", Icon: Gavel },
                ],
            },
        ],
        []
    );

    // Build set of valid tab keys for validation
    const VALID_TABS = React.useMemo(
        () => new Set(navItemGroups.flatMap((g) => g.items.map((i) => i.v))),
        [navItemGroups]
    );

    // On first mount, derive initial tab from URL (?tab=) or localStorage
    React.useEffect(() => {
        const fromQuery = searchParams?.get("tab") || "";
        const fromStorage =
            typeof window !== "undefined" ? localStorage.getItem("admin.tab") || "" : "";

        const initial =
            (fromQuery && VALID_TABS.has(fromQuery)) ? fromQuery :
                (fromStorage && VALID_TABS.has(fromStorage)) ? fromStorage :
                    "company";

        setTab(initial);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    // Persist tab changes to URL + localStorage
    React.useEffect(() => {
        if (!tab) return;

        if (typeof window !== "undefined") {
            localStorage.setItem("admin.tab", tab);
        }

        const current = new URLSearchParams(searchParams ? searchParams.toString() : "");
        current.set("tab", tab);
        router.replace(`?${current.toString()}`, { scroll: false });
    }, [tab, searchParams, router]);

    /* ---------------- Data fetching ---------------- */
    const refetchUsers = React.useCallback(async () => {
        try {
            const { items } = await getAdminUsers();
            setUsers(items.map(mapUserDTO));
        } catch (e: any) {
            push({
                title: "Failed to refresh users",
                desc: e?.message ?? "Internal server error",
                kind: "destructive",
            });
        }
    }, [push]);

    React.useEffect(() => {
        if (loadedRef.current) return;
        loadedRef.current = true;

        (async () => {
            setLoading(true);
            try {
                const [usersRes, rolesRes, locRes] = await Promise.allSettled([
                    getAdminUsers(),
                    getAdminRoles(),
                    getLocalizationSettings(),
                ]);

                // Users
                if (usersRes.status === "fulfilled") {
                    const items = usersRes.value?.items ?? [];
                    setUsers(items.map(mapUserDTO));
                } else {
                    setUsers([]);
                    push({
                        title: "Failed to load users",
                        desc: (usersRes.reason as any)?.message ?? "Internal server error",
                        kind: "destructive",
                    });
                }

                // Roles — prefer full /api/roles if the admin listing is "short"
                if (rolesRes.status === "fulfilled") {
                    const maybe = Array.isArray((rolesRes.value as any)?.items)
                        ? (rolesRes.value as any).items
                        : Array.isArray(rolesRes.value)
                            ? (rolesRes.value as any)
                            : [];

                    const looksShort =
                        Array.isArray(maybe) &&
                        maybe.length > 0 &&
                        maybe[0] &&
                        maybe[0].description === undefined &&
                        maybe[0].permissions === undefined;

                    try {
                        const full = looksShort
                            ? await fetch(`${API_BASE}/roles`, {
                                cache: "no-store",
                                credentials: "include",
                            }).then((r) => {
                                if (!r.ok) throw new Error(`Failed to GET /roles (${r.status})`);
                                return r.json() as Promise<any[]>;
                            })
                            : maybe ?? [];

                        setRoles(full as any[]);
                    } catch (e: any) {
                        setRoles(maybe as any[]);
                        push({
                            title: "Failed to load role details",
                            desc: e?.message ?? "Request failed",
                            kind: "destructive",
                        });
                    }
                } else {
                    setRoles([]);
                    push({
                        title: "Failed to load roles",
                        desc: (rolesRes.reason as any)?.message ?? "Internal server error",
                        kind: "destructive",
                    });
                }

                // Localization
                if (locRes.status === "fulfilled") {
                    const apiLoc = locRes.value ?? null;
                    setLoc(apiLoc ? mapLocalization(apiLoc) : null);
                } else {
                    setLoc(null);
                }
            } finally {
                setLoading(false);
            }
        })();
    }, [push]);

    // Invite modal (optional)
    const [inviteOpen, setInviteOpen] = React.useState(false);
    const [inviteEmails, setInviteEmails] = React.useState("");

    function onInviteUsers() {
        const emails = inviteEmails
            .split(",")
            .map((e) => e.trim())
            .filter(Boolean);
        if (!emails.length) {
            push({ title: "No emails provided", kind: "warning" });
            return;
        }
        setInviteEmails("");
        setInviteOpen(false);
        push({
            title: "Invitations queued",
            desc: `Sent to ${emails.length} recipient(s).`,
            kind: "success",
        });
    }

    const [removeUserId, setRemoveUserId] = React.useState<string | null>(null);
    const [reset2FAUserId, setReset2FAUserId] = React.useState<string | null>(null);

    async function onConfirmRemoveUser() {
        if (!removeUserId) return;
        const id = removeUserId;
        setRemoveUserId(null);

        const before = users;
        setUsers((prev) => prev.filter((p) => p.id !== id));
        try {
            await removeUser(id);
            await refetchUsers();
            push({ title: "User deleted", kind: "success" });
        } catch (e: any) {
            setUsers(before);
            push({
                title: "Failed to delete user",
                desc: e?.message ?? "Request failed",
                kind: "destructive",
            });
        }
    }

    /* ---------------- Left Nav UI state ---------------- */
    const [openGroups, setOpenGroups] = React.useState<string[]>([]);

    React.useEffect(() => {
        const currentGroup = navItemGroups.find((g) =>
            g.items.some((item) => item.v === tab)
        );
        if (currentGroup) {
            setOpenGroups((prev) =>
                prev.includes(currentGroup.title) ? prev : [...prev, currentGroup.title]
            );
        }
    }, [tab, navItemGroups]);

    const toggleGroup = (title: string) => {
        setOpenGroups((prev) =>
            prev.includes(title) ? prev.filter((g) => g !== title) : [...prev, title]
        );
    };

    return (
        <main className="p-4 sm:p-6">
            <div className="mx-auto max-w-7xl">
                <div className="mb-6">
                    <h1 className="text-xl font-semibold flex items-center gap-2">
                        <Shield className="h-5 w-5" /> Administration
                    </h1>
                    <p className="text-sm text-muted-foreground">
                        Organization-wide settings, users, roles, storage, billing and system
                        controls.
                    </p>
                </div>

                <Tabs
                    value={tab}
                    onValueChange={setTab}
                    className="grid grid-cols-[240px_1fr] items-start gap-6"
                >
                    {/* Left rail */}
                    <aside className="w-[240px] shrink-0 self-start sticky top-[70px] sm:top-[70px]">
                        <Card>
                            <TabsList className="flex h-auto w-full flex-col items-start justify-start gap-1 bg-transparent p-2">
                                {navItemGroups.map((group, groupIndex) => (
                                    <div
                                        key={group.title}
                                        className={cn("w-full", groupIndex > 0 && "border-t mt-2 pt-2")}
                                    >
                                        <button
                                            onClick={() => toggleGroup(group.title)}
                                            className="w-full flex items-center justify-start gap-2 rounded-md px-2 py-2 text-sm font-semibold text-foreground hover:bg-muted/50"
                                        >
                                            <ChevronDown
                                                className={cn(
                                                    "h-4 w-4 transition-transform text-muted-foreground",
                                                    openGroups.includes(group.title) ? "rotate-0" : "-rotate-90"
                                                )}
                                            />
                                            {group.title}
                                        </button>
                                        {group.items.map(({ v, label, Icon }) => {
                                            const isOpen = openGroups.includes(group.title);
                                            const isActive = tab === v;
                                            if (!isOpen && !isActive) return null;
                                            return (
                                                <TabsTrigger
                                                    key={v}
                                                    value={v}
                                                    className="w-full justify-start rounded-md border-l-2 border-transparent px-3 py-2 pl-8 text-sm text-muted-foreground hover:bg-muted/50 data-[state=active]:border-l-primary data-[state=active]:bg-primary/10 data-[state=active]:font-semibold data-[state=active]:text-primary"
                                                >
                                                    <Icon className="mr-2 h-4 w-4" />
                                                    {label}
                                                </TabsTrigger>
                                            );
                                        })}
                                    </div>
                                ))}
                            </TabsList>
                        </Card>
                    </aside>

                    {/* Right side */}
                    <div className="min-w-0 flex-1">
                        {tab === "users" && (
                            <UsersTab
                                users={users}
                                setUsers={setUsers}
                                roles={roles as any[]}
                                push={push}
                                setRemoveUserId={() => { }}
                                setReset2FAUserId={() => { }}
                                setInviteOpen={() => { }}
                                refetchUsers={refetchUsers}
                                localization={loc ?? undefined}
                            />
                        )}

                        {tab === "roles" && (
                            <RolesTab
                                roles={roles as any[]} // pass-through (keeps description + permissions)
                                setRoles={setRoles as any}
                                push={push}
                            />
                        )}

                        {tab === "company" && <CompanyTab push={push} />}
                        {tab === "branding" && <BrandingTab push={push} />}
                        {tab === "localization" && <LocalizationTab push={push} />}
                        {tab === "support" && <SupportTab push={push} />}

                        {tab === "subscription" && <SubscriptionTab push={push} />}
                        {tab === "billing" && <BillingTab push={push} />}
                        {tab === "invoices" && <InvoicesTab push={push} />}
                        {tab === "security_policies" && <SecurityPoliciesTab push={push} />}
                        {tab === "smtp" && <SmtpTab push={push} />}
                        {tab === "notifications" && <NotificationsTab push={push} />}
                        {tab === "templates" && <EmailTemplatesTab push={push} />}

                        {tab === "system" && <SystemTab push={push} />}
                        {tab === "database" && <DatabaseTab push={push} />}

                        {/* ⬇️ FIX: stop passing `push` to StorageTab and BackupsTab */}
                        {tab === "storage" && <StorageTab />}
                        {tab === "backups" && <BackupsTab />}

                        {tab === "agents" && <AgentsTab push={push} />}
                        {tab === "migrations" && <MigrationsTab push={push} />}

                        {tab === "audit" && <AuditLogsTab push={push} />}
                        {tab === "api" && <ApiTab push={push} />}
                        {tab === "integrations" && <IntegrationsTab push={push} />}
                        {tab === "secrets" && <SecretsTab push={push} />}
                        {tab === "workflows" && <WorkflowsTab push={push} />}
                        {tab === "import_export" && <ImportExportTab push={push} />}
                        {tab === "custom_fields" && <CustomFieldsTab push={push} />}
                        {tab === "client_portal" && <ClientPortalTab push={push} />}
                        {tab === "sla" && <SlaTab push={push} />}
                        {tab === "ticketing" && <TicketingTab push={push} />}
                        {tab === "reports" && <ReportsTab push={push} />}
                        {tab === "flags" && <FeatureFlagsTab push={push} />}
                        {tab === "compliance" && <ComplianceTab push={push} />}

                        {/* ✅ Sessions tab now imports the account version with matching props */}
                        {tab === "sessions" && (
                            <SessionsTab onDirtyChange={() => { }} saveHandleRef={() => { }} />
                        )}

                        {tab === "roles_matrix" && <RolesMatrixTab push={push} />}
                        {tab === "sso" && <SsoTab push={push} />}
                    </div>
                </Tabs>
            </div>

            {/* Invite dialog */}
            <Dialog open={inviteOpen} onOpenChange={setInviteOpen}>
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Invite users</DialogTitle>
                        <DialogDescription>
                            Enter one or more email addresses, separated by commas.
                        </DialogDescription>
                    </DialogHeader>
                    <div className="space-y-2">
                        <Label htmlFor="invite-emails">Email addresses</Label>
                        <Input
                            id="invite-emails"
                            placeholder="alice@acme.com, bob@acme.com"
                            value={inviteEmails}
                            onChange={(e) => setInviteEmails(e.target.value)}
                        />
                    </div>
                    <DialogFooter className="mt-4">
                        <Button variant="outline" onClick={() => setInviteOpen(false)}>
                            Cancel
                        </Button>
                        <Button variant="success" onClick={onInviteUsers}>
                            Send invites
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            {/* Toasts */}
            <div className="fixed bottom-4 right-4 z-[100] space-y-2">
                {toasts.map((t) => {
                    const klass =
                        t.kind === "success"
                            ? "border-emerald-200 bg-emerald-50 text-emerald-900 dark:border-emerald-700 dark:bg-emerald-900/20 dark:text-emerald-200"
                            : t.kind === "destructive"
                                ? "border-red-200 bg-red-50 text-red-900 dark:border-red-700 dark:bg-red-900/20 dark:text-red-200"
                                : t.kind === "warning"
                                    ? "border-amber-300 bg-amber-50 text-amber-900 dark:border-amber-600 dark:bg-amber-900/20 dark:text-amber-200"
                                    : "border-border bg-card text-card-foreground";
                    return (
                        <div
                            key={t.id}
                            className={cn("w-[340px] rounded-md border px-4 py-3 shadow-md", klass)}
                        >
                            <div className="text-sm font-medium">{t.title}</div>
                            {t.desc ? <div className="mt-1 text-xs opacity-90">{t.desc}</div> : null}
                        </div>
                    );
                })}
            </div>
        </main>
    );
}

================================================================================
END FILE: remoteiq-frontend\app\administration\page.tsx
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\app\(dashboard)\layout.tsx
================================================================================
// app/(dashboard)/layout.tsx
"use client";

import * as React from "react";
import { usePathname } from "next/navigation";
import TopBar from "@/components/top-bar";
import Sidebar from "@/components/sidebar";

/**
 * Dashboard area shell
 * - Global TopBar (fixed 56px).
 * - Optional left Sidebar (only on /devices…; the /customers area renders its own sidebar).
 * - Main content scrolls independently.
 *
 * NOTE: DashboardProvider is already mounted at the app root (via app/providers.tsx),
 * so we intentionally do NOT wrap another provider here to avoid double contexts.
 */
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
    return (
        <div className="min-h-screen">
            <TopBar />
            <SidebarVisibility>{children}</SidebarVisibility>
        </div>
    );
}

/**
 * Shows the global Sidebar only on Devices pages.
 * - Dashboard ("/"): hide sidebar
 * - Customers ("/customers…"): hide (Customers has its own sidebar/layout)
 * - Devices ("/devices…"): show sidebar
 */
function SidebarVisibility({ children }: { children: React.ReactNode }) {
    const pathname = usePathname();
    const showSidebar = pathname?.startsWith("/devices");

    return (
        <div className="flex w-full" style={{ paddingTop: 56 /* TopBar height */ }}>
            {showSidebar && (
                <aside className="hidden md:block w-64 shrink-0 border-r bg-background">
                    <Sidebar />
                </aside>
            )}
            <section className="flex-1 min-w-0">{children}</section>
        </div>
    );
}

================================================================================
END FILE: remoteiq-frontend\app\(dashboard)\layout.tsx
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\components\sidebar.tsx
================================================================================
//components\sidebar.tsx

"use client";

import * as React from "react";
import { useRouter, useSearchParams, usePathname } from "next/navigation";
import { ChevronRight, ChevronDown, Building2, Users2, Monitor } from "lucide-react";
import { cn } from "@/lib/utils";
import { useDashboard } from "@/app/(dashboard)/dashboard-context";

type SiteKey = `${string}|${string}`; // "Org|Site"

export default function Sidebar() {
    const pathname = usePathname();
    const isCustomers = pathname.startsWith("/customers");
    const { masterDevices } = useDashboard();

    // Build Clients → Sites tree
    const tree = React.useMemo(() => {
        const byOrg = new Map<string, Set<string>>();
        for (const d of masterDevices) {
            if (!byOrg.has(d.client)) byOrg.set(d.client, new Set());
            byOrg.get(d.client)!.add(d.site);
        }
        return Array.from(byOrg.entries())
            .map(([org, set]) => ({ org, sites: Array.from(set).sort((a, b) => a.localeCompare(b)) }))
            .sort((a, b) => a.org.localeCompare(b.org));
    }, [masterDevices]);

    const allOrgNames = React.useMemo(() => tree.map(t => t.org), [tree]);

    const router = useRouter();
    const qs = useSearchParams();

    const scope = qs.get("scope") || "";
    const orgsParam = qs.get("orgs") || "";
    const sitesParam = qs.get("sites") || "";

    const expandedOrgs = React.useMemo(() => {
        const list = orgsParam ? orgsParam.split(",").filter(Boolean) : [];
        return new Set(list.filter((o) => allOrgNames.includes(o)));
    }, [orgsParam, allOrgNames]);

    const selectedSites = React.useMemo(() => {
        const list = sitesParam ? sitesParam.split(",").filter(Boolean) : [];
        const valid = new Set<SiteKey>();
        for (const item of list) {
            const [org, site] = item.split("|");
            if (!org || !site) continue;
            const entry = tree.find((t) => t.org === org);
            if (entry && entry.sites.includes(site)) valid.add(`${org}|${site}`);
        }
        return valid;
    }, [sitesParam, tree]);

    const setQuery = React.useCallback((updater: (u: URL) => void) => {
        const url = new URL(window.location.href);
        updater(url);
        router.replace(`${url.pathname}?${url.searchParams.toString()}`);
    }, [router]);

    const gotoRootCustomers = () => {
        setQuery((url) => {
            url.searchParams.set("scope", "customers");
            url.searchParams.delete("orgs");
            url.searchParams.delete("sites");
        });
    };

    const toggleOrg = (org: string) => {
        const next = new Set(expandedOrgs);
        next.has(org) ? next.delete(org) : next.add(org);
        setQuery((url) => {
            url.searchParams.set("scope", "customers");
            url.searchParams.set("orgs", Array.from(next).join(","));
            // trim sites to only those under expanded orgs
            const kept = Array.from(selectedSites).filter((s) => next.has(s.split("|")[0]!));
            if (kept.length) url.searchParams.set("sites", kept.join(","));
            else url.searchParams.delete("sites");
        });
    };

    const toggleSite = (org: string, site: string) => {
        const key = `${org}|${site}` as SiteKey;
        const nextSites = new Set<SiteKey>(selectedSites);
        nextSites.has(key) ? nextSites.delete(key) : nextSites.add(key);

        const nextOrgs = new Set(expandedOrgs);
        nextOrgs.add(org);

        setQuery((url) => {
            url.searchParams.set("scope", "customers");
            url.searchParams.set("orgs", Array.from(nextOrgs).join(","));
            if (nextSites.size) url.searchParams.set("sites", Array.from(nextSites).join(","));
            else url.searchParams.delete("sites");
        });
    };

    const rootActive = isCustomers && scope === "customers";
    const orgIsExpanded = (org: string) => expandedOrgs.has(org);
    const siteIsSelected = (org: string, site: string) => selectedSites.has(`${org}|${site}`);

    return (
        <aside
            className={cn(
                "w-64 shrink-0 border-r bg-background",
                // starts below top bar; its own scroller
                "h-[calc(100vh-3.5rem)] overflow-y-auto"
            )}
        >
            <div className="px-3 py-2">
                {/* Customers root */}
                <button
                    onClick={gotoRootCustomers}
                    className={cn(
                        "flex w-full items-center gap-2 rounded-md px-2 py-2 text-sm hover:bg-accent",
                        rootActive ? "bg-accent text-accent-foreground" : "text-foreground"
                    )}
                    title="Customers"
                >
                    <Users2 className="h-4 w-4" />
                    <span className="truncate">Customers</span>
                </button>

                {/* Orgs + sites */}
                <div className="mt-2 space-y-1">
                    {tree.map(({ org, sites }) => (
                        <div key={org}>
                            <button
                                onClick={() => toggleOrg(org)}
                                className={cn(
                                    "flex w-full items-center gap-2 rounded-md px-2 py-2 text-sm hover:bg-accent",
                                    orgIsExpanded(org) ? "bg-muted" : ""
                                )}
                                title={org}
                            >
                                {orgIsExpanded(org) ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
                                <Building2 className="h-4 w-4 opacity-70" />
                                <span className="truncate">{org}</span>
                            </button>

                            {orgIsExpanded(org) && (
                                <div className="ml-6 mt-1 space-y-1">
                                    {sites.map((site) => (
                                        <button
                                            key={site}
                                            onClick={() => toggleSite(org, site)}
                                            className={cn(
                                                "flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-sm hover:bg-accent",
                                                siteIsSelected(org, site) ? "bg-accent text-accent-foreground" : "text-foreground"
                                            )}
                                            title={`${org} • ${site}`}
                                        >
                                            <Monitor className="h-3.5 w-3.5 opacity-70" />
                                            <span className="truncate">{site}</span>
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>
                    ))}
                </div>
            </div>
        </aside>
    );
}

================================================================================
END FILE: remoteiq-frontend\components\sidebar.tsx
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\components\top-bar.tsx
================================================================================
// app/(dashboard)/top-bar.tsx
"use client";

/**
 * Top Bar
 * ----------------------------------------------------------------
 * Saved Views + Automation + Search + Theme + Admin + Avatar
 * Adds "Dashboard" and "Customers" tabs next to the brand.
 * Uses user avatar from /api/users/me when available.
 */

import React, { useEffect, useRef, useState } from "react";
import {
    Moon,
    Search,
    Sun,
    Bell,
    Bookmark,
    PlusCircle,
    Trash2,
    Laptop,
    PlaySquare,
    ChevronDown,
    Link as LinkIcon,
    Save,
    ActivitySquare,
    MemoryStick,
    Shield,
} from "lucide-react";
import Link from "next/link";
import { useTheme } from "next-themes";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuTrigger,
    DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import {
    Dialog,
    DialogContent,
    DialogDescription,
    DialogFooter,
    DialogHeader,
    DialogTitle,
    DialogTrigger,
} from "@/components/ui/dialog";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Label } from "@/components/ui/label";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import RunScriptModal from "@/components/run-script-modal";
import { useDashboard, SavedView } from "@/app/(dashboard)/dashboard-context";
import { useBranding } from "@/app/providers/BrandingProvider";

const TOP_BAR_HEIGHT = 56;
const PLACEHOLDER_AVATAR = "/avatar-placeholder.png"; // ensure this exists in FE /public

type ToastKind = "success" | "destructive" | "default";
type ToastAction = { label: string; onClick: () => void };
type Toast = { id: string; title: string; desc?: string; kind: ToastKind; action?: ToastAction };

function useToasts() {
    const [toasts, setToasts] = useState<Toast[]>([]);
    const push = (toast: Omit<Toast, "id">) => {
        const id = Math.random().toString(36).slice(2);
        setToasts((t) => [...t, { ...toast, id }]);
        window.setTimeout(() => setToasts((t) => t.filter((x) => x.id !== id)), 4200);
    };
    return { toasts, push };
}

function useMiniRmmStats() {
    const [cpu, setCpu] = useState(18);
    const [ram, setRam] = useState(42);
    useEffect(() => {
        const id = window.setInterval(() => {
            setCpu((c) => Math.max(1, Math.min(99, Math.round(c + (Math.random() * 6 - 3)))));
            setRam((m) => Math.max(1, Math.min(99, Math.round(m + (Math.random() * 6 - 3)))));
        }, 4000);
        return () => clearInterval(id);
    }, []);
    return { cpu, ram };
}

/** Brand logo that respects saved branding (light/dark) */
function AppLogo() {
    const { branding } = useBranding();
    const light = branding?.logoLightUrl ?? undefined;
    const dark = branding?.logoDarkUrl ?? undefined;
    return (
        <div className="flex items-center gap-2">
            <picture>
                {dark ? <source srcSet={dark} media="(prefers-color-scheme: dark)" /> : null}
                <img
                    src={light || dark || "/logo.png"}
                    alt="RemoteIQ"
                    width={28}
                    height={28}
                    className="rounded-sm"
                />
            </picture>
            <span className="font-semibold">RemoteIQ</span>
        </div>
    );
}

function getInitials(name?: string, email?: string) {
    const fromName =
        (name || "")
            .split(" ")
            .map((s) => s.trim()[0])
            .filter(Boolean)
            .slice(0, 2)
            .join("")
            .toUpperCase();
    if (fromName) return fromName;
    const fromEmail = (email || "").trim()[0];
    return (fromEmail || "U").toUpperCase();
}

function normalizeAvatarUrl(raw?: string): string | undefined {
    if (!raw) return undefined;
    const url = raw.trim();
    if (!url) return undefined;
    // Absolute: http(s)://... or data:
    if (/^(https?:)?\/\//i.test(url) || url.startsWith("data:")) return url;
    // Relative to API base
    const base = (process.env.NEXT_PUBLIC_API_BASE || "").replace(/\/+$/, "");
    if (!base) return url; // hope same-origin
    if (url.startsWith("/")) return `${base}${url}`;
    return `${base}/${url}`;
}

type MeProfileResponse = {
    id: string;
    name?: string;
    email?: string;
    avatarUrl?: string;
    avatar_url?: string;
};

export default function TopBar() {
    const pathname = usePathname();
    const isDashboard = pathname === "/" || pathname === "/(dashboard)";
    const isCustomers = pathname.startsWith("/customers");
    const isTickets = pathname.startsWith("/tickets");
    // TODO: wire to real auth/role state
    const isSuperAdmin = true;

    const { setTheme } = useTheme();
    const {
        savedViews,
        saveCurrentView,
        loadView,
        deleteView,
        overwriteViewFromCurrent,
        getEncodedCurrentView,
    } = useDashboard();

    const router = useRouter();
    const searchParams = useSearchParams();

    const [newViewName, setNewViewName] = useState("");
    const [isSaveDialogOpen, setSaveDialogOpen] = useState(false);
    const [nameError, setNameError] = useState<string | null>(null);
    const [viewToDelete, setViewToDelete] = useState<SavedView | null>(null);
    const [viewToOverwrite, setViewToOverwrite] = useState<SavedView | null>(null);

    const [isRunScriptOpen, setRunScriptOpen] = useState(false);
    const [preselectIds, setPreselectIds] = useState<string[] | undefined>(undefined);
    const [automationOpen, setAutomationOpen] = useState(false);

    // NEW: Logout confirm state
    const [logoutOpen, setLogoutOpen] = useState(false);

    const { toasts, push } = useToasts();

    // ---------- CURRENT USER (avatar + initials) ----------
    const [avatarUrl, setAvatarUrl] = useState<string | undefined>(undefined);
    const [avatarErrored, setAvatarErrored] = useState(false);
    const [initials, setInitials] = useState("U");

    useEffect(() => {
        let cancelled = false;
        (async () => {
            try {
                // Pull full profile which contains avatarUrl
                const res = await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/api/users/me`, {
                    credentials: "include",
                });
                if (!res.ok) throw new Error(`Profile fetch failed (${res.status})`);
                const data: MeProfileResponse = await res.json();
                if (cancelled) return;

                const raw = (data as any)?.avatarUrl || (data as any)?.avatar_url || "";
                const normalized = normalizeAvatarUrl(raw);
                setAvatarUrl(normalized);
                setInitials(getInitials(data?.name, data?.email));
            } catch {
                // keep initials-only fallback
            }
        })();
        return () => {
            cancelled = true;
        };
    }, []);

    const setQuery = (key: string, value?: string) => {
        const url = new URL(window.location.href);
        if (!value) url.searchParams.delete(key);
        else url.searchParams.set(key, value);
        router.replace(`${url.pathname}?${url.searchParams.toString()}`);
    };

    // modal open-from-URL guard
    const lastOpenedIdRef = useRef<string | null>(null);
    const openedFromUrlRef = useRef<boolean>(false);
    useEffect(() => {
        const runScriptId = searchParams.get("runScript");
        const deviceId = searchParams.get("device");
        const theId = runScriptId || deviceId;
        if (!theId || isRunScriptOpen || lastOpenedIdRef.current === theId) return;

        lastOpenedIdRef.current = theId;
        openedFromUrlRef.current = true;
        setPreselectIds([theId]);
        setRunScriptOpen(true);
        setAutomationOpen(false);
    }, [searchParams, isRunScriptOpen]);

    const handleRunScriptOpenChange = (open: boolean) => {
        setRunScriptOpen(open);
        if (!open) {
            setPreselectIds(undefined);
            if (openedFromUrlRef.current) {
                openedFromUrlRef.current = false;
                router.back();
            } else {
                setQuery("runScript");
                setQuery("device");
            }
            window.setTimeout(() => {
                lastOpenedIdRef.current = null;
            }, 0);
        }
    };

    // Saved views actions
    const handleSaveView = () => {
        const trimmed = newViewName.trim();
        if (!trimmed) return setNameError("Please enter a name.");
        if (savedViews.some((v) => v.name.toLowerCase() === trimmed.toLowerCase())) {
            return setNameError("A view with this name already exists.");
        }
        saveCurrentView(trimmed);
        push({ title: "Saved view created", desc: `"${trimmed}" was saved.`, kind: "success" });
        setNewViewName("");
        setNameError(null);
        setSaveDialogOpen(false);
    };
    const confirmDelete = () => {
        if (!viewToDelete) return;
        deleteView(viewToDelete.id);
        push({ title: "Saved view deleted", desc: `"${viewToDelete.name}" was removed.`, kind: "destructive" });
        setViewToDelete(null);
    };
    const confirmOverwrite = () => {
        if (!viewToOverwrite) return;
        overwriteViewFromCurrent(viewToOverwrite.id);
        push({ title: "Saved view updated", desc: `"${viewToOverwrite.name}" was overwritten.`, kind: "success" });
        setViewToOverwrite(null);
    };

    const handleCopyViewLink = async () => {
        try {
            const encoded = getEncodedCurrentView({ includeLayouts: true });
            const url = new URL(window.location.href);
            if (encoded) url.searchParams.set("v", encoded);
            else url.searchParams.delete("v");
            const href = url.toString();
            await navigator.clipboard.writeText(href);
            push({
                title: "Link copied",
                desc: "The current view URL is in your clipboard.",
                kind: "success",
                action: { label: "Open", onClick: () => window.open(href, "_blank", "noopener,noreferrer") },
            });
        } catch {
            push({ title: "Copy failed", desc: "Could not write to clipboard.", kind: "destructive" });
        }
    };

    const { cpu, ram } = useMiniRmmStats();

    const handleLogout = async () => {
        try {
            await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/api/auth/logout`, {
                method: "POST",
                credentials: "include",
            });
        } catch {
            // ignore
        }
        router.replace("/login?next=/");
    };

    return (
        <>
            <header
                className="fixed inset-x-0 top-0 z-50 flex h-14 items-center border-b bg-background"
                style={{ height: TOP_BAR_HEIGHT }}
            >
                {/* Left cluster: brand + tabs + automation */}
                <div className="flex items-center gap-2 px-2 sm:px-3">
                    <Link href="/" className="flex items-center gap-2">
                        <AppLogo />
                    </Link>

                    <div className="ml-1 hidden sm:flex items-center">
                        <div className="flex items-center">
                            <Button
                                asChild
                                variant={isDashboard ? "secondary" : "ghost"}
                                size="sm"
                                title="Dashboard"
                                className="rounded-none first:rounded-l-md px-4"
                            >
                                <Link href="/">Dashboard</Link>
                            </Button>
                            <div className="h-6 w-px bg-border self-center" />
                            <Button
                                asChild
                                variant={isCustomers ? "secondary" : "ghost"}
                                size="sm"
                                title="Customers"
                                className="rounded-none last:rounded-r-md px-4"
                            >
                                <Link href="/customers">Customers</Link>
                            </Button>
                            <div className="h-6 w-px bg-border self-center" />
                            <Button
                                asChild
                                variant={isTickets ? "secondary" : "ghost"}
                                size="sm"
                                title="Tickets"
                                className="rounded-none last:rounded-r-md px-4"
                            >
                                <Link href="/tickets">Tickets</Link>
                            </Button>
                        </div>
                    </div>

                    <DropdownMenu open={automationOpen} onOpenChange={setAutomationOpen}>
                        <DropdownMenuTrigger asChild>
                            <Button variant="ghost" size="sm" className="gap-2" title="Open automation tools">
                                Automation
                                <ChevronDown className="h-4 w-4" aria-hidden="true" />
                            </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="start">
                            <DropdownMenuItem
                                onSelect={(e) => {
                                    e.preventDefault();
                                    setAutomationOpen(false);
                                    setPreselectIds(undefined);
                                    setRunScriptOpen(true);
                                    const url = new URL(window.location.href);
                                    url.searchParams.delete("runScript");
                                    url.searchParams.delete("device");
                                    history.replaceState(null, "", url.toString());
                                    openedFromUrlRef.current = false;
                                    lastOpenedIdRef.current = null;
                                }}
                            >
                                <PlaySquare className="mr-2 h-4 w-4" />
                                Run Script
                            </DropdownMenuItem>
                            <DropdownMenuSeparator />
                            <DropdownMenuItem disabled>More tools coming…</DropdownMenuItem>
                        </DropdownMenuContent>
                    </DropdownMenu>
                </div>

                <div className="flex-1" />

                {/* Right cluster — avatar MUST be last */}
                <div className="flex items-center gap-2 pr-2 sm:pr-3">
                    <Button
                        variant="outline"
                        size="sm"
                        className="gap-2"
                        onClick={handleCopyViewLink}
                        title="Copy link to current view"
                    >
                        <LinkIcon className="h-4 w-4" />
                        <span className="hidden sm:inline">Copy View Link</span>
                    </Button>

                    <Dialog open={isSaveDialogOpen} onOpenChange={setSaveDialogOpen}>
                        <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                                <Button variant="outline" size="sm" title="Manage saved views">
                                    <Bookmark className="h-4 w-4 mr-2" />
                                    Saved Views
                                </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end" className="w-64">
                                <DialogTrigger asChild>
                                    <DropdownMenuItem
                                        onSelect={(e) => {
                                            e.preventDefault();
                                            setSaveDialogOpen(true);
                                        }}
                                    >
                                        <PlusCircle className="mr-2 h-4 w-4" />
                                        <span>Save Current View</span>
                                    </DropdownMenuItem>
                                </DialogTrigger>
                                <DropdownMenuSeparator />
                                {savedViews.length === 0 && (
                                    <DropdownMenuItem disabled>No saved views</DropdownMenuItem>
                                )}
                                {savedViews.map((view) => (
                                    <DropdownMenuItem
                                        key={view.id}
                                        onSelect={() => {
                                            const ok = loadView(view.id);
                                            if (ok) {
                                                push({
                                                    title: "Saved view loaded",
                                                    desc: `"${view.name}" applied.`,
                                                    kind: "success",
                                                });
                                            }
                                        }}
                                        className="flex items-center gap-2 py-2"
                                    >
                                        <span className="flex-1 truncate">{view.name}</span>
                                        <Button
                                            variant="warning"
                                            size="icon"
                                            className="h-6 w-6"
                                            title="Overwrite from current"
                                            onClick={(e) => {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                setViewToOverwrite(view);
                                            }}
                                        >
                                            <Save className="h-4 w-4" />
                                        </Button>
                                        <Button
                                            variant="destructive"
                                            size="icon"
                                            className="h-6 w-6"
                                            onClick={(e) => {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                setViewToDelete(view);
                                            }}
                                            aria-label={`Delete ${view.name}`}
                                            title="Delete"
                                        >
                                            <Trash2 className="h-4 w-4" />
                                        </Button>
                                    </DropdownMenuItem>
                                ))}
                            </DropdownMenuContent>
                        </DropdownMenu>

                        {/* Save dialog */}
                        <DialogContent>
                            <form
                                onSubmit={(e) => {
                                    e.preventDefault();
                                    handleSaveView();
                                }}
                            >
                                <DialogHeader>
                                    <DialogTitle>Save New View</DialogTitle>
                                    <DialogDescription>
                                        Saves column visibility, scope, and any active filters/sorting.
                                    </DialogDescription>
                                </DialogHeader>

                                <div className="grid gap-4 py-4">
                                    <div className="grid grid-cols-4 items-center gap-4">
                                        <Label htmlFor="sv-name" className="text-right">
                                            Name
                                        </Label>
                                        <div className="col-span-3">
                                            <Input
                                                id="sv-name"
                                                value={newViewName}
                                                onChange={(e) => {
                                                    setNewViewName(e.target.value);
                                                    setNameError(null);
                                                }}
                                                placeholder="e.g., Global Windows Servers"
                                                autoFocus
                                            />
                                            {nameError && (
                                                <p className="mt-1 text-xs text-destructive">{nameError}</p>
                                            )}
                                        </div>
                                    </div>
                                </div>

                                <DialogFooter>
                                    <Button
                                        type="button"
                                        variant="outline"
                                        onClick={() => setSaveDialogOpen(false)}
                                        title="Cancel"
                                    >
                                        Cancel
                                    </Button>
                                    <Button type="submit" variant="success" title="Save view">
                                        Save
                                    </Button>
                                </DialogFooter>
                            </form>
                        </DialogContent>
                    </Dialog>

                    {/* Search */}
                    <div className="relative hidden md:block">
                        <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
                        <Input
                            type="search"
                            placeholder="Search devices, sites, customers…"
                            className="w-[320px] rounded-lg bg-background pl-8"
                        />
                    </div>

                    {/* Mini CPU/RAM */}
                    <div className="hidden sm:flex items-center gap-2">
                        <Button variant="outline" size="sm" className="gap-2 cursor-default" title="RMM Server CPU">
                            <ActivitySquare className="h-4 w-4" />
                            <span className="tabular-nums">{cpu}%</span>
                        </Button>
                        <Button variant="outline" size="sm" className="gap-2 cursor-default" title="RMM Server RAM">
                            <MemoryStick className="h-4 w-4" />
                            <span className="tabular-nums">{ram}%</span>
                        </Button>
                    </div>

                    {/* Theme */}
                    <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                            <Button variant="outline" size="icon" title="Theme">
                                <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
                                <Moon className="absolute h/[1.2rem] w/[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
                                <span className="sr-only">Toggle theme</span>
                            </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                            <DropdownMenuItem onClick={() => setTheme("light")}>
                                <Sun className="mr-2 h-4 w-4" />
                                Light
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={() => setTheme("dark")}>
                                <Moon className="mr-2 h-4 w-4" />
                                Dark
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={() => setTheme("system")}>
                                <Laptop className="mr-2 h-4 w-4" />
                                System
                            </DropdownMenuItem>
                        </DropdownMenuContent>
                    </DropdownMenu>

                    {/* Notifications */}
                    <Button variant="outline" size="icon" aria-label="Notifications" title="Notifications">
                        <Bell className="h-5 w-5" />
                    </Button>

                    {/* Admin (shield) — only for super admins */}
                    {isSuperAdmin && (
                        <Button asChild variant="outline" size="icon" title="Administration" aria-label="Administration">
                            <Link href="/administration">
                                <Shield className="h-5 w-5" />
                            </Link>
                        </Button>
                    )}

                    {/* Avatar menu — ALWAYS LAST */}
                    <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                            <Button
                                variant="outline"
                                size="icon"
                                title="Account"
                                aria-label="Account"
                                className="rounded-full overflow-hidden"
                            >
                                <Avatar className="h-8 w-8">
                                    <AvatarImage
                                        src={avatarErrored ? PLACEHOLDER_AVATAR : (avatarUrl || PLACEHOLDER_AVATAR)}
                                        alt="User"
                                        onError={() => setAvatarErrored(true)}
                                        referrerPolicy="no-referrer"
                                    />
                                    <AvatarFallback className="text-xs">{initials}</AvatarFallback>
                                </Avatar>
                            </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end" className="w-56">
                            <DropdownMenuItem asChild>
                                <Link href="/account">Account</Link>
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={() => router.push("/account#security")}>
                                Security
                            </DropdownMenuItem>
                            <DropdownMenuSeparator />
                            <DropdownMenuItem
                                onClick={(e) => {
                                    e.preventDefault();
                                    setLogoutOpen(true);
                                }}
                            >
                                Sign out
                            </DropdownMenuItem>
                        </DropdownMenuContent>
                    </DropdownMenu>
                </div>
            </header>

            {/* Overwrite confirm */}
            <AlertDialog open={!!viewToOverwrite} onOpenChange={(o) => !o && setViewToOverwrite(null)}>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Overwrite saved view?</AlertDialogTitle>
                        <AlertDialogDescription>
                            Replace settings of <b>{viewToOverwrite?.name}</b> with your current configuration.
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction
                            className="bg-amber-500 text-white hover:bg-amber-500/90 dark:bg-amber-600 dark:hover:bg-amber-600/90"
                            onClick={confirmOverwrite}
                        >
                            Overwrite
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>

            {/* Delete confirm */}
            <AlertDialog open={!!viewToDelete} onOpenChange={(o) => !o && setViewToDelete(null)}>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Delete saved view?</AlertDialogTitle>
                        <AlertDialogDescription>
                            This will permanently delete <b>{viewToDelete?.name}</b>.
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction
                            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                            onClick={confirmDelete}
                        >
                            Delete
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>

            {/* Sign out confirm (NEW) */}
            <AlertDialog open={logoutOpen} onOpenChange={setLogoutOpen}>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Are you sure?</AlertDialogTitle>
                        <AlertDialogDescription>
                            You’re about to sign out of RemoteIQ.
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction
                            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                            onClick={handleLogout}
                        >
                            Sign out
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>

            {/* Run Script modal */}
            <RunScriptModal
                open={isRunScriptOpen}
                onOpenChange={handleRunScriptOpenChange}
                preselectDeviceIds={preselectIds}
            />

            {/* Toasts */}
            <div className="fixed bottom-4 right-4 z-[100] space-y-2">
                {toasts.map((t) => {
                    const klass =
                        t.kind === "success"
                            ? "border-emerald-200 bg-emerald-50 text-emerald-900 dark:border-emerald-700 dark:bg-emerald-900/20 dark:text-emerald-200"
                            : t.kind === "destructive"
                                ? "border-red-200 bg-red-50 text-red-900 dark:border-red-700 dark:bg-red-900/20 dark:text-red-200"
                                : "border-border bg-card text-card-foreground";
                    return (
                        <div key={t.id} className={`rounded-md border px-4 py-3 shadow-md w-[340px] ${klass}`}>
                            <div className="flex items-start justify-between gap-3">
                                <div>
                                    <div className="text-sm font-medium">{t.title}</div>
                                    {t.desc && <div className="mt-1 text-xs/5 opacity-90">{t.desc}</div>}
                                </div>
                                {t.action && (
                                    <button
                                        className="text-xs underline underline-offset-2 hover:opacity-80"
                                        onClick={t.action.onClick}
                                        title={t.action.label}
                                    >
                                        {t.action.label}
                                    </button>
                                )}
                            </div>
                        </div>
                    );
                })}
            </div>
        </>
    );
}

================================================================================
END FILE: remoteiq-frontend\components\top-bar.tsx
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\app\hooks\useRequireAuth.ts
================================================================================
// app/hooks/useRequireAuth.ts
"use client";
import * as React from "react";
import { usePathname, useRouter } from "next/navigation";

const API_BASE = (process.env.NEXT_PUBLIC_API_BASE || "http://localhost:3001").replace(/\/+$/, "");

type MeResponse =
    | { user: null }
    | {
          user: {
              id: string;
              email: string;
              name: string;
              role: string;
              roleId?: string | null;
              roles?: Array<{ id: string; name: string }>;
          };
      };

export function useRequireAuth() {
    const [loading, setLoading] = React.useState(true);
    const [user, setUser] = React.useState<MeResponse["user"]>(null);
    const router = useRouter();
    const pathname = usePathname();

    React.useEffect(() => {
        let cancelled = false;

        async function run() {
            try {
                const res = await fetch(`${API_BASE}/api/auth/me`, {
                    method: "GET",
                    credentials: "include",
                });
                if (!res.ok) throw new Error(String(res.status));
                const data: MeResponse = await res.json();
                if (!cancelled) {
                    setUser(data.user ?? null);
                    if (!data.user) {
                        const next = encodeURIComponent(pathname || "/");
                        router.replace(`/login?next=${next}`);
                    }
                }
            } catch {
                if (!cancelled) {
                    const next = encodeURIComponent(pathname || "/");
                    router.replace(`/login?next=${next}`);
                }
            } finally {
                if (!cancelled) setLoading(false);
            }
        }

        run();
        return () => { cancelled = true; };
    }, [pathname, router]);

    return { loading, user };
}

================================================================================
END FILE: remoteiq-frontend\app\hooks\useRequireAuth.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\lib\auth.ts
================================================================================
// app/lib/auth.ts
export async function getMe() {
    const res = await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/api/auth/me`, {
        credentials: 'include',
    });
    return res.json() as Promise<{ user: null | { id: string; email: string; name: string; role: string } }>;
}
export async function logout() {
    await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/api/auth/logout`, { method: 'POST', credentials: 'include' });
}

================================================================================
END FILE: remoteiq-frontend\lib\auth.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\lib\account-api.ts
================================================================================
/* lib/account-api.ts — Enhanced mocked account API */

function sleep(ms = 500) { return new Promise((res) => setTimeout(res, ms)); }
function rnd(n = 900000) { return (100000 + Math.floor(Math.random() * n)).toString(); }

/* ===== Profile ===== */
export type Profile = {
  firstName: string; lastName: string; username: string;
  email: string; billingEmail?: string; phone?: string;
  timezone: string; locale: string; avatarUrl?: string;
};

export async function getProfile(): Promise<Profile> {
  await sleep();
  return {
    firstName: "Alex", lastName: "Morgan", username: "alexm",
    email: "alex@example.com", billingEmail: "billing@example.com",
    phone: "", timezone: "UTC", locale: "en-US", avatarUrl: "",
  };
}

export async function checkUsername(username: string): Promise<{ available: boolean }> {
  await sleep(400);
  const taken = new Set(["admin", "root", "support"]);
  const base = username.toLowerCase().replace(/\d+$/g, "");
  return { available: !(taken.has(username.toLowerCase()) || taken.has(base)) };
}
export const checkUsernameAvailable = checkUsername;

export async function updateProfile(payload: Partial<Profile>): Promise<{ ok: true } & Partial<Profile>> {
  await sleep(600);
  return { ok: true, ...payload };
}

/* ===== Security ===== */
export type Security = { twoFaEnabled: boolean; autoRevokeSessions: boolean; };
export async function getSecurity(): Promise<Security> { await sleep(); return { twoFaEnabled: false, autoRevokeSessions: true }; }
export async function updateSecurity(_payload: Partial<Security & { newPassword?: string }>) { await sleep(600); return { ok: true }; }
export async function reauthCheck() { await sleep(400); return { ok: true }; }
export async function registerPasskey() { await sleep(700); return { ok: true, credentialId: `cred_${rnd()}` }; }

/* ===== Sessions ===== */
export type Session = { id: string; device: string; ip: string; lastActive: string; current: boolean; city?: string; isp?: string; trusted?: boolean; label?: string; };
export async function getSessions(): Promise<Session[]> {
  await sleep();
  return [
    { id: "s1", device: "Chrome on Windows", ip: "73.184.10.22", lastActive: "2 minutes ago", current: true, city: "Boston, MA", isp: "Comcast", trusted: true, label: "Work PC" },
    { id: "s2", device: "Safari on iPhone", ip: "73.184.10.22", lastActive: "2 days ago", current: false, city: "Boston, MA", isp: "Comcast", trusted: false },
  ];
}
export async function toggleTrustSession(id: string, trusted: boolean) { await sleep(300); return { ok: true, id, trusted }; }
export async function updateSessionLabel(id: string, label: string) { await sleep(300); return { ok: true, id, label }; }
export async function revokeSession(id: string) { await sleep(400); return { ok: true, id }; }
export async function revokeAll() { await sleep(700); return { ok: true }; }

/* ===== Notifications ===== */
export type Notifications = {
  email: boolean; push: boolean; product: boolean;
  digest: "never" | "daily" | "weekly" | "monthly";
  quiet: { enabled: boolean; start: string; end: string };
  products: string[];
};
export async function getNotifications(): Promise<Notifications> {
  await sleep();
  return { email: true, push: false, product: true, digest: "daily", quiet: { enabled: false, start: "22:00", end: "07:00" }, products: ["RMM Alerts", "Billing"] };
}
export async function updateNotifications(_payload: Partial<Notifications>) { await sleep(600); return { ok: true }; }
export async function sendTestEmail() { await sleep(500); return { ok: true, id: `msg_${rnd()}` }; }

/* ===== Integrations ===== */
export type Integrations = { slackWebhook: string; webhookUrl: string; webhookSigningSecret: string; events: string[]; };
export async function getIntegrations(): Promise<Integrations> {
  await sleep();
  return { slackWebhook: "", webhookUrl: "", webhookSigningSecret: "", events: ["Tickets", "Alerts"] };
}
export async function updateIntegrations(_payload: Partial<Integrations>) { await sleep(600); return { ok: true }; }
export async function testSlackWebhook(_url: string) { await sleep(500); return { ok: true, status: 200, ms: 153 }; }
export async function testGenericWebhook(_url: string) { await sleep(500); return { ok: true, status: 202, ms: 211 }; }
export async function rotateSigningSecret() { await sleep(500); return { secret: `whsec_${rnd(90000000)}` }; }
export async function previewSignature(body: string, secret: string) {
  await sleep(200);
  // mock HMAC preview (NOT real crypto)
  const mock = btoa(`${secret}:${body}`).slice(0, 24);
  return { header: `X-RemoteIQ-Signature: v1=${mock}` };
}

/* ===== Billing ===== */
export type BillingProfile = { company: string; addr1: string; addr2?: string; city: string; country: string; cardLast4: string; taxId?: string; };
export async function getBillingProfile(): Promise<BillingProfile> {
  await sleep();
  return { company: "Acme MSP", addr1: "100 Main St", addr2: "", city: "Springfield", country: "US", cardLast4: "4242", taxId: "" };
}
export async function updateBillingProfile(_payload: Partial<BillingProfile>) { await sleep(600); return { ok: true }; }
export type Invoice = { id: string; date: string; total: number; currency: string; status: string };
export async function listInvoices(): Promise<Invoice[]> {
  await sleep();
  return [
    { id: "inv_1003", date: "2025-10-01", total: 199.00, currency: "USD", status: "Paid" },
    { id: "inv_1002", date: "2025-09-01", total: 199.00, currency: "USD", status: "Paid" },
    { id: "inv_1001", date: "2025-08-01", total: 199.00, currency: "USD", status: "Paid" },
  ];
}
export async function estimateNextInvoice() {
  await sleep(300);
  return { estimate: 219.00, currency: "USD", note: "Proration for +2 seats mid-cycle." };
}

/* ===== API Keys ===== */
export type ApiKey = { id: string; label: string; lastUsed?: string; scopes?: string[]; expiresAt?: string; };
export async function listApiKeys(): Promise<ApiKey[]> {
  await sleep();
  return [{ id: "rk_live_xxx123", label: "Production server", lastUsed: "3 hours ago", scopes: ["read", "write"], expiresAt: "" }];
}
export async function createApiKey(label: string, scopes: string[], expiresIn: "never" | "30d" | "90d", ipAllowlist?: string): Promise<ApiKey> {
  await sleep(500);
  const id = `rk_live_${Math.random().toString(36).slice(2, 10)}`;
  const expiresAt = expiresIn === "never" ? "" : new Date(Date.now() + (expiresIn === "30d" ? 30 : 90) * 24 * 3600 * 1000).toISOString();
  void ipAllowlist;
  return { id, label, scopes, expiresAt };
}
export async function revokeApiKey(id: string) { await sleep(400); return { ok: true, id }; }
export async function regenerateApiKey(id: string) { await sleep(500); return { oldId: id, newKey: `rk_live_${Math.random().toString(36).slice(2, 10)}` }; }
export async function keyUsage(id: string) {
  await sleep(250);
  // mock 7-day request counts
  return { id, last7: Array.from({ length: 7 }, (_, i) => ({ d: i, c: Math.floor(Math.random() * 120) })) };
}

/* ===== Audit ===== */
export type AuditEvent = { id: string; at: string; action: string; details: string };
export async function getAuditEvents(section: string): Promise<AuditEvent[]> {
  await sleep(200);
  const now = Date.now();
  const sample = [
    { action: "Saved", details: `Updated ${section} settings` },
    { action: "Viewed", details: `Opened ${section} tab` },
  ];
  return sample.map((s, i) => ({ id: `${section}_${i}`, at: new Date(now - i * 3600_000).toISOString(), ...s }));
}

================================================================================
END FILE: remoteiq-frontend\lib\account-api.ts
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\app\administration\tabs\RolesTab.tsx
================================================================================
// app/administration/tabs/RolesTab.tsx
"use client";

import * as React from "react";
import { TabsContent } from "@/components/ui/tabs";
import {
    Card,
    CardHeader,
    CardTitle,
    CardDescription,
    CardContent,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
    Select,
    SelectTrigger,
    SelectValue,
    SelectContent,
    SelectItem,
} from "@/components/ui/select";
import {
    DropdownMenu,
    DropdownMenuTrigger,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuShortcut,
} from "@/components/ui/dropdown-menu";
import { Checkbox } from "@/components/ui/checkbox";
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    DialogDescription,
    DialogFooter,
} from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";
import {
    Plus,
    MoreVertical,
    Pencil,
    Copy,
    Download,
    Trash2,
    Layers,
    Check,
    Zap,
    RefreshCw,
    ChevronDown,
} from "lucide-react";
import { useVirtualizer } from "@tanstack/react-virtual";
import ExcelJS from "exceljs";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";

/* ========= Types ========= */
export type Role = {
    id: string;
    name: string;
    description?: string;
    permissions: string[];
    usersCount?: number;
    createdAt?: string;
    updatedAt?: string;
};

type AnyRole = {
    id: string;
    name: string;
    description?: string;
    permissions: string[] | Record<string, boolean>;
    usersCount?: number;
    createdAt?: string;
    updatedAt?: string;
};

export type ToastFn = (t: {
    title: string;
    desc?: string;
    kind: "success" | "warning" | "destructive" | "default";
}) => void;

interface RolesTabProps {
    roles: any[];
    setRoles: React.Dispatch<React.SetStateAction<any[]>>;
    push: ToastFn;
    refetchRoles?: () => Promise<void>;
    setDeleteRoleId?: React.Dispatch<React.SetStateAction<string | null>>;
}

/* ========= Constants / helpers ========= */
const PAGE_SIZES = [10, 25, 50, 100] as const;
const DEFAULT_SORT: Sort = { key: "name", dir: "asc" };
const PROTECTED_NAMES = new Set(["owner", "admin"]);
const PROTECTED_FULL_LOCK = "owner";
const ROW_HEIGHT = 70;

type SortKey = "name" | "usersCount" | "updatedAt";
type SortDir = "asc" | "desc";
type Sort = { key: SortKey; dir: SortDir };

type PermGroup = {
    key: string;
    label: string;
    items: { key: string; label: string }[];
};

const DEFAULT_PERM_GROUPS: PermGroup[] = [
    {
        key: "users",
        label: "Users",
        items: [
            { key: "users.read", label: "View users" },
            { key: "users.write", label: "Create/edit users" },
            { key: "users.delete", label: "Remove users" },
            { key: "users.2fa.reset", label: "Reset 2FA" },
        ],
    },
    {
        key: "roles",
        label: "Roles",
        items: [
            { key: "roles.read", label: "roles.read" },
            { key: "roles.write", label: "roles.write" },
            { key: "roles.delete", label: "roles.delete" },
        ],
    },
    {
        key: "teams",
        label: "Teams",
        items: [
            { key: "teams.read", label: "teams.read" },
            { key: "teams.write", label: "teams.write" },
            { key: "teams.delete", label: "teams.delete" },
        ],
    },
    {
        key: "billing",
        label: "Billing",
        items: [
            { key: "billing.read", label: "billing.read" },
            { key: "billing.write", label: "billing.write" },
        ],
    },
    {
        key: "settings",
        label: "Settings",
        items: [
            { key: "settings.read", label: "settings.read" },
            { key: "settings.write", label: "settings.write" },
        ],
    },
    {
        key: "backups",
        label: "Backups",
        items: [
            { key: "backups.read", label: "View config and history" },
            { key: "backups.run", label: "Run, retry or cancel jobs" },
            { key: "backups.prune", label: "Prune artifacts" },
            { key: "backups.manage", label: "Configure/test destinations" },
            { key: "backups.restore", label: "Restore from backups" },
            { key: "backups.download", label: "Download backups" },
        ],
    },
];

function isProtectedRoleName(name: string) {
    return PROTECTED_NAMES.has(name.trim().toLowerCase());
}
function formatDate(iso?: string) {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleString();
}
function relativeTimeFromNow(iso?: string) {
    if (!iso) return "";
    const now = Date.now();
    const t = Date.parse(iso);
    if (Number.isNaN(t)) return "";
    const diff = Math.max(0, now - t);
    const sec = Math.floor(diff / 1000);
    if (sec < 60) return `${sec}s ago`;
    const min = Math.floor(sec / 60);
    if (min < 60) return `${min}m ago`;
    const hr = Math.floor(min / 60);
    if (hr < 24) return `${hr}h ago`;
    const day = Math.floor(hr / 24);
    if (day < 30) return `${day}d ago`;
    const mo = Math.floor(day / 30);
    if (mo < 12) return `${mo}mo ago`;
    const yr = Math.floor(mo / 12);
    return `${yr}y ago`;
}
function sanitizeForCSVCell(v: string): string {
    if (/^[=+\-@]/.test(v)) return "'" + v;
    return v;
}

/* ========= Permission adapters ========= */
function isPermMap(p: AnyRole["permissions"]): p is Record<string, boolean> {
    return !!p && !Array.isArray(p) && typeof p === "object";
}
function toKeys(p: AnyRole["permissions"]): string[] {
    if (Array.isArray(p)) return p;
    if (!p) return [];
    return Object.entries(p)
        .filter(([, v]) => Boolean(v))
        .map(([k]) => k);
}
function keysToMap(keys: string[]): Record<string, boolean> {
    const out: Record<string, boolean> = {};
    keys.forEach((k) => (out[k] = true));
    return out;
}
function normalizeRole(r: AnyRole): Role {
    return {
        id: r.id,
        name: r.name,
        description: r.description,
        permissions: toKeys(r.permissions),
        usersCount: r.usersCount,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt,
    };
}

/* ========= Export columns ========= */
type ColumnKey =
    | "id"
    | "name"
    | "description"
    | "usersCount"
    | "permissions"
    | "createdAt"
    | "updatedAt";

const COLUMN_LABELS: Record<ColumnKey, string> = {
    id: "ID",
    name: "Name",
    description: "Description",
    usersCount: "Users",
    permissions: "Permissions",
    createdAt: "Created",
    updatedAt: "Updated",
};

const DEFAULT_EXPORT_COLUMNS: ColumnKey[] = [
    "name",
    "description",
    "usersCount",
    "permissions",
    "updatedAt",
];

/* ========= API base ========= */
function getApiBase(): string {
    const raw = (process.env.NEXT_PUBLIC_API_BASE || "").replace(/\/+$/, "");
    if (!raw) return "/api";
    return raw.endsWith("/api") ? raw : `${raw}/api`;
}
const API_BASE = getApiBase();

/* ========= Local API helpers ========= */
async function apiListRoles(): Promise<AnyRole[]> {
    const res = await fetch(`${API_BASE}/roles`, {
        cache: "no-store",
        credentials: "include",
    });
    if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Failed to list roles (${res.status}): ${txt || res.statusText}`);
    }
    return res.json();
}
async function apiCreateRole(payload: {
    name: string;
    description?: string;
    permissions: string[];
}): Promise<{ id: string }> {
    const res = await fetch(`${API_BASE}/roles`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(payload),
    });
    if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Failed to create role (${res.status}): ${txt || res.statusText}`);
    }
    return res.json();
}
async function apiUpdateRole(id: string, patch: Partial<Role>): Promise<void> {
    const res = await fetch(`${API_BASE}/roles/${id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(patch),
    });
    if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Failed to update role (${res.status}): ${txt || res.statusText}`);
    }
}
async function apiDeleteRole(id: string): Promise<void> {
    const res = await fetch(`${API_BASE}/roles/${id}`, {
        method: "DELETE",
        credentials: "include",
    });
    if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Failed to delete role (${res.status}): ${txt || res.statusText}`);
    }
}

async function apiListPermissionGroups(): Promise<PermGroup[]> {
    const res = await fetch(`${API_BASE}/roles/permission-keys`, {
        cache: "no-store",
        credentials: "include",
    });
    if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Failed to load permission catalog (${res.status}): ${txt || res.statusText}`);
    }
    const body = (await res.json().catch(() => ({}))) as { groups?: PermGroup[] };
    if (!Array.isArray(body.groups) || !body.groups.length) {
        return DEFAULT_PERM_GROUPS;
    }
    return body.groups.map((group) => ({
        key: group.key,
        label: group.label,
        items: Array.isArray(group.items)
            ? group.items.map((item) => ({ key: item.key, label: item.label }))
            : [],
    }));
}

/* ========= Component ========= */
export default function RolesTab({
    roles,
    setRoles,
    push,
    refetchRoles,
}: RolesTabProps) {
    const [permissionGroups, setPermissionGroups] = React.useState<PermGroup[]>(DEFAULT_PERM_GROUPS);
    const allPermissionKeys = React.useMemo(
        () => permissionGroups.flatMap((g) => g.items.map((i) => i.key)),
        [permissionGroups]
    );

    // Track whether backend originally returns a map or an array for permissions
    const originalIsMapRef = React.useRef<boolean>(
        roles.length ? isPermMap((roles[0] as AnyRole)?.permissions) : false
    );

    React.useEffect(() => {
        if (roles.length) {
            originalIsMapRef.current = isPermMap((roles[0] as AnyRole)?.permissions);
        }
    }, [roles]);

    const [loading, setLoading] = React.useState(false);

    const refreshFromServer = React.useCallback(
        async (toastOnSuccess = false) => {
            setLoading(true);
            try {
                const fresh = await apiListRoles(); // <- raw
                setRoles(fresh as any[]);
                originalIsMapRef.current = fresh.length
                    ? isPermMap(fresh[0]?.permissions as any)
                    : originalIsMapRef.current;
                if (toastOnSuccess) push({ title: "Roles synced", kind: "success" });
            } catch (e: any) {
                push({
                    title: "Refresh failed",
                    desc: e?.message ?? "Request failed",
                    kind: "destructive",
                });
            } finally {
                setLoading(false);
            }
        },
        [setRoles, push]
    );

    // Optional hydration if parent didn't preload
    React.useEffect(() => {
        if (!roles || roles.length === 0) {
            refreshFromServer(false);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    React.useEffect(() => {
        let cancelled = false;
        (async () => {
            try {
                const groups = await apiListPermissionGroups();
                if (!cancelled && groups.length) {
                    setPermissionGroups(groups);
                }
            } catch (e: any) {
                push({
                    title: "Failed to load permissions",
                    desc: e?.message ?? "Internal server error",
                    kind: "destructive",
                });
            }
        })();
        return () => {
            cancelled = true;
        };
    }, [push]);

    const normalized = React.useMemo<Role[]>(
        () => (roles as AnyRole[]).map(normalizeRole),
        [roles]
    );

    // ---- Toolbar state ----
    const [query, setQuery] = React.useState("");
    const [debounced, setDebounced] = React.useState("");
    React.useEffect(() => {
        const t = setTimeout(() => setDebounced(query.trim().toLowerCase()), 300);
        return () => clearTimeout(t);
    }, [query]);

    const [permFilter, setPermFilter] = React.useState<string>("__all__");
    const [sort, setSort] = React.useState<Sort>(DEFAULT_SORT);
    const [pageSize, setPageSize] =
        React.useState<typeof PAGE_SIZES[number]>(PAGE_SIZES[0]);
    const [page, setPage] = React.useState(1);
    const [virtualize, setVirtualize] = React.useState(false);
    const [selectedIds, setSelectedIds] = React.useState<string[]>([]);

    // Reset page to 1 when core filters change
    React.useEffect(() => {
        setPage(1);
    }, [debounced, permFilter, sort.key, sort.dir]);

    const filtered = React.useMemo(() => {
        let rows = normalized;

        if (debounced) {
            rows = rows.filter((r) => {
                const t = `${r.name} ${r.description ?? ""}`.toLowerCase();
                return t.includes(debounced);
            });
        }

        if (permFilter !== "__all__") {
            rows = rows.filter((r) => r.permissions?.includes(permFilter));
        }

        rows = [...rows].sort((a, b) => {
            const dir = sort.dir === "asc" ? 1 : -1;
            if (sort.key === "name") {
                return a.name.localeCompare(b.name) * dir;
            }
            if (sort.key === "usersCount") {
                const av = a.usersCount ?? 0;
                const bv = b.usersCount ?? 0;
                return (av - bv) * dir;
            }
            const av = a.updatedAt ? Date.parse(a.updatedAt) : 0;
            const bv = b.updatedAt ? Date.parse(b.updatedAt) : 0;
            return (av - bv) * dir;
        });

        return rows;
    }, [normalized, debounced, permFilter, sort]);

    const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
    React.useEffect(() => {
        if (page > totalPages) setPage(totalPages);
    }, [totalPages, page]);

    const paged = React.useMemo(() => {
        if (virtualize) return filtered;
        const start = (page - 1) * pageSize;
        return filtered.slice(start, start + pageSize);
    }, [filtered, virtualize, page, pageSize]);

    const toggleAllVisible = React.useCallback(
        (checked: boolean) => {
            setSelectedIds((prev) => {
                const ids = new Set(prev);
                const rows = paged.map((r) => r.id);
                if (checked) rows.forEach((id) => ids.add(id));
                else rows.forEach((id) => ids.delete(id));
                return [...ids];
            });
        },
        [paged]
    );

    const toggleOne = React.useCallback((id: string, checked: boolean) => {
        setSelectedIds((prev) =>
            checked ? [...new Set([...prev, id])] : prev.filter((x) => x !== id)
        );
    }, []);

    const clearSelection = React.useCallback(() => setSelectedIds([]), []);

    async function safeWriteClipboard(text: string) {
        if (
            typeof navigator !== "undefined" &&
            navigator.clipboard &&
            typeof navigator.clipboard.writeText === "function"
        ) {
            await navigator.clipboard.writeText(text);
            return true;
        }
        return false;
    }

    const onCopyNames = React.useCallback(() => {
        const working = (selectedIds.length
            ? filtered.filter((r) => selectedIds.includes(r.id))
            : filtered
        ).map((r) => r.name);
        if (!working.length) {
            push({ title: "Nothing to copy", kind: "warning" });
            return;
        }
        safeWriteClipboard(working.join("\n")).then((ok) => {
            if (ok) {
                push({
                    title: "Copied role name(s)",
                    desc: `${working.length} copied`,
                    kind: "success",
                });
            } else {
                push({
                    title: "Copy failed",
                    desc: "Clipboard not available",
                    kind: "destructive",
                });
            }
        });
    }, [filtered, selectedIds, push]);

    /* ===== Export ===== */
    const [exportOpen, setExportOpen] = React.useState(false);
    const [exportScope, setExportScope] =
        React.useState<"selected" | "filtered" | "all">("filtered");
    const [exportColumns, setExportColumns] =
        React.useState<ColumnKey[]>(DEFAULT_EXPORT_COLUMNS);
    const [exportFormat, setExportFormat] = React.useState<"xlsx" | "csv">("xlsx");

    const rolesForExport = React.useMemo(() => {
        if (exportScope === "selected" && selectedIds.length) {
            return filtered.filter((r) => selectedIds.includes(r.id));
        }
        if (exportScope === "all") return normalized;
        return filtered;
    }, [exportScope, selectedIds, filtered, normalized]);

    const doExport = React.useCallback(async () => {
        const rows = rolesForExport;
        if (!rows.length) {
            push({ title: "Nothing to export", kind: "warning" });
            return;
        }

        if (exportFormat === "csv") {
            const header = exportColumns.map((c) => COLUMN_LABELS[c]);
            const lines = [header.join(",")];
            for (const r of rows) {
                const vals = exportColumns.map((c) => {
                    let val = "";
                    switch (c) {
                        case "id":
                            val = r.id;
                            break;
                        case "name":
                            val = r.name;
                            break;
                        case "description":
                            val = r.description ?? "";
                            break;
                        case "usersCount":
                            val = String(r.usersCount ?? 0);
                            break;
                        case "permissions":
                            val = (r.permissions ?? []).join("; ");
                            break;
                        case "createdAt":
                            val = r.createdAt ?? "";
                            break;
                        case "updatedAt":
                            val = r.updatedAt ?? "";
                            break;
                    }
                    val = sanitizeForCSVCell(val);
                    if (/[,"\n]/.test(val)) val = '"' + val.replace(/"/g, '""') + '"';
                    return val;
                });
                lines.push(vals.join(","));
            }
            const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `roles_${Date.now()}.csv`;
            a.click();
            URL.revokeObjectURL(a.href);
            push({ title: "CSV exported", kind: "success" });
            setExportOpen(false);
            return;
        }

        // XLSX
        const wb = new ExcelJS.Workbook();
        const ws = wb.addWorksheet("Roles");
        ws.addRow(exportColumns.map((c) => COLUMN_LABELS[c]));
        for (const r of rows) {
            const rowVals = exportColumns.map((c) => {
                switch (c) {
                    case "id":
                        return sanitizeForCSVCell(r.id);
                    case "name":
                        return sanitizeForCSVCell(r.name);
                    case "description":
                        return sanitizeForCSVCell(r.description ?? "");
                    case "usersCount":
                        return r.usersCount ?? 0;
                    case "permissions":
                        return sanitizeForCSVCell((r.permissions ?? []).join("; "));
                    case "createdAt":
                        return r.createdAt ?? "";
                    case "updatedAt":
                        return r.updatedAt ?? "";
                }
            });
            ws.addRow(rowVals as any);
        }
        (ws.columns || []).forEach((col: any) => {
            let max = 10;
            if (col?.eachCell) {
                col.eachCell((cell: any) => {
                    const len = String(cell?.value ?? "").length;
                    if (len > max) max = len;
                });
            }
            col.width = Math.min(60, Math.max(10, max + 2));
        });
        const buf = await wb.xlsx.writeBuffer();
        const blob = new Blob([buf], {
            type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `roles_${Date.now()}.xlsx`;
        a.click();
        URL.revokeObjectURL(a.href);
        push({ title: "XLSX exported", kind: "success" });
        setExportOpen(false);
    }, [rolesForExport, exportFormat, exportColumns, push]);

    /* ===== Create/Edit/Delete ===== */
    const [editOpen, setEditOpen] = React.useState(false);
    const [editingRole, setEditingRole] = React.useState<Role | null>(null);

    const openCreate = React.useCallback(() => {
        setEditingRole({
            id: "",
            name: "",
            description: "",
            permissions: [],
        });
        setEditOpen(true);
    }, []);

    const openEdit = React.useCallback((r: Role) => {
        setEditingRole({ ...r });
        setEditOpen(true);
    }, []);

    const openDuplicate = React.useCallback((r: Role) => {
        setEditingRole({
            id: "",
            name: `${r.name} (copy)`,
            description: r.description ?? "",
            permissions: [...(r.permissions ?? [])],
        });
        setEditOpen(true);
    }, []);

    const nameIsUnique = React.useCallback(
        (name: string, excludingId?: string) => {
            const lowered = name.trim().toLowerCase();
            return !normalized.some(
                (r) => r.id !== excludingId && r.name.trim().toLowerCase() === lowered
            );
        },
        [normalized]
    );

    const submitEdit = React.useCallback(async () => {
        if (!editingRole) return;
        const { id, name, description, permissions } = editingRole;
        const trimmed = name.trim();
        const lowered = trimmed.toLowerCase();

        // prevent creating a new protected role
        if (!id && PROTECTED_NAMES.has(lowered)) {
            push({
                title: "Protected role name",
                desc: `"${trimmed}" is reserved and cannot be created`,
                kind: "warning",
            });
            return;
        }

        if (trimmed.length < 2 || trimmed.length > 64) {
            push({
                title: "Invalid name",
                desc: "Name must be 2–64 characters",
                kind: "warning",
            });
            return;
        }

        if (!nameIsUnique(trimmed, id || undefined)) {
            push({
                title: "Duplicate name",
                desc: "Role name must be unique (case-insensitive)",
                kind: "warning",
            });
            return;
        }

        // Build payload. For protected system roles, DO NOT send `name` at all.
        const isProtectedExisting = Boolean(id) && PROTECTED_NAMES.has(lowered);
        const payload: Partial<Role> = {
            // name only if not protected
            ...(isProtectedExisting ? {} : { name: trimmed }),
            description: (description ?? "").trim() || undefined,
            permissions: permissions ?? [],
        };

        if (!id) {
            // optimistic create
            const optimisticId = `tmp_${Math.random().toString(36).slice(2)}`;
            const optimistic: Role = {
                id: optimisticId,
                name: trimmed,
                description: payload.description,
                permissions: payload.permissions as string[],
                usersCount: 0,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
            };
            setRoles((prev) => {
                const backModeIsMap = originalIsMapRef.current;
                const out = backModeIsMap
                    ? { ...optimistic, permissions: keysToMap(optimistic.permissions) }
                    : { ...optimistic };
                return [out as any, ...prev];
            });
            setEditOpen(false);

            try {
                await apiCreateRole({
                    name: trimmed,
                    description: payload.description,
                    permissions: (payload.permissions as string[]) ?? [],
                });
                await refreshFromServer(true);
            } catch (e: any) {
                setRoles((prev) =>
                    prev.filter(
                        (r) => normalizeRole(r as unknown as AnyRole).id !== optimisticId
                    )
                );
                push({
                    title: "Create failed",
                    desc: e?.message ?? "Request failed",
                    kind: "destructive",
                });
            }
            return;
        }

        // editing existing
        const before = roles;
        const updated: Role = {
            ...editingRole,
            // only change name locally if not protected
            name: isProtectedExisting ? editingRole.name : trimmed,
            description: payload.description,
            permissions: (payload.permissions as string[]) ?? [],
            updatedAt: new Date().toISOString(),
        };

        setRoles((prev) =>
            prev.map((r) => {
                const n = normalizeRole(r as unknown as AnyRole);
                if (n.id !== id) return r;
                const out = originalIsMapRef.current
                    ? { ...updated, permissions: keysToMap(updated.permissions) }
                    : updated;
                return out as any;
            })
        );
        setEditOpen(false);

        try {
            await apiUpdateRole(id, payload);
            await refreshFromServer(false);
            push({ title: "Role updated", kind: "success" });
        } catch (e: any) {
            setRoles(before);
            push({
                title: "Update failed",
                desc: e?.message ?? "Request failed",
                kind: "destructive",
            });
        }
    }, [editingRole, nameIsUnique, push, roles, setRoles, refreshFromServer]);


    const [confirmDelete, setConfirmDelete] = React.useState<{
        open: boolean;
        ids: string[];
    }>({
        open: false,
        ids: [],
    });

    const attemptDeleteOne = React.useCallback(
        (r: Role) => {
            if (isProtectedRoleName(r.name)) {
                push({
                    title: "Protected role",
                    desc: "Owner/Admin cannot be deleted",
                    kind: "warning",
                });
                return;
            }
            if ((r.usersCount ?? 0) > 0) {
                push({
                    title: "Role in use",
                    desc: "Reassign users before deleting this role",
                    kind: "warning",
                });
                return;
            }
            setConfirmDelete({ open: true, ids: [r.id] });
        },
        [push]
    );

    const attemptBulkDelete = React.useCallback(() => {
        if (!selectedIds.length) return;
        const blocked: { name: string; reason: string }[] = [];
        const deletable: Role[] = [];
        for (const r of filtered) {
            if (!selectedIds.includes(r.id)) continue;
            if (isProtectedRoleName(r.name)) {
                blocked.push({ name: r.name, reason: "protected role" });
                continue;
            }
            if ((r.usersCount ?? 0) > 0) {
                blocked.push({ name: r.name, reason: "users assigned" });
                continue;
            }
            deletable.push(r);
        }
        if (blocked.length) {
            push({
                title: "Some roles cannot be deleted",
                desc:
                    blocked
                        .slice(0, 4)
                        .map((b) => `${b.name}: ${b.reason}`)
                        .join("; ") + (blocked.length > 4 ? "…" : ""),
                kind: "warning",
            });
        }
        if (!deletable.length) return;
        setConfirmDelete({ open: true, ids: deletable.map((r) => r.id) });
    }, [filtered, selectedIds, push]);

    const confirmPerformDelete = React.useCallback(async () => {
        const ids = confirmDelete.ids;
        setConfirmDelete({ open: false, ids: [] });
        if (!ids.length) return;

        const before = roles;
        setRoles((prev) =>
            prev.filter((r) => !ids.includes(normalizeRole(r as unknown as AnyRole).id))
        );

        try {
            for (const id of ids) {
                await apiDeleteRole(id);
            }
            await refreshFromServer(false);
            push({ title: ids.length > 1 ? "Roles deleted" : "Role deleted", kind: "success" });
        } catch (e: any) {
            setRoles(before);
            push({
                title: "Delete failed",
                desc: e?.message ?? "Request failed",
                kind: "destructive",
            });
        } finally {
            clearSelection();
            if (typeof refetchRoles === "function") {
                try {
                    await refetchRoles();
                } catch {
                    /* ignore */
                }
            }
        }
    }, [confirmDelete.ids, roles, setRoles, push, clearSelection, refetchRoles, refreshFromServer]);

    /* ===== Virtualization ===== */
    const parentRef = React.useRef<HTMLDivElement | null>(null);
    const rowVirtualizer = useVirtualizer({
        count: virtualize ? filtered.length : 0,
        getScrollElement: () => parentRef.current,
        estimateSize: () => ROW_HEIGHT,
        overscan: 10,
    });

    /* ===== Small helpers for display ===== */
    function permissionsPreview(perms: string[] = [], take = 3) {
        const list = perms.slice(0, take);
        const rest = Math.max(0, perms.length - list.length);
        const txt = list.join(", ") + (rest > 0 ? `, +${rest} more` : "");
        return { text: txt, title: perms.join(", ") };
    }

    /* ===== Render ===== */
    return (
        <TabsContent value="roles" className="mt-0">
            <Card>
                <CardHeader className="gap-2">
                    <div className="flex items-center justify-between">
                        <div>
                            <CardTitle>Roles</CardTitle>
                            <CardDescription>
                                Define access levels and permissions. Protected examples: Owner / Admin (cannot be deleted).
                            </CardDescription>
                        </div>
                        <div className="flex items-center gap-2">
                            <Button
                                variant="outline"
                                size="sm"
                                onClick={() => setExportOpen(true)}
                                aria-label="Export roles"
                                title="Export…"
                            >
                                <Download className="h-4 w-4 mr-2" />
                                Export…
                            </Button>
                            <Button
                                variant="outline"
                                size="sm"
                                onClick={onCopyNames}
                                aria-label="Copy role names"
                                title="Copy role names"
                            >
                                <Copy className="h-4 w-4 mr-2" />
                                Copy names
                            </Button>
                            <Button
                                variant="outline"
                                size="sm"
                                onClick={() => refreshFromServer(true)}
                                disabled={loading}
                                aria-label="Sync"
                                title="Sync with server"
                            >
                                <RefreshCw className={cn("h-4 w-4 mr-2", loading && "animate-spin")} />
                                Sync
                            </Button>
                            <Button size="sm" onClick={openCreate} aria-label="Create role">
                                <Plus className="h-4 w-4 mr-2" />
                                New role
                            </Button>
                        </div>
                    </div>
                </CardHeader>

                <CardContent className="space-y-3">
                    {/* Toolbar */}
                    <div className="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
                        <div className="flex items-center gap-2">
                            <Input
                                value={query}
                                onChange={(e) => setQuery(e.target.value)}
                                placeholder="Search roles…"
                                className="w-[260px]"
                                aria-label="Search roles"
                            />
                            <Select value={permFilter} onValueChange={(v) => setPermFilter(v)}>
                                <SelectTrigger className="w-[260px]" aria-label="Filter by permission">
                                    <SelectValue placeholder="Filter by permission" />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="__all__">All permissions</SelectItem>
                                    {allPermissionKeys.map((p) => (
                                        <SelectItem key={p} value={p}>
                                            {p}
                                        </SelectItem>
                                    ))}
                                </SelectContent>
                            </Select>
                        </div>

                        <div className="flex items-center gap-2 whitespace-nowrap">
                            {/* Sort */}
                            <Select
                                value={`${sort.key}:${sort.dir}`}
                                onValueChange={(v) => {
                                    const [key, dir] = v.split(":") as [SortKey, SortDir];
                                    setSort({ key, dir });
                                }}
                            >
                                <SelectTrigger
                                    className="h-9 w-[140px] sm:w-[160px] md:w-[180px] min-w-0"
                                    aria-label="Sort roles"
                                >
                                    <SelectValue className="truncate" />
                                </SelectTrigger>
                                <SelectContent>
                                    <DropdownMenuLabel className="px-2 py-1.5 text-xs text-muted-foreground">
                                        Sort by
                                    </DropdownMenuLabel>
                                    <SelectItem value="name:asc">Name (A→Z)</SelectItem>
                                    <SelectItem value="name:desc">Name (Z→A)</SelectItem>
                                    <SelectItem value="usersCount:asc">Users (fewest)</SelectItem>
                                    <SelectItem value="usersCount:desc">Users (most)</SelectItem>
                                    <SelectItem value="updatedAt:desc">Updated (newest)</SelectItem>
                                    <SelectItem value="updatedAt:asc">Updated (oldest)</SelectItem>
                                </SelectContent>
                            </Select>

                            {/* Pagination size */}
                            {!virtualize && (
                                <Select
                                    value={String(pageSize)}
                                    onValueChange={(v) => setPageSize(Number(v) as any)}
                                >
                                    <SelectTrigger className="w-[120px]" aria-label="Rows per page">
                                        <SelectValue placeholder="Rows" />
                                    </SelectTrigger>
                                    <SelectContent>
                                        {PAGE_SIZES.map((n) => (
                                            <SelectItem key={n} value={String(n)}>
                                                {n} / page
                                            </SelectItem>
                                        ))}
                                    </SelectContent>
                                </Select>
                            )}

                            {/* Virtualize toggle */}
                            <Button
                                variant={virtualize ? "default" : "outline"}
                                size="sm"
                                onClick={() => setVirtualize((v) => !v)}
                                aria-pressed={virtualize}
                                title="Toggle virtualization"
                            >
                                <Zap className="h-4 w-4 mr-2" />
                                {virtualize ? "Virtualized" : "Virtualize"}
                            </Button>
                        </div>
                    </div>

                    {/* Bulk bar */}
                    {selectedIds.length > 0 && (
                        <div className="flex items-center justify-between rounded-md border px-3 py-2">
                            <div className="text-sm">
                                <strong>{selectedIds.length}</strong> selected
                            </div>
                            <div className="flex items-center gap-2">
                                <Button
                                    variant="destructive"
                                    size="sm"
                                    onClick={attemptBulkDelete}
                                    aria-label="Bulk delete roles"
                                    title="Bulk delete"
                                >
                                    <Trash2 className="h-4 w-4 mr-2" />
                                    Delete
                                </Button>
                                <Button variant="outline" size="sm" onClick={clearSelection} aria-label="Clear selection">
                                    Clear
                                </Button>
                            </div>
                        </div>
                    )}

                    {/* Table */}
                    <div className="rounded-md border">
                        {/* header */}
                        <div className="grid grid-cols-[40px_1fr_120px_220px_56px] items-center gap-2 border-b px-3 py-2 text-xs font-semibold text-muted-foreground">
                            <div className="flex items-center justify-center">
                                <Checkbox
                                    aria-label="Select all on page"
                                    checked={paged.length > 0 && paged.every((r) => selectedIds.includes(r.id))}
                                    onCheckedChange={(v) => toggleAllVisible(Boolean(v))}
                                />
                            </div>
                            <div>Name</div>
                            <div className="text-right pr-2">Users</div>
                            <div>Updated</div>
                            <div className="text-right">Actions</div>
                        </div>

                        {/* body */}
                        {virtualize ? (
                            <div
                                ref={parentRef}
                                className="h-[520px] overflow-auto"
                                role="table"
                                aria-label="Roles table virtualized"
                            >
                                <div style={{ height: rowVirtualizer.getTotalSize() }} className="relative">
                                    {rowVirtualizer.getVirtualItems().map((vi) => {
                                        const r = filtered[vi.index];
                                        const isSelected = selectedIds.includes(r.id);
                                        const pv = permissionsPreview(r.permissions, 3);
                                        return (
                                            <div
                                                key={r.id}
                                                className={cn(
                                                    "absolute left-0 right-0 grid grid-cols-[40px_1fr_120px_180px_56px] items-center gap-2 border-b px-3 h-[60px]",
                                                    isSelected && "bg-primary/5"
                                                )}
                                                style={{ transform: `translateY(${vi.start}px)`, height: ROW_HEIGHT }}
                                            >
                                                <div className="flex items-center justify-center">
                                                    <Checkbox
                                                        checked={isSelected}
                                                        onCheckedChange={(v) => toggleOne(r.id, Boolean(v))}
                                                        aria-label={`Select ${r.name}`}
                                                    />
                                                </div>

                                                <div className="min-w-0">
                                                    <div className="flex items-center gap-2">
                                                        <span className="truncate font-medium">{r.name}</span>
                                                        {isProtectedRoleName(r.name) && (
                                                            <Badge variant="secondary" title="System role">
                                                                System
                                                            </Badge>
                                                        )}
                                                        <Badge variant="outline" title={r.permissions.join(", ")}>
                                                            {r.permissions.length} perms
                                                        </Badge>
                                                    </div>
                                                    {r.description && (
                                                        <div className="truncate text-xs text-muted-foreground">
                                                            {r.description}
                                                        </div>
                                                    )}
                                                    {r.permissions?.length > 0 && (
                                                        <div className="truncate text-[11px] text-muted-foreground" title={pv.title}>
                                                            {pv.text}
                                                        </div>
                                                    )}
                                                </div>

                                                <div className="text-right pr-2">{r.usersCount ?? 0}</div>

                                                <div className="truncate text-sm" title={r.updatedAt ?? ""}>
                                                    {relativeTimeFromNow(r.updatedAt) || formatDate(r.updatedAt)}
                                                </div>

                                                <div className="flex items-center justify-end">
                                                    <RowActions
                                                        role={r}
                                                        onEdit={() => openEdit(r)}
                                                        onDuplicate={() => openDuplicate(r)}
                                                        onDelete={() => attemptDeleteOne(r)}
                                                    />
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        ) : (
                            <>
                                {paged.map((r) => {
                                    const isSelected = selectedIds.includes(r.id);
                                    const pv = permissionsPreview(r.permissions, 3);
                                    return (
                                        <div
                                            key={r.id}
                                            className={cn(
                                                "grid grid-cols-[40px_1fr_120px_180px_56px] items-center gap-2 border-b px-3 h-[60px]",
                                                isSelected && "bg-primary/5"
                                            )}
                                            style={{ height: ROW_HEIGHT }}
                                        >
                                            <div className="flex items-center justify-center">
                                                <Checkbox
                                                    checked={isSelected}
                                                    onCheckedChange={(v) => toggleOne(r.id, Boolean(v))}
                                                    aria-label={`Select ${r.name}`}
                                                />
                                            </div>

                                            <div className="min-w-0">
                                                <div className="flex items-center gap-2">
                                                    <span className="truncate font-medium">{r.name}</span>
                                                    {isProtectedRoleName(r.name) && (
                                                        <Badge variant="secondary" title="System role">
                                                            System
                                                        </Badge>
                                                    )}
                                                    <Badge variant="outline" title={r.permissions.join(", ")}>
                                                        {r.permissions.length} perms
                                                    </Badge>
                                                </div>
                                                {r.description && (
                                                    <div className="truncate text-xs text-muted-foreground">
                                                        {r.description}
                                                    </div>
                                                )}
                                                {r.permissions?.length > 0 && (
                                                    <div className="truncate text-[11px] text-muted-foreground" title={pv.title}>
                                                        {pv.text}
                                                    </div>
                                                )}
                                            </div>

                                            <div className="text-right pr-2">{r.usersCount ?? 0}</div>

                                            <div className="truncate text-sm" title={r.updatedAt ?? ""}>
                                                {relativeTimeFromNow(r.updatedAt) || formatDate(r.updatedAt)}
                                            </div>

                                            <div className="flex items-center justify-end">
                                                <RowActions
                                                    role={r}
                                                    onEdit={() => openEdit(r)}
                                                    onDuplicate={() => openDuplicate(r)}
                                                    onDelete={() => attemptDeleteOne(r)}
                                                />
                                            </div>
                                        </div>
                                    );
                                })}

                                {/* pager */}
                                <div className="flex items-center justify-between px-3 py-2">
                                    <div className="text-xs text-muted-foreground">
                                        {filtered.length} role(s)
                                        {filtered.length !== normalized.length && ` • filtered from ${normalized.length}`}
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <Button
                                            variant="outline"
                                            size="sm"
                                            disabled={page <= 1}
                                            onClick={() => setPage((p) => Math.max(1, p - 1))}
                                        >
                                            Prev
                                        </Button>
                                        <div className="text-sm">
                                            Page {page} / {totalPages}
                                        </div>
                                        <Button
                                            variant="outline"
                                            size="sm"
                                            disabled={page >= totalPages}
                                            onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                                        >
                                            Next
                                        </Button>
                                    </div>
                                </div>
                            </>
                        )}
                    </div>

                    {/* subtle loading indicator */}
                    {loading && (
                        <div className="text-xs text-muted-foreground flex items-center gap-2 pl-1">
                            <RefreshCw className="h-3.5 w-3.5 animate-spin" />
                            Syncing…
                        </div>
                    )}
                </CardContent>
            </Card>

            {/* Create/Edit Role Dialog — redesigned for better fit */}
            <Dialog open={editOpen} onOpenChange={(v) => setEditOpen(v)}>
                <DialogContent
                    // Wider but clamped; internal scroll area handles height
                    className={cn(
                        "w-[min(100vw-2rem,1100px)] max-w-none p-0 overflow-hidden"
                    )}
                >
                    <DialogHeader className="sticky top-0 z-10 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b px-6 py-4">
                        <DialogTitle>{editingRole?.id ? "Edit role" : "New role"}</DialogTitle>
                        <DialogDescription>
                            {editingRole?.id
                                ? "Update the role name, description and permissions."
                                : "Create a new role with the permissions you choose."}
                        </DialogDescription>
                    </DialogHeader>

                    {editingRole && (
                        <>
                            {/* Scroll body */}
                            <div className="max-h-[75vh] overflow-auto px-6 py-4">
                                <div className="grid gap-3 md:grid-cols-2">
                                    <div className="grid gap-1">
                                        <label className="text-sm">Name</label>
                                        <Input
                                            value={editingRole.name}
                                            onChange={(e) =>
                                                setEditingRole((prev) => (prev ? { ...prev, name: e.target.value } : prev))
                                            }
                                            placeholder="e.g. Support Agent"
                                            aria-label="Role name"
                                            disabled={
                                                Boolean(editingRole.id) &&
                                                editingRole.name.trim().toLowerCase() === PROTECTED_FULL_LOCK
                                            }
                                        />
                                    </div>
                                    <div className="grid gap-1">
                                        <label className="text-sm">Description (optional)</label>
                                        <Input
                                            value={editingRole.description ?? ""}
                                            onChange={(e) =>
                                                setEditingRole((prev) =>
                                                    prev ? { ...prev, description: e.target.value } : prev
                                                )
                                            }
                                            placeholder="Short description"
                                            aria-label="Role description"
                                        />
                                    </div>
                                </div>

                                {/* Permission checklist (accordion/compact) */}
                                <div className="rounded-md border mt-3">
                                    <div className="flex items-center justify-between px-3 py-2 border-b">
                                        <div className="font-medium text-sm">Permissions</div>
                                        <div className="flex items-center gap-2">
                                            <Button
                                                size="sm"
                                                variant="outline"
                                                onClick={() =>
                                                    setEditingRole((prev) =>
                                                        prev ? { ...prev, permissions: [...allPermissionKeys] } : prev
                                                    )
                                                }
                                                aria-label="Check all permissions"
                                                title="Grant all permissions"
                                            >
                                                <Check className="h-4 w-4 mr-2" />
                                                All permissions
                                            </Button>
                                            <Button
                                                size="sm"
                                                variant="outline"
                                                onClick={() =>
                                                    setEditingRole((prev) => (prev ? { ...prev, permissions: [] } : prev))
                                                }
                                                aria-label="Uncheck all permissions"
                                                title="Revoke all"
                                            >
                                                Clear
                                            </Button>
                                        </div>
                                    </div>

                                    <div className="p-2 sm:p-3 space-y-2">
                                        {permissionGroups.map((group) => {
                                            const groupKeys = group.items.map((i) => i.key);
                                            const hasAll =
                                                editingRole.permissions &&
                                                groupKeys.every((k) => (editingRole.permissions ?? []).includes(k));
                                            const hasSome =
                                                editingRole.permissions &&
                                                groupKeys.some((k) => (editingRole.permissions ?? []).includes(k));

                                            return (
                                                <details
                                                    key={group.key}
                                                    className="rounded-md border"
                                                    open
                                                >
                                                    <summary className="flex items-center justify-between cursor-pointer list-none px-3 py-2 select-none">
                                                        <div className="flex items-center gap-2">
                                                            <ChevronDown className="h-4 w-4 transition-transform data-[state=open]:rotate-180" />
                                                            <span className="font-medium">{group.label}</span>
                                                            <span className="text-xs text-muted-foreground">
                                                                {hasAll ? "All" : hasSome ? "Partial" : "None"}
                                                            </span>
                                                        </div>
                                                        <div className="flex items-center gap-2">
                                                            <Button
                                                                size="sm"
                                                                variant="outline"
                                                                onClick={(e) => {
                                                                    e.preventDefault();
                                                                    setEditingRole((prev) => {
                                                                        if (!prev) return prev;
                                                                        const next = new Set(prev.permissions ?? []);
                                                                        groupKeys.forEach((k) => next.add(k));
                                                                        return { ...prev, permissions: [...next] };
                                                                    });
                                                                }}
                                                                aria-label={`Grant all ${group.label}`}
                                                                title={`Grant all ${group.label}`}
                                                            >
                                                                <Layers className="h-4 w-4 mr-2" />
                                                                Check all
                                                            </Button>
                                                            <Button
                                                                size="sm"
                                                                variant="outline"
                                                                onClick={(e) => {
                                                                    e.preventDefault();
                                                                    setEditingRole((prev) => {
                                                                        if (!prev) return prev;
                                                                        const next = new Set(prev.permissions ?? []);
                                                                        groupKeys.forEach((k) => next.delete(k));
                                                                        return { ...prev, permissions: [...next] };
                                                                    });
                                                                }}
                                                                aria-label={`Revoke all ${group.label}`}
                                                                title={`Revoke all ${group.label}`}
                                                            >
                                                                Clear
                                                            </Button>
                                                        </div>
                                                    </summary>

                                                    <div className="px-3 pb-3">
                                                        <div className="grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
                                                            {group.items.map((p) => {
                                                                const checked = editingRole.permissions?.includes(p.key) ?? false;
                                                                return (
                                                                    <label
                                                                        key={p.key}
                                                                        className="flex items-center justify-between gap-3 rounded-md border px-3 py-2"
                                                                    >
                                                                        <div className="text-sm">{p.label}</div>
                                                                        <Checkbox
                                                                            checked={checked}
                                                                            onCheckedChange={(v) =>
                                                                                setEditingRole((prev) => {
                                                                                    if (!prev) return prev;
                                                                                    const next = new Set(prev.permissions ?? []);
                                                                                    v ? next.add(p.key) : next.delete(p.key);
                                                                                    return { ...prev, permissions: [...next] };
                                                                                })
                                                                            }
                                                                            aria-label={p.label}
                                                                        />
                                                                    </label>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                </details>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                            {/* Sticky footer */}
                            <DialogFooter className="sticky bottom-0 z-10 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-t px-6 py-4">
                                <Button variant="outline" onClick={() => setEditOpen(false)}>
                                    Cancel
                                </Button>
                                <Button onClick={submitEdit}>
                                    {editingRole?.id ? "Save changes" : "Create role"}
                                </Button>
                            </DialogFooter>
                        </>
                    )}
                </DialogContent>
            </Dialog>

            {/* Delete Confirm */}
            <Dialog
                open={confirmDelete.open}
                onOpenChange={(open) => setConfirmDelete((prev) => ({ ...prev, open }))}
            >
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Delete {confirmDelete.ids.length > 1 ? "roles" : "role"}?</DialogTitle>
                        <DialogDescription className="text-red-600 dark:text-red-400">
                            This action cannot be undone.
                        </DialogDescription>
                    </DialogHeader>
                    <div className="text-sm">
                        Deleting a role will remove it permanently. Roles in use or protected roles cannot be deleted.
                    </div>
                    <DialogFooter className="mt-4">
                        <Button variant="outline" onClick={() => setConfirmDelete({ open: false, ids: [] })}>
                            Cancel
                        </Button>
                        <Button variant="destructive" onClick={confirmPerformDelete}>
                            Delete
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            {/* Export dialog (unchanged) */}
            <Dialog open={exportOpen} onOpenChange={(v) => setExportOpen(v)}>
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Export roles</DialogTitle>
                    </DialogHeader>

                    <div className="space-y-4">
                        {/* Scope (radio) */}
                        <div className="rounded-md border p-3">
                            <div className="font-medium mb-2 text-sm">Scope</div>
                            <RadioGroup
                                value={exportScope}
                                onValueChange={(v: "selected" | "filtered" | "all") => setExportScope(v)}
                                className="grid gap-2 sm:grid-cols-3"
                            >
                                {(["selected", "filtered", "all"] as const).map((s) => (
                                    <label
                                        key={s}
                                        className={cn(
                                            "flex items-center justify-between gap-2 rounded-md border px-3 py-2 text-sm",
                                            exportScope === s && "border-primary"
                                        )}
                                    >
                                        <span className="capitalize">{s}</span>
                                        <RadioGroupItem value={s} aria-label={`Export scope ${s}`} />
                                    </label>
                                ))}
                            </RadioGroup>
                        </div>

                        {/* Columns (checkboxes) */}
                        <div className="rounded-md border p-3">
                            <div className="font-medium mb-2 text-sm">Columns</div>
                            <div className="grid gap-2 sm:grid-cols-2">
                                {(Object.keys(COLUMN_LABELS) as ColumnKey[]).map((k) => (
                                    <label
                                        key={k}
                                        className="flex items-center justify-between gap-2 rounded-md border px-3 py-2 text-sm"
                                    >
                                        <span>{COLUMN_LABELS[k]}</span>
                                        <Checkbox
                                            checked={exportColumns.includes(k)}
                                            onCheckedChange={(v) =>
                                                setExportColumns((prev) => {
                                                    const set = new Set(prev);
                                                    v ? set.add(k) : set.delete(k);
                                                    return [...set];
                                                })
                                            }
                                            aria-label={`Column ${COLUMN_LABELS[k]}`}
                                        />
                                    </label>
                                ))}
                            </div>
                        </div>

                        {/* Format (radio) */}
                        <div className="rounded-md border p-3">
                            <div className="font-medium mb-2 text-sm">Format</div>
                            <RadioGroup
                                value={exportFormat}
                                onValueChange={(v: "xlsx" | "csv") => setExportFormat(v)}
                                className="grid gap-2 sm:grid-cols-2"
                            >
                                {(["xlsx", "csv"] as const).map((fmt) => (
                                    <label
                                        key={fmt}
                                        className={cn(
                                            "flex items-center justify-between gap-2 rounded-md border px-3 py-2 text-sm",
                                            exportFormat === fmt && "border-primary"
                                        )}
                                    >
                                        <span className="uppercase">{fmt}</span>
                                        <RadioGroupItem value={fmt} aria-label={`Format ${fmt}`} />
                                    </label>
                                ))}
                            </RadioGroup>
                        </div>
                    </div>

                    <DialogFooter className="mt-4">
                        <Button variant="outline" onClick={() => setExportOpen(false)}>
                            Cancel
                        </Button>
                        <Button onClick={doExport}>
                            <Download className="h-4 w-4 mr-2" />
                            Export
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </TabsContent>
    );
}

/* ========= Row actions ========= */
function RowActions({
    role,
    onEdit,
    onDuplicate,
    onDelete,
}: {
    role: Role;
    onEdit: () => void;
    onDuplicate: () => void;
    onDelete: () => void;
}) {
    const deletable = !isProtectedRoleName(role.name) && (role.usersCount ?? 0) === 0;

    return (
        <DropdownMenu>
            <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" aria-label="Open actions">
                    <MoreVertical className="h-4 w-4" />
                </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-44">
                <DropdownMenuLabel>Actions</DropdownMenuLabel>
                <DropdownMenuItem onClick={onEdit}>
                    <Pencil className="mr-2 h-4 w-4" />
                    Edit
                    <DropdownMenuShortcut>E</DropdownMenuShortcut>
                </DropdownMenuItem>
                <DropdownMenuItem onClick={onDuplicate}>
                    <Copy className="mr-2 h-4 w-4" />
                    Duplicate
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                <DropdownMenuItem
                    disabled={!deletable}
                    onClick={deletable ? onDelete : undefined}
                    title={
                        deletable
                            ? "Delete role"
                            : isProtectedRoleName(role.name)
                                ? "Protected role cannot be deleted"
                                : "Role has users; reassign them first"
                    }
                    className={cn(!deletable && "opacity-60")}
                >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete
                </DropdownMenuItem>
            </DropdownMenuContent>
        </DropdownMenu>
    );
}

================================================================================
END FILE: remoteiq-frontend\app\administration\tabs\RolesTab.tsx
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\app\administration\tabs\RolesMatrixTab.tsx
================================================================================
"use client";

import * as React from "react";
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { TabsContent } from "@/components/ui/tabs";
import { Check, X } from "lucide-react";

export type RolesMatrixTabProps = {
    push: (t: any) => void;
};

export default function RolesMatrixTab({ push }: RolesMatrixTabProps) {
    const permissions = ['View Devices', 'Manage Devices', 'Manage Users', 'View Billing', 'View Audit Logs', 'Manage API'];
    const roles = [
        { name: 'Technician', perms: [true, false, false, false, true, false] },
        { name: 'Admin', perms: [true, true, true, true, true, true] },
        { name: 'Read Only', perms: [true, false, false, false, true, false] },
    ];

    return (
        <TabsContent value="roles_matrix">
            <Card>
                <CardHeader>
                    <CardTitle>Roles Matrix</CardTitle>
                    <CardDescription>
                        Compare permissions across all roles in a grid view.
                    </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                    <div className="rounded-md border overflow-x-auto">
                        <table className="w-full text-sm">
                            <thead>
                                <tr className="border-b bg-muted/30">
                                    <th className="p-2 text-left font-medium">Permission</th>
                                    {roles.map(r => <th key={r.name} className="p-2 font-medium">{r.name}</th>)}
                                </tr>
                            </thead>
                            <tbody>
                                {permissions.map((perm, pIndex) => (
                                    <tr key={perm} className="border-b last:border-b-0">
                                        <td className="p-2 font-medium">{perm}</td>
                                        {roles.map((role, rIndex) => (
                                            <td key={role.name} className="p-2 text-center">
                                                {role.perms[pIndex]
                                                    ? <Check className="h-5 w-5 text-green-500 mx-auto" />
                                                    : <X className="h-5 w-5 text-muted-foreground mx-auto" />
                                                }
                                            </td>
                                        ))}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </CardContent>
            </Card>
        </TabsContent>
    );
}

================================================================================
END FILE: remoteiq-frontend\app\administration\tabs\RolesMatrixTab.tsx
================================================================================

================================================================================
BEGIN FILE: remoteiq-frontend\app\providers.tsx
================================================================================
// app/providers.tsx
"use client";

import * as React from "react";
import { ToastProvider } from "@/lib/toast";            // ✅ add this
import { TooltipProvider } from "@/components/ui/tooltip";
import AmbientTooltips from "@/components/ambient-tooltips";
import { DashboardProvider } from "@/app/(dashboard)/dashboard-context";

export default function Providers({ children }: { children: React.ReactNode }) {
    return (
        <ToastProvider>                                      {/* ✅ now useToast() is safe */}
            <TooltipProvider delayDuration={200}>
                <DashboardProvider>
                    {children}
                    {/* Global, zero-config tooltips for elements with data-tooltip="..." */}
                    <AmbientTooltips />
                </DashboardProvider>
            </TooltipProvider>
        </ToastProvider>
    );
}

================================================================================
END FILE: remoteiq-frontend\app\providers.tsx
================================================================================

 
Summary:
  Collected files : 45
  Skipped patterns: 2
  Skipped list:
    - database/migrations/*roles*.sql
    - database/migrations/*permission*.sql
