RemoteIQ Backups CORE Source Bundle
Generated: 2025-11-08 22:36:03 -05:00
RepoRoot : C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing



--------------------------------------------------------------------------------
| Backend Â· Backups module (*.ts) |
--------------------------------------------------------------------------------

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\admin.guard.ts

``r

import { CanActivate, ExecutionContext, Injectable, ForbiddenException } from "@nestjs/common";

/** Tight default: only allow authenticated admins.
 * Replace with your existing RBAC once wired.
 */
@Injectable()
export class AdminGuard implements CanActivate {
    canActivate(ctx: ExecutionContext): boolean {
        const req = ctx.switchToHttp().getRequest();
        // Example: if you have req.user / req.session
        const user = req.user || req.session?.user;
        if (!user) throw new ForbiddenException("Not authenticated");
        if (!user.roles || !Array.isArray(user.roles) || !user.roles.includes("admin")) {
            throw new ForbiddenException("Admin role required");
        }
        return true;
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\backups.controller.ts

``r

import {
    Body,
    Controller,
    Get,
    Post,
    Put,
    Param,
    Query,
    Res,
    HttpException,
    HttpStatus,
    UseGuards,
} from "@nestjs/common";
import { Response } from "express";
import { BackupsService } from "./backups.service";
import { HistoryQueryDto, BackupConfigDto } from "./dto";
import { PermissionsGuard } from "../auth/permissions.guard";
import { RequirePerm } from "../auth/require-perm.decorator";
import { WorkerService } from "./worker.service";

@Controller("/api/admin/backups")
@UseGuards(PermissionsGuard)
export class BackupsController {
    constructor(
        private readonly svc: BackupsService,
        private readonly worker: WorkerService
    ) { }

    /* ---------------- Config / Permissions ---------------- */

    @Get("config")
    @RequirePerm("backups.read")
    async getConfig() {
        return this.svc.getConfig();
    }

    @Put("config")
    @RequirePerm("backups.manage")
    async putConfig(@Body() body: BackupConfigDto) {
        this.svc.validateDestination((body as any).destination);
        return this.svc.saveConfig(body);
    }

    // Capability booleans for UI
    @Get("permissions")
    @RequirePerm("backups.read")
    async getPerms() {
        return this.svc.getPermissions();
    }

    /* ---------------- History ---------------- */

    @Get("history")
    @RequirePerm("backups.read")
    async history(@Query() q: HistoryQueryDto) {
        return this.svc.listHistory(q);
    }

    /* ---------------- Actions ---------------- */

    @Post("run")
    @RequirePerm("backups.run")
    async runNow() {
        const res = await this.svc.startBackupNow();
        // kick the worker (fire-and-forget)
        this.worker.runOneIfAny().catch(() => { });
        return res;
    }

    @Post("prune")
    @RequirePerm("backups.prune")
    async prune() {
        return this.svc.pruneOld();
    }

    @Post("test-destination")
    @RequirePerm("backups.manage")
    async testDest(@Body() body: any) {
        return this.svc.testDestination((body ?? {}).destination);
    }

    @Post(":id/retry")
    @RequirePerm("backups.run")
    async retry(@Param("id") id: string) {
        return this.svc.retryJob(id);
    }

    @Post(":id/cancel")
    @RequirePerm("backups.run")
    async cancel(@Param("id") id: string) {
        return this.svc.cancelJob(id);
    }

    @Post(":id/restore")
    @RequirePerm("backups.restore")
    async restore(@Param("id") id: string) {
        return this.svc.startRestore(id);
    }

    /* ---------------- Artifacts ---------------- */

    @Get(":id/log")
    @RequirePerm("backups.read")
    async log(@Param("id") id: string, @Res() res: Response) {
        const stream = await this.svc.openLogStream(id);
        if (!stream) throw new HttpException("Not found", HttpStatus.NOT_FOUND);
        res.setHeader("Content-Type", "text/plain; charset=utf-8");
        stream.pipe(res);
    }

    @Get(":id/manifest")
    @RequirePerm("backups.read")
    async manifest(@Param("id") id: string) {
        const m = await this.svc.getManifest(id);
        if (!m) throw new HttpException("Not found", HttpStatus.NOT_FOUND);
        return m;
    }

    @Get(":id/download")
    @RequirePerm("backups.download")
    async download(@Param("id") id: string, @Res() res: Response) {
        const out = await this.svc.getDownload(id);
        if (!out) throw new HttpException("Not found", HttpStatus.NOT_FOUND);

        if (out.stream) {
            res.setHeader(
                "Content-Disposition",
                `attachment; filename="${out.filename.replace(/"/g, "")}"`
            );
            res.setHeader("Content-Type", "application/octet-stream");
            out.stream.pipe(res);
            return;
        }
        if (out.presignedUrl) {
            res.redirect(out.presignedUrl);
            return;
        }
        throw new HttpException("Not found", HttpStatus.NOT_FOUND);
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\backups.module.ts

``r

import { Module } from "@nestjs/common";
import { BackupsController } from "./backups.controller";
import { BackupsService } from "./backups.service";
import { CronPreviewService } from "./cron-preview.service";
import { PgPoolService } from "../storage/pg-pool.service";
import { OrganizationContextService } from "../storage/organization-context.service";
import { PermissionsGuard } from "../auth/permissions.guard";
import { Reflector } from "@nestjs/core";
import { SchedulerService } from "./scheduler.service";
import { WorkerService } from "./worker.service";
import { NotifierService } from "./notifier.service";

@Module({
    controllers: [BackupsController],
    providers: [
        BackupsService,
        CronPreviewService,
        PgPoolService,
        OrganizationContextService,
        PermissionsGuard,
        Reflector,
        SchedulerService,
        WorkerService,
        NotifierService,
    ],
    exports: [BackupsService],
})
export class BackupsModule { }


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\backups.service.ts

``r

import {
    BadRequestException,
    Injectable,
    NotFoundException,
} from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";
import { OrganizationContextService } from "../storage/organization-context.service";
import { BackupConfigDto, HistoryQueryDto, FanoutDestinationDto } from "./dto";
import { Readable } from "stream";
import * as crypto from "crypto";
import { WorkerService } from "./worker.service";
import { NotifierService } from "./notifier.service";
import { s3PresignGet, webdavDownloadAsBuffer, gdriveDownloadAsBuffer } from "./storage-clients";

type JobRow = {
    id: string;
    started_at: Date;
    finished_at: Date | null;
    status: "running" | "completed" | "failed" | "cancelled";
    note: string | null;
    size_bytes: number | null;
    duration_sec: number | null;
    verified: boolean | null;
};

type HistoryStatus = "success" | "failed" | "running";

function mapFilterStatus(status: HistoryStatus | undefined): string | undefined {
    if (!status) return undefined;
    if (status === "success") return "completed";
    return status;
}
function projectStatus(status: string): HistoryStatus {
    switch (status) {
        case "completed": return "success";
        case "failed":
        case "cancelled": return "failed";
        default: return "running";
    }
}

function isAbsolutePath(p: string) {
    return p.startsWith("/") || /^[A-Za-z]:\\/.test(p);
}
function sanitizeLocalPath(p: string) {
    if (!isAbsolutePath(p)) throw new BadRequestException("Path must be absolute");
    if (p.includes("..") || p.includes("\0")) throw new BadRequestException("Invalid path");
    return p;
}
function parseCursor(cur?: string | null): number {
    if (!cur) return 0;
    try {
        const { page } = JSON.parse(Buffer.from(cur, "base64").toString("utf8"));
        return Number(page) || 0;
    } catch {
        return 0;
    }
}
function makeCursor(page: number) {
    return Buffer.from(JSON.stringify({ page }), "utf8").toString("base64");
}

type PolicyRow = {
    id: string;
    schedule: string;
    retention: any;
    options: any;
    destination_id: string | null;
    destination_provider: string | null;
    destination_configuration: any | null;
};

type PolicyConfig = {
    policyId: string;
    enabled: boolean;
    targets: string[];
    schedule: string;
    cronExpr?: string;
    retentionDays: number;
    encrypt: boolean;
    destination: any | null;
    extraDestinations: any[];
    notifications: Record<string, any>;
    lastScheduledAt?: string | null;
    minSuccess?: number | null;
    parallelism?: number | null;
};

@Injectable()
export class BackupsService {
    constructor(
        private readonly db: PgPoolService,
        private readonly notifier: NotifierService,
        private readonly worker: WorkerService,
        private readonly orgContext: OrganizationContextService,
    ) { }

    private async orgId(): Promise<string> {
        return this.orgContext.getDefaultOrganizationId();
    }

    private retentionDays(retention: any): number {
        if (!retention) return 30;
        if (typeof retention.days === "number") return retention.days;
        if (typeof retention.value === "number" && retention.unit === "days") return retention.value;
        return 30;
    }

    private async loadFanout(policyId: string): Promise<any[]> {
        const sql = `
      SELECT d.configuration
        FROM backup_policy_destinations pd
        JOIN backup_destinations d ON d.id = pd.destination_id
       WHERE pd.policy_id = $1
       ORDER BY pd.is_primary DESC, pd.priority ASC, d.name ASC
    `;
        const { rows } = await this.db.query<{ configuration: any }>(sql, [policyId]);
        return rows.slice(1).map((r) => r.configuration || {});
    }

    private parsePolicy(row: PolicyRow | null): PolicyConfig | null {
        if (!row) return null;
        const options = row.options && typeof row.options === "object" ? row.options : {};
        const destination =
            row.destination_configuration && typeof row.destination_configuration === "object"
                ? row.destination_configuration
                : null;

        const cronExpr = options.cronExpr ?? options.cron_expr ?? undefined;
        const notifications =
            options.notifications && typeof options.notifications === "object" ? options.notifications : {};

        const enabled = options.enabled ?? false;
        const rawTargets = Array.isArray(options.targets)
            ? options.targets.filter((t: any) => typeof t === "string" && t.trim().length)
            : [];
        const targets = rawTargets.length ? rawTargets : ["users", "roles", "devices", "settings"];
        const encrypt = options.encrypt ?? true;
        const lastScheduledAt = options.lastScheduledAt ?? options.last_scheduled_at ?? null;
        const minSuccess = options.minSuccess != null ? Number(options.minSuccess) : null;
        const parallelism = options.parallelism != null ? Number(options.parallelism) : null;

        return {
            policyId: row.id,
            enabled,
            targets,
            schedule: row.schedule,
            cronExpr: cronExpr ?? undefined,
            retentionDays: this.retentionDays(row.retention),
            encrypt,
            destination,
            extraDestinations: [],
            notifications,
            lastScheduledAt,
            minSuccess,
            parallelism,
        };
    }

    private normalizeDestinationInput(dest: any): { provider: string; configuration: any } {
        if (!dest || typeof dest !== "object") throw new BadRequestException("Destination required");
        const provider = dest.kind === "remote" ? "sftp" : dest.kind;
        return { provider, configuration: { ...dest } };
    }

    private async fetchDefaultPolicyRow(): Promise<PolicyRow | null> {
        const orgId = await this.orgId();
        const { rows } = await this.db.query<PolicyRow>(
            `SELECT p.id,
              p.schedule,
              p.retention,
              p.options,
              p.destination_id,
              d.provider AS destination_provider,
              d.configuration AS destination_configuration
         FROM backup_policies p
    LEFT JOIN backup_destinations d ON d.id = p.destination_id
        WHERE p.organization_id = $1
     ORDER BY p.is_default DESC, p.created_at ASC
        LIMIT 1`,
            [orgId]
        );
        return rows[0] ?? null;
    }

    private async fetchDefaultPolicy(): Promise<PolicyConfig | null> {
        const row = await this.fetchDefaultPolicyRow();
        const parsed = this.parsePolicy(row);
        if (!parsed) return null;
        parsed.extraDestinations = row?.id ? await this.loadFanout(row.id) : [];
        return parsed;
    }

    private async upsertDestination(
        orgId: string,
        dest: any,
        name: string,
    ): Promise<{ id: string; provider: string; configuration: any }> {
        const { provider, configuration } = this.normalizeDestinationInput(dest);
        const { rows } = await this.db.query<{ id: string; provider: string; configuration: any }>(
            `INSERT INTO backup_destinations (organization_id, name, provider, configuration)
       VALUES ($1, $2, $3, $4::jsonb)
       ON CONFLICT (organization_id, name)
       DO UPDATE SET provider = EXCLUDED.provider,
                     configuration = EXCLUDED.configuration,
                     updated_at = NOW()
       RETURNING id, provider, configuration`,
            [orgId, name, provider, JSON.stringify(configuration)]
        );
        return rows[0];
    }

    private fanoutName(i: number) {
        return i === 0 ? "Default Backup Destination" : `Backup Destination #${i + 1}`;
    }

    private validateFanoutItem(item: FanoutDestinationDto) {
        if (!item || typeof item !== "object") throw new BadRequestException("Bad destination");
        switch (item.kind) {
            case "local":
                if (!item.path) throw new BadRequestException("Local path required");
                sanitizeLocalPath(item.path);
                return;
            case "s3":
            case "nextcloud":
            case "gdrive":
            case "remote":
                if (!item.connectionId || !/^[0-9a-f-]{36}$/i.test(item.connectionId)) {
                    throw new BadRequestException("Valid connectionId required");
                }
                if (item.kind === "nextcloud") {
                    const p = String(item.path || "");
                    if (!p.startsWith("/")) throw new BadRequestException("Nextcloud path must start with '/'");
                }
                if (item.kind === "remote") {
                    const p = String(item.path || "");
                    if (!isAbsolutePath(p)) throw new BadRequestException("Remote path must be absolute");
                }
                return;
            default:
                throw new BadRequestException("Unsupported destination");
        }
    }

    private async upsertPolicyWithFanout(orgId: string, cfg: BackupConfigDto): Promise<PolicyConfig | null> {
        const primary = await this.upsertDestination(orgId, cfg.destination, this.fanoutName(0));

        const mergedOptions: Record<string, any> = {
            enabled: !!cfg.enabled,
            targets: cfg.targets,
            cronExpr: cfg.schedule === "cron" ? cfg.cronExpr ?? null : null,
            cron_expr: cfg.schedule === "cron" ? cfg.cronExpr ?? null : null, // legacy spell
            encrypt: !!cfg.encrypt,
            notifications: cfg.notifications ?? {},
        };
        if (cfg.minSuccess != null) mergedOptions.minSuccess = Number(cfg.minSuccess);
        if (cfg.parallelism != null) mergedOptions.parallelism = Number(cfg.parallelism);
        if (mergedOptions.cronExpr == null) delete (mergedOptions as any).cronExpr;
        if (mergedOptions.cron_expr == null) delete (mergedOptions as any).cron_expr;

        const policyIns = await this.db.query<{ id: string }>(
            `INSERT INTO backup_policies (
         organization_id, name, description, schedule, retention,
         destination_id, target_type, target_id, options, is_default
       )
       VALUES (
         $1, $2, $3, $4, $5::jsonb,
         $6, 'organization', NULL, $7::jsonb, TRUE
       )
       ON CONFLICT (organization_id, name)
       DO UPDATE SET
         description = EXCLUDED.description,
         schedule    = EXCLUDED.schedule,
         retention   = EXCLUDED.retention,
         destination_id = EXCLUDED.destination_id,
         target_type = EXCLUDED.target_type,
         target_id   = EXCLUDED.target_id,
         options     = EXCLUDED.options,
         is_default  = TRUE,
         updated_at  = NOW()
       RETURNING id`,
            [
                orgId,
                "Default Backup Policy",
                "Normalized default backups policy",
                cfg.schedule,
                JSON.stringify({ days: cfg.retentionDays }),
                primary.id,
                JSON.stringify(mergedOptions),
            ]
        );
        const policyId = policyIns.rows[0]?.id;
        if (!policyId) throw new Error("Failed to upsert policy");

        const extras = Array.isArray(cfg.extraDestinations) ? cfg.extraDestinations : [];
        for (const e of extras) this.validateFanoutItem(e);

        const withPrimary = [{ ...cfg.destination, isPrimary: true, priority: 10 } as FanoutDestinationDto]
            .concat(extras.map((e, i) => ({ ...e, isPrimary: false, priority: e.priority ?? (i + 2) * 10 })));

        const destIds: { id: string; isPrimary: boolean; priority: number }[] = [];
        for (let i = 0; i < withPrimary.length; i++) {
            const ent = withPrimary[i];
            const ins = await this.upsertDestination(orgId, ent, this.fanoutName(i));
            destIds.push({ id: ins.id, isPrimary: !!ent.isPrimary, priority: ent.priority ?? (i + 1) * 10 });
        }

        await this.db.query(`DELETE FROM backup_policy_destinations WHERE policy_id=$1`, [policyId]);

        if (destIds.length) {
            const values = destIds
                .map((_, i) => `($1::uuid, $${i * 3 + 2}::uuid, $${i * 3 + 3}::boolean, $${i * 3 + 4}::int)`)
                .join(", ");
            await this.db.query(
                `INSERT INTO backup_policy_destinations (policy_id, destination_id, is_primary, priority)
         VALUES ${values}
         ON CONFLICT (policy_id, destination_id) DO UPDATE
           SET is_primary = EXCLUDED.is_primary,
               priority   = EXCLUDED.priority`,
                [policyId, ...destIds.flatMap((d) => [d.id, d.isPrimary, d.priority])]
            );
        }

        const detail = await this.db.query<PolicyRow>(
            `SELECT p.id, p.schedule, p.retention, p.options, p.destination_id,
              d.provider AS destination_provider, d.configuration AS destination_configuration
         FROM backup_policies p
    LEFT JOIN backup_destinations d ON d.id = p.destination_id
        WHERE p.id = $1`,
            [policyId]
        );
        const parsed = this.parsePolicy(detail.rows[0] ?? null);
        if (!parsed) return null;
        parsed.extraDestinations = await this.loadFanout(policyId);
        return parsed;
    }

    /* ---------------- Permissions (UI helper) --------------- */
    async getPermissions() {
        // Safer defaults until your authz is wired
        return { restore: false, download: false };
    }

    /* ---------------- Config (load/save) --------------------- */
    async getConfig() {
        const policy = await this.fetchDefaultPolicy();
        if (!policy) {
            return {
                enabled: false,
                targets: ["users", "roles", "devices", "settings"],
                schedule: "daily",
                cronExpr: "0 3 * * *",
                retentionDays: 30,
                encrypt: true,
                destination: { kind: "local", path: "/var/remoteiq/backups" },
                extraDestinations: [],
                notifications: { email: false, webhook: false, slack: false },
                minSuccess: 1,
                parallelism: 2,
            };
        }

        return {
            enabled: policy.enabled,
            targets: policy.targets,
            schedule: policy.schedule as any,
            cronExpr: policy.cronExpr,
            retentionDays: policy.retentionDays,
            encrypt: policy.encrypt,
            destination: policy.destination ?? { kind: "local", path: "/var/remoteiq/backups" },
            extraDestinations: policy.extraDestinations ?? [],
            notifications: policy.notifications,
            minSuccess: policy.minSuccess ?? undefined,
            parallelism: policy.parallelism ?? undefined,
        };
    }

    validateDestination(dest: any) {
        if (!dest || typeof dest !== "object" || !dest.kind) {
            throw new BadRequestException("Destination required");
        }

        switch (dest.kind) {
            case "local":
                sanitizeLocalPath(String(dest.path || ""));
                break;
            case "s3":
            case "nextcloud":
            case "gdrive":
                if (!dest.connectionId || !/^[0-9a-f-]{36}$/i.test(dest.connectionId)) {
                    throw new BadRequestException("Valid connectionId required");
                }
                if (dest.kind === "nextcloud") {
                    const p = String(dest.path || "");
                    if (!p.startsWith("/"))
                        throw new BadRequestException("Nextcloud path must start with '/'");
                }
                break;
            case "remote":
                // still unsupported for primary
                throw new BadRequestException("Primary SFTP not yet supported. Use as an extra destination.");
            default:
                throw new BadRequestException("Unsupported destination");
        }
    }

    async saveConfig(cfg: BackupConfigDto) {
        if (cfg.schedule === "cron" && !cfg.cronExpr) {
            throw new BadRequestException("cronExpr required for schedule=cron");
        }
        this.validateDestination(cfg.destination);
        if (Array.isArray(cfg.extraDestinations)) {
            for (const e of cfg.extraDestinations) this.validateFanoutItem(e);
        }

        const orgId = await this.orgId();
        const policy = await this.upsertPolicyWithFanout(orgId, cfg);
        return { ok: true, policyId: policy?.policyId };
    }

    /* ---------------- History -------------------- */
    async listHistory(q: HistoryQueryDto) {
        const pageSize = 50;
        const page = parseCursor(q.cursor);
        const offset = page * pageSize;

        const params: any[] = [];
        const where: string[] = [];

        const policy = await this.fetchDefaultPolicy();
        if (policy?.policyId) {
            params.push(policy.policyId);
            where.push(`(policy_id = $${params.length} OR policy_id IS NULL)`);
        }
        const statusFilter = mapFilterStatus(q.status as any);
        if (statusFilter) {
            params.push(statusFilter);
            where.push(`status = $${params.length}`);
        }
        if (q.q?.trim()) {
            params.push(`%${q.q.trim()}%`);
            where.push(`(id::text ILIKE $${params.length} OR note ILIKE $${params.length})`);
        }
        if (q.from) {
            params.push(q.from);
            where.push(`started_at >= $${params.length}::date`);
        }
        if (q.to) {
            params.push(q.to);
            where.push(`started_at < ($${params.length}::date + INTERVAL '1 day')`);
        }
        const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";

        const sql = `
      SELECT id, started_at, status, note, size_bytes, duration_sec, verified
      FROM backup_jobs
      ${whereSql}
      ORDER BY started_at DESC
      LIMIT ${pageSize + 1}
      OFFSET ${offset}
    `;

        const { rows } = await this.db.query<JobRow>(sql, params);
        const items = rows.slice(0, pageSize).map((r) => ({
            id: r.id,
            at: r.started_at.toISOString().slice(0, 16).replace("T", " "),
            status: projectStatus(r.status),
            note: r.note ?? undefined,
            sizeBytes: r.size_bytes ?? undefined,
            durationSec: r.duration_sec ?? undefined,
            verified: r.verified ?? undefined,
        }));

        const hasMore = rows.length > pageSize;
        return { items, nextCursor: hasMore ? makeCursor(page + 1) : undefined };
    }

    /* ---------------- Scheduler hooks ------------- */
    async markScheduledOnce(now: Date) {
        const policy = await this.fetchDefaultPolicyRow();
        if (!policy) return { updated: false };

        const { rows } = await this.db.query(
            `UPDATE backup_policies
          SET options = jsonb_set(
              COALESCE(options, '{}'::jsonb),
              '{lastScheduledAt}',
              to_jsonb(($2)::timestamptz),
              true
          )
       WHERE id = $1
         AND (
              options->>'lastScheduledAt' IS NULL
           OR (options->>'lastScheduledAt')::timestamptz < ($2)::timestamptz - interval '30 seconds'
         )
       RETURNING 1`,
            [policy.id, now.toISOString()]
        );
        return { updated: rows.length > 0 };
    }

    async kickWorker() {
        await this.worker.runOneIfAny();
    }

    /* ---------------- Actions -------------------- */
    async startBackupNow() {
        const policy = await this.fetchDefaultPolicy();
        if (!policy) throw new BadRequestException("Backups not configured");
        if (!policy.enabled) throw new BadRequestException("Backups disabled");

        const id = crypto.randomUUID();
        await this.db.query(
            `INSERT INTO backup_jobs (id, policy_id, started_at, status, note)
       VALUES ($1, $2, NOW(), 'running', 'Manual run')`,
            [id, policy.policyId]
        );

        // Snapshot fan-out into backup_job_destinations for the worker
        const snap = await this.db.query<{ id: string; is_primary: boolean; priority: number }>(
            `SELECT d.id, pd.is_primary, pd.priority
         FROM backup_policy_destinations pd
         JOIN backup_destinations d ON d.id=pd.destination_id
        WHERE pd.policy_id=$1
        ORDER BY pd.priority ASC`,
            [policy.policyId]
        );
        if (snap.rows.length) {
            const values = snap.rows
                .map((_, i) => `($1::uuid, $${i * 3 + 2}::uuid, $${i * 3 + 3}::boolean, $${i * 3 + 4}::int, NOW())`)
                .join(", ");
            await this.db.query(
                `INSERT INTO backup_job_destinations (job_id, destination_id, is_primary, priority, created_at)
         VALUES ${values}`,
                [id, ...snap.rows.flatMap((r) => [r.id, r.is_primary, r.priority ?? 10])]
            );
        }

        await this.worker.runOneIfAny();
        return { id, startedAt: new Date().toISOString() };
    }

    async pruneOld() {
        const policy = await this.fetchDefaultPolicy();
        if (!policy) return { removed: 0 };

        const params: any[] = [String(policy.retentionDays)];
        let sql = `DELETE FROM backup_jobs
               WHERE COALESCE(finished_at, started_at) < (NOW() - ($1 || ' days')::interval)
                 AND status IN ('completed','failed','cancelled')`;

        if (policy.policyId) {
            params.push(policy.policyId);
            sql += ` AND (policy_id = $2 OR policy_id IS NULL)`;
        }

        const { rows } = await this.db.query(sql + ` RETURNING 1`, params);
        return { removed: rows.length };
    }

    // -------- Destination probe implementations --------
    async testDestination(dest: any) {
        if (dest.kind === "local") {
            sanitizeLocalPath(dest.path);
            const { ensureDir } = await import("./storage-clients");
            const fs = await import("fs/promises");
            const p = require("path").join(dest.path, ".remoteiq_probe.txt");
            await ensureDir(dest.path);
            await fs.writeFile(p, "probe");
            const r = await fs.readFile(p, "utf8");
            await fs.unlink(p);
            return { ok: r === "probe", phases: { write: true, read: r === "probe", delete: true } };
        }

        if (dest.kind === "s3") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='s3'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("S3 connection not found");
            const cfgS3 = { ...(row.config || {}), ...(row.secrets || {}) };
            const bucket = dest.bucket || cfgS3.bucket;
            const prefix = (dest.prefix || cfgS3.prefix || "").replace(/^\/+|\/+$/g, "");
            const key = (prefix ? `${prefix}/` : "") + ".remoteiq_probe.txt";
            const { s3PutObject, s3Head, s3Delete } = await import("./storage-clients");
            await s3PutObject(cfgS3, bucket, key, Buffer.from("probe"));
            const head = await s3Head(cfgS3, bucket, key);
            const ok = !!head;
            await s3Delete(cfgS3, bucket, key);
            return { ok, phases: { write: true, read: ok, delete: true } };
        }

        if (dest.kind === "nextcloud") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='nextcloud'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("Nextcloud connection not found");
            const { webdavProbe } = await import("./storage-clients");
            const url = row.config?.webdavUrl;
            const username = row.config?.username;
            const password = row.secrets?.password;
            const path = dest.path;
            const phases = await webdavProbe({ url, username, password, path });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        if (dest.kind === "remote") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='sftp'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("SFTP connection not found");
            const { sftpProbe } = await import("./storage-clients");
            const host = row.config?.host;
            const port = row.config?.port;
            const username = row.secrets?.username || row.config?.username;
            const password = row.secrets?.password;
            const privateKey = row.secrets?.privateKey;
            const passphrase = row.secrets?.passphrase;
            const phases = await sftpProbe({
                host,
                port,
                username,
                password,
                privateKey,
                passphrase,
                testPath: dest.path,
            });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        if (dest.kind === "gdrive") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='gdrive'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("GDrive connection not found");
            const { gdriveProbe } = await import("./storage-clients");
            const credentialsJson = row.secrets?.serviceAccountJson;
            const folderId = row.config?.folderId || undefined;
            const phases = await gdriveProbe({ credentialsJson, folderId });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        throw new BadRequestException("Unsupported destination");
    }

    async testNotification() {
        await this.notifier.send(
            { email: true, slack: true, webhook: true },
            "RemoteIQ Backups: Test",
            "This is a test notification."
        );
        return { sent: true };
    }

    async retryJob(id: string) {
        const { rows } = await this.db.query(
            `UPDATE backup_jobs
         SET status='running', note='Retry queued', finished_at=NULL, cancelled=false
       WHERE id=$1 AND status='failed'
       RETURNING 1`,
            [id]
        );
        if (!rows.length) throw new BadRequestException("Job not in failed state");
        await this.worker.runOneIfAny();
        return { queued: true };
    }

    async cancelJob(id: string) {
        const { rows } = await this.db.query(
            `UPDATE backup_jobs
         SET cancelled=true, status='cancelled', finished_at=NOW(), note='Cancelled by user'
       WHERE id=$1 AND status='running'
       RETURNING 1`,
            [id]
        );
        if (!rows.length) throw new BadRequestException("Job not running");
        return { sent: true };
    }

    async startRestore(id: string) {
        const { rows } = await this.db.query(
            `SELECT id, status FROM backup_jobs WHERE id=$1 LIMIT 1`,
            [id]
        );
        if (!rows.length) return null;
        if (rows[0].status !== "completed")
            throw new BadRequestException("Backup not successful");

        await this.db.query(
            `INSERT INTO backup_restores (id, backup_job_id, status)
       VALUES ($1, $2, 'running')`,
            [crypto.randomUUID(), id]
        );
        return { started: true };
    }

    /* ---------------- Artifacts ------------------- */
    async openLogStream(id: string): Promise<Readable | null> {
        const { rows } = await this.db.query(
            `SELECT log_text FROM backup_job_logs WHERE job_id=$1`,
            [id]
        );
        if (!rows.length) return null;
        const text: string = rows[0].log_text ?? "";
        return Readable.from(text);
    }

    async getManifest(id: string): Promise<any | null> {
        const { rows } = await this.db.query(
            `SELECT manifest FROM backup_job_manifests WHERE job_id=$1`,
            [id]
        );
        if (!rows.length) return null;
        return rows[0].manifest;
    }

    async getDownload(id: string): Promise<{ presignedUrl?: string; stream?: Readable; filename: string } | null> {
        const { rows } = await this.db.query(
            `SELECT j.status,
              j.artifact_location,
              d.configuration AS destination_configuration
         FROM backup_jobs j
    LEFT JOIN backup_policies p ON j.policy_id = p.id
    LEFT JOIN backup_destinations d ON d.id = p.destination_id
        WHERE j.id=$1`,
            [id]
        );
        if (!rows.length) return null;
        if (rows[0].status !== "completed")
            throw new BadRequestException("Backup not successful");

        const loc = rows[0].artifact_location || {};
        if (loc.kind === "local") {
            const fs = await import("fs");
            if (!fs.existsSync(loc.path)) return null;
            const filename = String(loc.path).split(/[\\/]/).pop() || "backup.tar.gz";
            return { filename, stream: fs.createReadStream(loc.path) };
        }
        if (loc.kind === "s3") {
            const destConfig = rows[0].destination_configuration || {};
            const connectionId = loc.connectionId || destConfig.connectionId;
            if (!connectionId) throw new BadRequestException("S3 connection missing");
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='s3'`,
                [connectionId]
            )).rows[0];
            if (!row) throw new BadRequestException("S3 connection missing");
            const s3Cfg = { ...(row.config || {}), ...(row.secrets || {}) };
            const bucket = loc.bucket || destConfig.bucket || s3Cfg.bucket;
            const key = loc.key || destConfig.key;
            if (!bucket || !key) throw new BadRequestException("S3 location incomplete");
            const url = await s3PresignGet(s3Cfg, bucket, key, 60 * 10);
            const filename = String(key || "").split("/").pop() || "backup.tar.gz";
            return { presignedUrl: url, filename };
        }
        if (loc.kind === "nextcloud") {
            const connectionId = loc.connectionId;
            if (!connectionId) throw new BadRequestException("Nextcloud connection missing");
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='nextcloud'`,
                [connectionId]
            )).rows[0];
            if (!row) throw new BadRequestException("Nextcloud connection missing");
            const webdavUrl = row.config?.webdavUrl;
            const username = row.config?.username;
            const password = row.secrets?.password;
            const remotePath = loc.path;
            if (!webdavUrl || !username || !password || !remotePath) {
                throw new BadRequestException("Nextcloud location incomplete");
            }
            const buf = await webdavDownloadAsBuffer({ url: webdavUrl, username, password, remotePath });
            const filename = String(remotePath).split("/").pop() || "backup.tar.gz";
            return { filename, stream: Readable.from(buf) };
        }
        if (loc.kind === "gdrive") {
            const connectionId = loc.connectionId;
            if (!connectionId) throw new BadRequestException("GDrive connection missing");
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='gdrive'`,
                [connectionId]
            )).rows[0];
            if (!row) throw new BadRequestException("GDrive connection missing");
            const credentialsJson = row.secrets?.serviceAccountJson;
            const fileId = loc.fileId;
            if (!credentialsJson || !fileId) throw new BadRequestException("GDrive location incomplete");
            const buf = await gdriveDownloadAsBuffer({ credentialsJson, fileId });
            const filename = loc.name || "backup.tar.gz";
            return { filename, stream: Readable.from(buf) };
        }
        return null;
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\cron-preview.service.ts

``r

import { Injectable, BadRequestException } from "@nestjs/common";
import * as cronParser from "cron-parser"; // namespace import works across CJS/ESM builds

@Injectable()
export class CronPreviewService {
    nextRuns(expr: string, tz: string, count = 5): string[] {
        try {
            const parse = (cronParser as any).parseExpression as
                | ((e: string, o?: any) => any)
                | undefined;

            if (typeof parse !== "function") {
                throw new Error("cron-parser: parseExpression is not available");
            }

            const interval = parse(expr, { tz });
            const out: string[] = [];
            for (let i = 0; i < count; i++) {
                const d = interval.next().toDate();
                out.push(
                    d.toLocaleString("en-US", {
                        timeZone: tz,
                        weekday: "short",
                        hour: "2-digit",
                        minute: "2-digit",
                    })
                );
            }
            return out;
        } catch (e: any) {
            throw new BadRequestException(e?.message ?? "Invalid cron");
        }
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\dto.ts

``r

// remoteiq-minimal-e2e/backend/src/backups/dto.ts
import {
    IsArray, IsBoolean, IsIn, IsInt, IsOptional, IsString,
    IsUUID, Min, Max, ValidateNested, IsObject, Matches, ValidateIf,
} from "class-validator";
import { Type, Transform } from "class-transformer";

export const SCHEDULES = ["hourly", "daily", "weekly", "cron"] as const;
export type ScheduleKind = typeof SCHEDULES[number];

export type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";
export type Destination =
    | { kind: "local"; path: string }
    | { kind: "s3"; connectionId: string; bucket?: string; prefix?: string }
    | { kind: "nextcloud"; connectionId: string; path: string }
    | { kind: "gdrive"; connectionId: string; subfolder?: string }
    | { kind: "remote"; connectionId: string; path: string }; // SFTP

export class NotificationsDto {
    @IsOptional() @IsBoolean() email?: boolean;
    @IsOptional() @IsBoolean() webhook?: boolean;
    @IsOptional() @IsBoolean() slack?: boolean;
}

/** Primary (legacy) destination DTOs */
export class LocalDestDto {
    @IsIn(["local"]) kind!: "local";
    @IsString() path!: string;
}
export class S3DestDto {
    @IsIn(["s3"]) kind!: "s3";
    @IsUUID() connectionId!: string;
    @IsOptional() @IsString() bucket?: string;
    @IsOptional() @IsString() prefix?: string;
}
export class NextcloudDestDto {
    @IsIn(["nextcloud"]) kind!: "nextcloud";
    @IsUUID() connectionId!: string;
    @IsString() path!: string;
}
export class GDriveDestDto {
    @IsIn(["gdrive"]) kind!: "gdrive";
    @IsUUID() connectionId!: string;
    @IsOptional() @IsString() subfolder?: string;
}
export class RemoteDestDto {
    @IsIn(["remote"]) kind!: "remote";
    @IsUUID() connectionId!: string;
    @IsString() path!: string;
}
export class DestinationDto {
    @IsIn(["local", "s3", "nextcloud", "gdrive", "remote"])
    kind!: Destination["kind"];
}

/** Additional (fan-out) destination item */
export class FanoutDestinationDto {
    @IsIn(["local", "s3", "nextcloud", "gdrive", "remote"])
    kind!: Destination["kind"];

    // Convert "" -> undefined so optional validators don't fire on empty strings
    @Transform(({ value }) => (value === "" ? undefined : value))
    @IsOptional()
    @ValidateIf(o => o.kind !== "local" && o.connectionId !== undefined)
    @IsUUID()
    connectionId?: string;          // s3/nextcloud/gdrive/remote

    // Paths (only required by certain kinds; service layer also validates specifics)
    @IsOptional()
    @ValidateIf(o => o.kind === "local" || o.kind === "remote" || o.kind === "nextcloud")
    @IsString()
    path?: string;                  // local / remote / nextcloud

    // S3 options
    @IsOptional() @IsString()
    bucket?: string;
    @IsOptional() @IsString()
    prefix?: string;

    // GDrive option
    @IsOptional() @IsString()
    subfolder?: string;

    @IsOptional() @IsBoolean()
    isPrimary?: boolean;            // server normalizes; only one should be true

    @IsOptional() @IsInt() @Min(0) @Max(100000)
    priority?: number;              // ordering / tie-breaker
}

export class BackupConfigDto {
    @IsBoolean() enabled!: boolean;

    @IsArray() @IsString({ each: true })
    targets!: string[]; // UI-enforced values

    @IsIn(SCHEDULES as unknown as string[]) schedule!: ScheduleKind;

    @IsOptional()
    @Matches(/^(\S+\s+){4}\S+$/)
    cronExpr?: string;

    @IsInt() @Min(1) @Max(3650)
    retentionDays!: number;

    @IsBoolean() encrypt!: boolean;

    @IsObject()
    destination!: Destination; // primary (kept for compatibility)

    /** NEW: extra fan-out destinations (in addition to primary) */
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => FanoutDestinationDto)
    extraDestinations?: FanoutDestinationDto[];

    /** Optional notification toggles */
    @IsOptional() @ValidateNested()
    @Type(() => NotificationsDto)
    notifications?: NotificationsDto;

    /** Optional runner hints; persisted into policy.options */
    @IsOptional() @IsInt() @Min(1) @Max(64)
    parallelism?: number;

    @IsOptional() @IsInt() @Min(1) @Max(64)
    minSuccess?: number;
}

export class HistoryQueryDto {
    @IsOptional() @IsString() cursor?: string;
    @IsOptional() @IsIn(["success", "failed", "running"]) status?: "success" | "failed" | "running";
    @IsOptional() @IsString() q?: string;
    @IsOptional() @Matches(/^\d{4}-\d{2}-\d{2}$/) from?: string;
    @IsOptional() @Matches(/^\d{4}-\d{2}-\d{2}$/) to?: string;
}

export class TestDestinationDto {
    @ValidateNested()
    @Type(() => Object)
    destination!: Destination;
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\notifier.service.ts

``r

import { Injectable, Logger } from "@nestjs/common";
import nodemailer from "nodemailer";
import axios from "axios";

type Channels = { email?: boolean; slack?: boolean; webhook?: boolean };

@Injectable()
export class NotifierService {
    private log = new Logger("BackupsNotifier");

    async send(channels: Channels, subject: string, body: string) {
        const promises: Promise<any>[] = [];
        if (channels.email) promises.push(this.sendEmail(subject, body));
        if (channels.slack) promises.push(this.sendSlack(body));
        if (channels.webhook) promises.push(this.sendWebhook({ subject, body }));
        await Promise.allSettled(promises);
    }

    private async sendEmail(subject: string, body: string) {
        const { SMTP_HOST, SMTP_PORT, SMTP_SECURE, SMTP_USER, SMTP_PASS, SMTP_FROM, SMTP_TO } = process.env as any;
        if (!SMTP_HOST || !SMTP_FROM || !SMTP_TO) return;
        const transporter = nodemailer.createTransport({
            host: SMTP_HOST,
            port: Number(SMTP_PORT ?? 587),
            secure: String(SMTP_SECURE ?? "false") === "true",
            auth: SMTP_USER && SMTP_PASS ? { user: SMTP_USER, pass: SMTP_PASS } : undefined,
        });
        await transporter.sendMail({
            from: SMTP_FROM,
            to: SMTP_TO,
            subject,
            text: body,
        });
    }

    private async sendSlack(text: string) {
        const url = process.env.SLACK_WEBHOOK_URL;
        if (!url) return;
        await axios.post(url, { text });
    }

    private async sendWebhook(payload: any) {
        const url = process.env.BACKUPS_WEBHOOK_URL;
        if (!url) return;
        await axios.post(url, payload, { timeout: 5000 });
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\scheduler.service.ts

``r

import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from "@nestjs/common";
import * as cronParser from "cron-parser";
import { BackupsService } from "./backups.service";
import { WorkerService } from "./worker.service";

@Injectable()
export class SchedulerService implements OnModuleInit, OnModuleDestroy {
    private cronTimer?: NodeJS.Timeout;
    private workerTimer?: NodeJS.Timeout;
    private log = new Logger("BackupsScheduler");

    constructor(
        private readonly svc: BackupsService,
        private readonly worker: WorkerService
    ) { }

    onModuleInit() {
        // Check cron schedule every 30s
        this.cronTimer = setInterval(
            () => this.tickCron().catch((e) => this.log.error(e?.message || e)),
            30_000
        );
        // Worker pump every 5s to process any running jobs
        this.workerTimer = setInterval(
            () => this.worker.runOneIfAny().catch(() => { }),
            5_000
        );
    }

    onModuleDestroy() {
        if (this.cronTimer) clearInterval(this.cronTimer);
        if (this.workerTimer) clearInterval(this.workerTimer);
    }

    private async tickCron() {
        const cfg = await this.svc.getConfig();
        if (!cfg.enabled) return;

        const now = new Date();
        let due = false;

        if (cfg.schedule === "hourly") {
            due = now.getMinutes() === 0;
        } else if (cfg.schedule === "daily") {
            due = now.getHours() === 3 && now.getMinutes() === 0;
        } else if (cfg.schedule === "weekly") {
            due = now.getDay() === 0 && now.getHours() === 3 && now.getMinutes() === 0;
        } else if (cfg.schedule === "cron" && cfg.cronExpr) {
            const parse = (cronParser as any).parseExpression as
                | ((expr: string, opts?: any) => { prev(): { toDate(): Date } })
                | undefined;
            if (typeof parse !== "function") {
                this.log.warn("cron-parser parseExpression not available");
            } else {
                const it = parse(cfg.cronExpr, {
                    tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
                });
                const prev = it.prev().toDate();
                // fire if previous occurrence is within last minute
                due = +now - +prev < 60_000;
            }
        }

        if (!due) return;

        this.log.log("Cron window due → starting backup job");
        await this.svc.startBackupNow();
        // Immediately try to process it
        this.worker.runOneIfAny().catch(() => { });
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\storage-clients.ts

``r

import {
    S3Client,
    PutObjectCommand,
    HeadObjectCommand,
    DeleteObjectCommand,
    GetObjectCommand,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import SftpClient from "ssh2-sftp-client";
import { createClient as createWebdavClient } from "webdav";
import { google } from "googleapis";
import * as fs from "fs";
import * as fsp from "fs/promises";
import * as path from "path";
import * as crypto from "crypto";
import type { Readable as NodeReadable } from "stream";

/* ---------------- Types ---------------- */
export type LocalLoc = { kind: "local"; path: string };
export type S3Loc = { kind: "s3"; bucket: string; key: string; region?: string; endpoint?: string };
export type ArtifactLoc = LocalLoc | S3Loc;

export type S3Secret = {
    region?: string;
    bucket?: string;
    endpoint?: string; // optional for compatible S3 (e.g., MinIO, Wasabi)
    accessKeyId?: string;
    secretAccessKey?: string;
    sessionToken?: string;
    forcePathStyle?: boolean;
    kmsKeyId?: string; // reserved
};

export async function ensureDir(p: string) {
    await fsp.mkdir(p, { recursive: true });
}

/* ---------------- Small path helpers (WebDAV-safe) ---------------- */
function ensureLeadingSlash(p: string) {
    return p.startsWith("/") ? p : `/${p}`;
}
function ensureTrailingSlash(p: string) {
    return p.endsWith("/") ? p : `${p}/`;
}
function collapseSlashes(p: string) {
    return p.replace(/\/{2,}/g, "/");
}
function normalizeDirPath(p: string) {
    return collapseSlashes(ensureTrailingSlash(ensureLeadingSlash(p || "/")));
}
function normalizeFilePath(p: string) {
    const withLead = ensureLeadingSlash(p || "/");
    const noTrail = collapseSlashes(withLead).replace(/\/+$/g, "");
    return noTrail.length ? noTrail : "/";
}

/* ---------------- Local ---------------- */
export async function localWriteStream(absDir: string, filename: string) {
    await ensureDir(absDir);
    const full = path.join(absDir, filename);
    return { stream: fs.createWriteStream(full), fullPath: full };
}
export function localArtifactLoc(fullPath: string): LocalLoc {
    return { kind: "local", path: fullPath };
}

/* ---------------- S3 ---------------- */
function makeS3Client(secret: S3Secret) {
    const cfg: any = { region: secret.region ?? "us-east-1" };
    if (secret.endpoint) cfg.endpoint = secret.endpoint;
    if (secret.accessKeyId && secret.secretAccessKey) {
        cfg.credentials = {
            accessKeyId: secret.accessKeyId,
            secretAccessKey: secret.secretAccessKey,
            sessionToken: secret.sessionToken,
        };
    }
    if (secret.forcePathStyle != null) cfg.forcePathStyle = secret.forcePathStyle;
    return new S3Client(cfg);
}

export async function s3PutObject(
    secret: S3Secret,
    bucket: string,
    key: string,
    body: Buffer | Uint8Array | NodeReadable
) {
    const s3 = makeS3Client(secret);
    await s3.send(new PutObjectCommand({ Bucket: bucket, Key: key, Body: body as any }));
}
export async function s3Head(secret: S3Secret, bucket: string, key: string) {
    const s3 = makeS3Client(secret);
    return s3.send(new HeadObjectCommand({ Bucket: bucket, Key: key }));
}
export async function s3Delete(secret: S3Secret, bucket: string, key: string) {
    const s3 = makeS3Client(secret);
    await s3.send(new DeleteObjectCommand({ Bucket: bucket, Key: key }));
}
export async function s3PresignGet(
    secret: S3Secret,
    bucket: string,
    key: string,
    expiresSec = 60 * 10
) {
    const s3 = makeS3Client(secret);
    return getSignedUrl(
        s3,
        new GetObjectCommand({ Bucket: bucket, Key: key }),
        { expiresIn: expiresSec }
    );
}

/* ---------------- SFTP (probe only) ---------------- */
export async function sftpProbe(opts: {
    host: string;
    port?: number;
    username: string;
    password?: string;
    privateKey?: string;
    passphrase?: string;
    hostHash?: string;
    testPath: string;
}) {
    const client = new SftpClient();
    try {
        await client.connect({
            host: opts.host,
            port: opts.port ?? 22,
            username: opts.username,
            password: opts.password,
            privateKey: opts.privateKey,
            passphrase: opts.passphrase,
        });
        const dir = normalizeDirPath(opts.testPath).replace(/\/$/, "");
        const file = dir + "/remoteiq_probe_" + crypto.randomBytes(8).toString("hex") + ".txt";
        const data = Buffer.from("probe");
        await client.put(data, file);
        const read = (await client.get(file)) as Buffer;
        const okRead = read && read.length === data.length;
        await client.delete(file);
        return { write: true, read: okRead, delete: true };
    } finally {
        try { await client.end(); } catch { }
    }
}

/* ---------------- WebDAV (probe + upload + list + download) ---------------- */
export async function webdavProbe(opts: { url: string; username: string; password: string; path: string; }) {
    const client = createWebdavClient(opts.url, { username: opts.username, password: opts.password });
    const baseDir = normalizeDirPath(opts.path).replace(/\/$/, "");
    const name = "remoteiq_probe_" + crypto.randomBytes(8).toString("hex") + ".txt";
    const p = normalizeFilePath(`${baseDir}/${name}`);
    const data = "probe";
    await client.putFileContents(p, data, { overwrite: true });
    const read = await client.getFileContents(p, { format: "text" });
    const okRead = read === data;
    await client.deleteFile(p);
    return { write: true, read: okRead, delete: true };
}
export async function webdavUpload(opts: {
    url: string; username: string; password: string;
    directory: string; filename: string; body: Buffer | NodeReadable;
}) {
    const client = createWebdavClient(opts.url, { username: opts.username, password: opts.password });
    const base = normalizeDirPath(opts.directory).replace(/\/$/, "");
    const full = normalizeFilePath(`${base}/${opts.filename}`);
    await client.putFileContents(full, opts.body as any, { overwrite: true });
    return full;
}
export async function webdavDownloadAsBuffer(opts: {
    url: string; username: string; password: string; remotePath: string;
}): Promise<Buffer> {
    const client = createWebdavClient(opts.url, { username: opts.username, password: opts.password });
    const rp = normalizeFilePath(opts.remotePath);
    const buf = await client.getFileContents(rp, { format: "binary" }) as Buffer;
    return Buffer.isBuffer(buf) ? buf : Buffer.from(buf as any);
}
export async function webdavListDirs(opts: {
    url: string; username: string; password: string; basePath: string;
}): Promise<string[]> {
    let baseUrl = String(opts.url || "").trim();
    if (!baseUrl) throw new Error("webdavListDirs: missing url");
    if (!baseUrl.endsWith("/")) baseUrl += "/";

    const client = createWebdavClient(baseUrl, { username: opts.username, password: opts.password });
    const cleaned = String(opts.basePath || "/").replace(/\/{2,}/g, "/");
    const rel = cleaned.replace(/^\/+/, "");
    const relDir = rel.endsWith("/") ? rel : rel + "/";
    const absPathname = new URL(relDir, baseUrl).pathname;

    const toAbs = (p: string) => {
        const s = String(p || "");
        const pathOnly = s.replace(/^https?:\/\/[^/]+/i, "");
        const withLead = pathOnly.startsWith("/") ? pathOnly : "/" + pathOnly;
        return withLead.replace(/\/{2,}/g, "/").replace(/\/$/, "") || "/";
    };

    async function tryList(pathArg: string) {
        const items = await client.getDirectoryContents(pathArg, { deep: false }) as any[];
        return (items || []).filter((x) => x.type === "directory").map((x) => toAbs(String(x.filename ?? x.href ?? "")));
    }

    try {
        const dirs = await tryList(relDir);
        return Array.from(new Set(dirs)).sort((a, b) => a.localeCompare(b));
    } catch (e: any) {
        if (String(e?.message || "").includes("401") || String(e?.message || "").includes("404")) {
            const dirs = await tryList(absPathname);
            return Array.from(new Set(dirs)).sort((a, b) => a.localeCompare(b));
        }
        throw e;
    }
}

/* ---------------- Google Drive (probe + upload + download) ---------------- */

function makeDriveClient(credentialsJson: any) {
    if (!credentialsJson?.client_email || !credentialsJson?.private_key) {
        throw new Error("Missing Google service account JSON (client_email/private_key)");
    }
    const auth = new google.auth.JWT({
        email: credentialsJson.client_email,
        key: credentialsJson.private_key,
        scopes: ["https://www.googleapis.com/auth/drive.file"],
    });
    return google.drive({ version: "v3", auth });
}

/** Find or create a subfolder inside a parent folder and return its id. Works with personal + Shared Drives. */
async function ensureSubfolder(drive: any, parentId: string, name: string): Promise<string> {
    const q = [
        `'${parentId}' in parents`,
        `mimeType = 'application/vnd.google-apps.folder'`,
        `name = '${name.replace(/'/g, "\\'")}'`,
        "trashed = false",
    ].join(" and ");

    const { data } = await drive.files.list({
        q,
        fields: "files(id,name)",
        supportsAllDrives: true,
        includeItemsFromAllDrives: true,
        corpora: "allDrives",
    });

    if (data.files && data.files[0]) return data.files[0].id;

    const created = await drive.files.create({
        requestBody: {
            name,
            parents: [parentId],
            mimeType: "application/vnd.google-apps.folder",
        },
        fields: "id",
        supportsAllDrives: true,
    });

    return created.data.id!;
}

export async function gdriveProbe(opts: { credentialsJson: any; folderId?: string }) {
    if (!opts.folderId) {
        throw new Error("Google Drive folderId is required");
    }
    const drive = makeDriveClient(opts.credentialsJson);
    const name = "remoteiq_probe_" + crypto.randomBytes(8).toString("hex") + ".txt";
    const createRes = await drive.files.create({
        requestBody: { name, parents: [opts.folderId] },
        media: { mimeType: "text/plain", body: "probe" as any },
        fields: "id",
        supportsAllDrives: true,
    });
    const id = createRes.data.id!;
    const get = await drive.files.get({ fileId: id, alt: "media" }, { responseType: "arraybuffer" });
    const okRead = Buffer.from(get.data as any).toString("utf8") === "probe";
    await drive.files.delete({ fileId: id, supportsAllDrives: true });
    return { write: true, read: okRead, delete: true };
}

export async function gdriveUpload(opts: {
    credentialsJson: any;            // service account JSON
    folderId: string;                // parent folder ID (Shared Drive or My Drive folder)
    subfolder?: string;              // optional subfolder to create/use inside folderId
    name: string;                    // filename
    body: Buffer | NodeReadable;     // content
}): Promise<{ fileId: string }> {
    if (!opts.folderId) throw new Error("Google Drive folderId missing");
    const drive = makeDriveClient(opts.credentialsJson);

    let parentId = opts.folderId;
    if (opts.subfolder && opts.subfolder.trim()) {
        parentId = await ensureSubfolder(drive, parentId, opts.subfolder.trim());
    }

    const res = await drive.files.create({
        requestBody: { name: opts.name, parents: [parentId] },
        media: { mimeType: "application/gzip", body: opts.body as any },
        fields: "id",
        supportsAllDrives: true,
    });
    const fileId = res.data.id!;
    return { fileId };
}

export async function gdriveDownloadAsBuffer(opts: {
    credentialsJson: any;
    fileId: string;
}): Promise<Buffer> {
    const drive = makeDriveClient(opts.credentialsJson);
    const res = await drive.files.get({ fileId: opts.fileId, alt: "media" }, { responseType: "arraybuffer" });
    return Buffer.from(res.data as any);
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\worker.service.ts

``r

import { Injectable, Logger } from "@nestjs/common";
import * as fs from "fs";
import * as fsp from "fs/promises";
import * as os from "os";
import * as path from "path";
import archiver from "archiver";
import { PgPoolService } from "../storage/pg-pool.service";
import { s3PutObject, s3Head, ensureDir, webdavUpload, gdriveUpload } from "./storage-clients";
import { NotifierService } from "./notifier.service";

type Job = { id: string; status: string; cancelled: boolean };

type FanoutDest =
    | { kind: "local"; path: string; priority?: number }
    | { kind: "s3"; connectionId: string; bucket?: string; prefix?: string; priority?: number }
    | { kind: "nextcloud"; connectionId: string; path: string; priority?: number }
    | { kind: "gdrive"; connectionId: string; subfolder?: string; priority?: number }
    | { kind: "remote"; connectionId: string; path: string; priority?: number };

type JobConfig = {
    targets: string[];
    destination:
    | { kind: "local"; path: string }
    | { kind: "s3"; connectionId: string; bucket?: string; prefix?: string }
    | { kind: "nextcloud"; connectionId: string; path: string }
    | { kind: "gdrive"; connectionId: string; subfolder?: string }
    | { kind: "remote"; connectionId: string; path: string };
    extras: FanoutDest[]; // additional destinations (fan-out)
    notifications: { email?: boolean; slack?: boolean; webhook?: boolean };
    /** Runner hints (from policy.options) */
    minSuccess?: number;
    parallelism?: number;
};

@Injectable()
export class WorkerService {
    private log = new Logger("BackupsWorker");
    private running = false;

    constructor(
        private readonly db: PgPoolService,
        private readonly notifier: NotifierService
    ) { }

    /** Picks the oldest running job and processes it (re-entrant safe). */
    async runOneIfAny() {
        if (this.running) return;
        const job = await this.pickJob();
        if (!job) return;

        this.running = true;
        try {
            await this.process(job.id);
        } finally {
            this.running = false;
        }
    }

    private async pickJob(): Promise<Job | null> {
        const { rows } = await this.db.query(
            `SELECT id, status, cancelled
         FROM backup_jobs
        WHERE status='running' AND cancelled=false
        ORDER BY started_at ASC
        LIMIT 1`
        );
        return rows[0] ?? null;
    }

    private async appendLog(jobId: string, chunk: string) {
        await this.db.query(
            `INSERT INTO backup_job_logs (job_id, log_text)
       VALUES ($1, $2)
       ON CONFLICT (job_id) DO UPDATE SET log_text = backup_job_logs.log_text || $2`,
            [jobId, chunk]
        );
    }

    /** simple bounded-concurrency helper */
    private async pLimit<T>(limit: number, tasks: (() => Promise<T>)[]) {
        const results: Promise<T>[] = [];
        const pool: Promise<void>[] = [];
        let i = 0;
        const run = async () => {
            while (i < tasks.length) {
                const idx = i++;
                results[idx] = tasks[idx]();
                await results[idx].then(() => void 0, () => void 0);
            }
        };
        for (let k = 0; k < Math.max(1, limit); k++) pool.push(run());
        await Promise.all(pool);
        return Promise.allSettled(results);
    }

    /**
     * Process a single job:
     *  - export selected targets to NDJSON (skip missing)
     *  - tar.gz into an archive
     *  - write to local path or upload to remote destination(s)
     *  - fan-out to extra destinations
     *  - persist manifest/log
     *  - mark success (respecting minSuccess)
     */
    async process(jobId: string) {
        const started = Date.now();

        const cfg = await this.loadJobConfig(jobId);
        if (!cfg) {
            await this.fail(jobId, "Backup configuration missing");
            return;
        }

        const tmpRoot = await fsp.mkdtemp(path.join(os.tmpdir(), "remoteiq-bkp-"));
        const exportDir = path.join(tmpRoot, "export");
        await ensureDir(exportDir);

        try {
            // Export targets -> NDJSON files
            const targets: string[] = cfg.targets.length ? cfg.targets : ["users", "devices", "settings"];

            const manifest: any = {
                id: jobId,
                targets,
                files: [],
                counts: {},
                createdAt: new Date().toISOString(),
            };

            await this.appendLog(jobId, `Exporting targets: ${targets.join(", ")}\n`);

            for (const t of targets) {
                const table = await this.resolveExistingTableForTarget(jobId, t);
                if (!table) {
                    await this.appendLog(jobId, `  - ${t}: skipped (no mapped table/view exists)\n`);
                    manifest.counts[t] = 0;
                    continue;
                }

                const file = path.join(exportDir, `${t}.ndjson`);
                const ws = fs.createWriteStream(file, { flags: "w" });

                try {
                    const { rows } = await this.db.query(`SELECT * FROM ${table}`);
                    let count = 0;
                    for (const row of rows) {
                        ws.write(JSON.stringify(row) + "\n");
                        count++;
                    }
                    await new Promise((r) => ws.end(r));
                    manifest.files.push(path.basename(file));
                    manifest.counts[t] = count;
                    await this.appendLog(jobId, `  - ${t}: ${count} rows (from ${table})\n`);
                } catch (e: any) {
                    await new Promise((r) => ws.end(r));
                    await this.appendLog(jobId, `  - ${t}: error reading ${table} → ${e?.message || e}; skipped\n`);
                    manifest.counts[t] = 0;
                }
            }

            // Create archive (.tar.gz)
            const archiveName = `backup_${new Date()
                .toISOString()
                .replace(/[:]/g, "-")
                .replace(/\..+/, "")}.tar.gz`;
            const archivePath = path.join(tmpRoot, archiveName);
            await this.createTarGz(exportDir, archivePath);

            const stat = await fsp.stat(archivePath);
            await this.appendLog(jobId, `Archive created: ${archiveName} (${stat.size} bytes)\n`);

            // Upload primary destination
            const dest = cfg.destination as any;
            let artifactLoc: any = null;
            let successCount = 0;

            if (dest.kind === "local") {
                const full = path.join(dest.path, path.basename(archivePath));
                await ensureDir(dest.path);
                await fsp.copyFile(archivePath, full);
                artifactLoc = { kind: "local", path: full };
                await this.appendLog(jobId, `Saved to local path: ${full}\n`);
                successCount += 1;
            } else if (dest.kind === "s3") {
                const cid = dest.connectionId;
                const conn = (
                    await this.db.query(
                        `SELECT config, secrets
               FROM storage_connections
              WHERE id=$1 AND kind='s3'`,
                        [cid]
                    )
                ).rows[0];
                if (!conn) throw new Error("S3 connection not found");
                const cfgS3 = { ...(conn.config || {}), ...(conn.secrets || {}) };
                const bucket = dest.bucket || cfgS3.bucket;
                if (!bucket) throw new Error("S3 bucket not specified");
                const prefix = (dest.prefix || cfgS3.prefix || "").replace(/^\/+|\/+$/g, "");
                const key = (prefix ? `${prefix}/` : "") + path.basename(archivePath);
                await s3PutObject(cfgS3, bucket, key, fs.createReadStream(archivePath));
                await s3Head(cfgS3, bucket, key);
                artifactLoc = {
                    kind: "s3",
                    bucket,
                    key,
                    connectionId: cid,
                    region: cfgS3.region,
                    endpoint: cfgS3.endpoint,
                };
                await this.appendLog(jobId, `Uploaded to s3://${bucket}/${key}\n`);
                successCount += 1;
            } else if (dest.kind === "nextcloud") {
                const cid = dest.connectionId;
                const conn = (
                    await this.db.query(
                        `SELECT config, secrets
               FROM storage_connections
              WHERE id=$1 AND kind='nextcloud'`,
                        [cid]
                    )
                ).rows[0];
                if (!conn) throw new Error("Nextcloud connection not found");
                const webdavUrl = conn.config?.webdavUrl;
                const username = conn.config?.username;
                const password = conn.secrets?.password;
                const directory = String(dest.path || conn.config?.path || "/").trim();
                if (!webdavUrl || !username || !password) {
                    throw new Error("Nextcloud connection incomplete (need webdavUrl, username, password)");
                }
                const remotePath = await webdavUpload({
                    url: webdavUrl,
                    username,
                    password,
                    directory,
                    filename: path.basename(archivePath),
                    body: fs.createReadStream(archivePath),
                });
                artifactLoc = { kind: "nextcloud", connectionId: cid, path: remotePath };
                await this.appendLog(jobId, `Uploaded to Nextcloud ${remotePath}\n`);
                successCount += 1;
            } else if (dest.kind === "gdrive") {
                const cid = dest.connectionId;
                const conn = (
                    await this.db.query(
                        `SELECT config, secrets
               FROM storage_connections
              WHERE id=$1 AND kind='gdrive'`,
                        [cid]
                    )
                ).rows[0];
                if (!conn) throw new Error("GDrive connection not found");

                const credentialsJson = conn.secrets?.serviceAccountJson;
                const folderId: string | undefined = conn.config?.folderId;
                if (!credentialsJson || !folderId) {
                    throw new Error("GDrive connection incomplete (missing service account JSON or folderId)");
                }

                const { fileId } = await gdriveUpload({
                    credentialsJson,
                    folderId,
                    subfolder: dest.subfolder || undefined,
                    name: path.basename(archivePath),
                    body: fs.createReadStream(archivePath),
                });

                artifactLoc = {
                    kind: "gdrive",
                    connectionId: cid,
                    fileId,
                    name: path.basename(archivePath),
                };
                await this.appendLog(jobId, `Uploaded to Google Drive fileId=${fileId}\n`);
                successCount += 1;
            } else {
                // Primary kinds not supported (guarded by service), but double-check here
                throw new Error(`Destination kind '${dest.kind}' not supported for primary upload`);
            }

            // ---- Fan-out to extra destinations (replication) ----
            const replicaOk = await this.replicateExtras(
                jobId,
                cfg.extras || [],
                archivePath,
                path.basename(archivePath),
                cfg.parallelism ?? 2
            );
            successCount += replicaOk;

            // Enforce minSuccess if provided
            if (cfg.minSuccess && successCount < cfg.minSuccess) {
                throw new Error(`Only ${successCount} destination(s) succeeded; required minSuccess=${cfg.minSuccess}`);
            }

            // Save manifest & finalize
            await this.db.query(
                `INSERT INTO backup_job_manifests (job_id, manifest) VALUES ($1, $2)
         ON CONFLICT (job_id) DO UPDATE SET manifest=$2`,
                [jobId, JSON.stringify(manifest)]
            );

            const durationSec = Math.max(1, Math.round((Date.now() - started) / 1000));
            await this.db.query(
                `UPDATE backup_jobs
           SET finished_at=NOW(),
               status='completed',
               size_bytes=$2,
               duration_sec=$3,
               verified=true,
               artifact_location=$4
         WHERE id=$1`,
                [jobId, stat.size, durationSec, JSON.stringify(artifactLoc)]
            );

            await this.appendLog(jobId, `Done in ${durationSec}s\n`);

            // Notify (best-effort)
            await this.notify(
                cfg.notifications,
                `Backup ${jobId} success`,
                `Size=${stat.size} Duration=${durationSec}s DestinationsOK=${successCount}`
            );
        } catch (e: any) {
            this.log.error(`Backup job ${jobId} failed: ${e?.message || e}`);
            await this.fail(jobId, e?.message || "Worker error");
            try {
                await this.notify(
                    cfg?.notifications ?? {},
                    `Backup ${jobId} failed`,
                    e?.message || "Worker error"
                );
            } catch { }
        } finally {
            // cleanup temp
            try {
                await fsp.rm(tmpRoot, { recursive: true, force: true });
            } catch { }
        }
    }

    private async fail(jobId: string, note: string) {
        await this.db.query(
            `UPDATE backup_jobs
          SET status='failed',
              finished_at=NOW(),
              note=$2
        WHERE id=$1`,
            [jobId, note]
        );
    }

    private async createTarGz(srcDir: string, outFile: string) {
        await new Promise<void>((resolve, reject) => {
            const output = fs.createWriteStream(outFile);
            const archive = archiver("tar", { gzip: true, gzipOptions: { level: 9 } });
            output.on("close", () => resolve());
            archive.on("error", (err) => reject(err));
            archive.pipe(output);
            archive.directory(srcDir, false);
            archive.finalize().catch(reject);
        });
    }

    /**
     * Map a logical target to candidate DB objects and return the first that exists.
     */
    private async resolveExistingTableForTarget(jobId: string, target: string): Promise<string | null> {
        const candidatesByTarget: Record<string, string[]> = {
            users: ["public.users", "users"],
            roles: ["public.roles", "roles"],
            devices: ["public.devices", "devices"],
            policies: ["public.policies", "policies"],
            audit_logs: ["public.audit_logs", "audit_logs", "public.auditlog", "auditlog"],
            settings: ["public.settings", "settings", "public.app_settings", "app_settings", "public.system_settings", "system_settings"],
            templates: ["public.templates", "templates"],
        };

        const candidates = candidatesByTarget[target] || [];
        for (const ident of candidates) {
            const reg = await this.db.query(`SELECT to_regclass($1) AS oid`, [ident]);
            const exists = !!reg.rows?.[0]?.oid;
            if (exists) return ident;
        }
        await this.appendLog(jobId, `    (no table/view found for target "${target}")\n`);
        return null;
    }

    /**
     * Load job config including the primary destination and fan-out destinations.
     */
    private async loadJobConfig(jobId: string): Promise<JobConfig | null> {
        const head = await this.db.query(
            `SELECT j.id,
              p.options,
              d.configuration AS destination_configuration
         FROM backup_jobs j
    LEFT JOIN backup_policies p ON j.policy_id = p.id
    LEFT JOIN backup_destinations d ON d.id = p.destination_id
        WHERE j.id=$1`,
            [jobId]
        );
        if (!head.rows.length) return null;

        const options = head.rows[0].options && typeof head.rows[0].options === "object" ? head.rows[0].options : {};
        if (options.enabled === false) return null;

        const destination = head.rows[0].destination_configuration || {};
        if (!destination.kind) return null;

        const targets = Array.isArray(options.targets) ? options.targets.filter(Boolean) : [];
        const notifications =
            options.notifications && typeof options.notifications === "object" ? options.notifications : {};
        const minSuccess =
            options.minSuccess != null ? Number(options.minSuccess) : undefined;
        const parallelism =
            options.parallelism != null ? Number(options.parallelism) : undefined;

        const extraRows = await this.db.query(
            `SELECT bjd.is_primary, bd.configuration
         FROM backup_job_destinations bjd
         JOIN backup_destinations bd ON bd.id = bjd.destination_id
        WHERE bjd.job_id=$1
        ORDER BY bjd.is_primary DESC, bjd.priority ASC`,
            [jobId]
        );

        const extras: FanoutDest[] = extraRows.rows
            .filter((r) => !r.is_primary)
            .map((r) => r.configuration as FanoutDest);

        return { targets, destination, notifications, extras, minSuccess, parallelism };
    }

    private async notify(
        channels: { email?: boolean; slack?: boolean; webhook?: boolean },
        subject: string,
        body: string
    ) {
        try {
            await this.notifier.send(channels || {}, subject, body);
        } catch (e) {
            this.log.warn(`Notify failed: ${e}`);
        }
    }

    /**
     * Copy/upload the finished archive to each extra destination. Best-effort:
     * returns how many succeeded. Runs with bounded concurrency.
     */
    private async replicateExtras(
        jobId: string,
        extras: FanoutDest[],
        localArchivePath: string,
        finalFileName: string,
        parallelism = 2
    ): Promise<number> {
        if (!extras?.length) return 0;

        const ordered = [...extras].sort((a, b) => (a.priority ?? 1000) - (b.priority ?? 1000));

        const tasks = ordered.map((dest) => async () => {
            try {
                if (dest.kind === "local") {
                    const out = path.join(dest.path, finalFileName);
                    await ensureDir(dest.path);
                    await fsp.copyFile(localArchivePath, out);
                    await this.appendLog(jobId, `[replica:local] ${out}\n`);
                    return true;
                } else if (dest.kind === "s3") {
                    const row = (
                        await this.db.query(
                            `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='s3'`,
                            [dest.connectionId]
                        )
                    ).rows[0];
                    if (!row) throw new Error("S3 connection not found");
                    const s3Cfg = { ...(row.config || {}), ...(row.secrets || {}) };
                    const bucket = dest.bucket || s3Cfg.bucket;
                    if (!bucket) throw new Error("S3 bucket missing");
                    const prefix = (dest.prefix || s3Cfg.prefix || "").replace(/^\/+|\/+$/g, "");
                    const key = (prefix ? `${prefix}/` : "") + finalFileName;
                    await s3PutObject(s3Cfg, bucket, key, fs.createReadStream(localArchivePath));
                    await this.appendLog(jobId, `[replica:s3] s3://${bucket}/${key}\n`);
                    return true;
                } else if (dest.kind === "nextcloud") {
                    const row = (
                        await this.db.query(
                            `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='nextcloud'`,
                            [dest.connectionId]
                        )
                    ).rows[0];
                    if (!row) throw new Error("Nextcloud connection not found");
                    const webdavUrl = row.config?.webdavUrl;
                    const username = row.config?.username;
                    const password = row.secrets?.password;
                    if (!webdavUrl || !username || !password || !dest.path) {
                        throw new Error("Nextcloud config incomplete");
                    }
                    await webdavUpload({
                        url: webdavUrl,
                        username,
                        password,
                        directory: dest.path,
                        filename: finalFileName,
                        body: fs.createReadStream(localArchivePath),
                    });
                    await this.appendLog(jobId, `[replica:nextcloud] ${dest.path}/${finalFileName}\n`);
                    return true;
                } else if (dest.kind === "gdrive") {
                    const row = (
                        await this.db.query(
                            `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='gdrive'`,
                            [dest.connectionId]
                        )
                    ).rows[0];
                    if (!row) throw new Error("GDrive connection not found");
                    const credentialsJson = row.secrets?.serviceAccountJson;
                    const folderId: string | undefined = row.config?.folderId;
                    if (!credentialsJson || !folderId) throw new Error("GDrive connection incomplete");

                    await gdriveUpload({
                        credentialsJson,
                        folderId,
                        subfolder: dest.subfolder || undefined,
                        name: finalFileName,
                        body: fs.createReadStream(localArchivePath),
                    });
                    await this.appendLog(jobId, `[replica:gdrive] folderId=${folderId}${dest.subfolder ? `/${dest.subfolder}` : ""}/${finalFileName}\n`);
                    return true;
                } else if (dest.kind === "remote") {
                    await this.appendLog(jobId, `[replica:sftp] NOT IMPLEMENTED (skipped)\n`);
                    return false;
                } else {
                    await this.appendLog(jobId, `[replica:${(dest as any).kind}] Unknown kind (skipped)\n`);
                    return false;
                }
            } catch (err: any) {
                await this.appendLog(
                    jobId,
                    `[replica:${(dest as any).kind}] ERROR: ${(err?.message || String(err)).slice(0, 500)}\n`
                );
                return false;
            }
        });

        const settled = await this.pLimit(Math.max(1, Number(parallelism) || 2), tasks);
        return settled.reduce((ok, r) => ok + (r.status === "fulfilled" && r.value ? 1 : 0), 0);
    }
}


``r

--------------------------------------------------------------------------------
| Backend Â· Storage module (*.ts) |
--------------------------------------------------------------------------------

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\connection-import.util.ts

``r

// backend/src/storage/connection-import.util.ts

export type IncomingImport =
    | { connections: Array<any> }          // existing RMM import shape
    | Record<string, any>;                 // raw Google service_account JSON, etc.

/**
 * Accepts either:
 *  - { connections: [...] } (your existing bulk format)
 *  - raw Google service account JSON (type === "service_account")
 * Returns a normalized { connections: [...] } object.
 */
export function normalizeConnectionImport(input: IncomingImport) {
    // Already the expected wrapper
    if (input && typeof input === "object" && Array.isArray((input as any).connections)) {
        return input as { connections: Array<any> };
    }

    // Raw Google service account JSON
    if (input && typeof input === "object" && (input as any).type === "service_account") {
        const serviceAccountJson = input;

        // We default to Drive "root" so validation passes; user can set a specific Folder ID later in the UI.
        const conn = {
            kind: "gdrive",
            name: "Google Drive (service account)",
            config: {
                folderId: "root",
            },
            meta: {
                environment: "dev",
                tags: ["backup", "offsite"],
            },
            secrets: {
                serviceAccountJson,
            },
        };

        return { connections: [conn] };
    }

    throw new Error("Unsupported import format. Paste the Google service_account JSON or { connections: [...] }.");
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\organization-context.service.ts

``r

import { Injectable, Logger } from "@nestjs/common";
import { PgPoolService } from "./pg-pool.service";

function slugify(input: string): string {
    return input
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "")
        .replace(/--+/g, "-");
}

@Injectable()
export class OrganizationContextService {
    private readonly logger = new Logger(OrganizationContextService.name);
    private cachedOrgId: string | null = null;

    constructor(private readonly pg: PgPoolService) { }

    async getDefaultOrganizationId(): Promise<string> {
        if (this.cachedOrgId) return this.cachedOrgId;

        const configuredSlug = process.env.DEFAULT_ORGANIZATION_SLUG || "default";
        const slug = slugify(configuredSlug) || "default";
        const name = process.env.DEFAULT_ORGANIZATION_NAME || "Default Organization";

        try {
            const existing = await this.pg.query<{ id: string }>(
                `SELECT id FROM organizations WHERE slug = $1 LIMIT 1`,
                [slug],
            );
            if (existing.rows[0]?.id) {
                this.cachedOrgId = existing.rows[0].id;
                return this.cachedOrgId;
            }
        } catch (err) {
            this.logger.warn(`organizations table unavailable: ${(err as Error)?.message ?? err}`);
            throw err;
        }

        const insert = await this.pg.query<{ id: string }>(
            `INSERT INTO organizations (name, slug)
             VALUES ($1, $2)
             ON CONFLICT (slug) DO UPDATE
               SET name = EXCLUDED.name
             RETURNING id`,
            [name, slug],
        );

        const orgId = insert.rows[0].id;
        this.cachedOrgId = orgId;

        await this.pg.query(
            `INSERT INTO organization_settings (organization_id)
             VALUES ($1)
             ON CONFLICT (organization_id) DO NOTHING`,
            [orgId],
        );

        return orgId;
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\pg.bootstrap.ts

``r

// backend/src/storage/pg.bootstrap.ts
import { Injectable, OnModuleInit, Optional } from "@nestjs/common";
import { PgPoolService } from "./pg-pool.service";

/**
 * Optional bootstrap that applies env-based defaults at startup.
 * If PgPoolService isn’t present in the DI graph, this safely no-ops.
 */
@Injectable()
export class PgBootstrap implements OnModuleInit {
    constructor(@Optional() private readonly pg?: PgPoolService) { }

    onModuleInit() {
        if (!this.pg) {
            // Not wired yet (or not exported/imported). Don’t crash.
            console.warn("PgBootstrap: PgPoolService not found; skipping PG bootstrap.");
            return;
        }

        try {
            this.pg.configure({
                connectionString:
                    process.env.DATABASE_URL ||
                    process.env.PG_URL ||
                    "postgres://remoteiq:remoteiqpass@localhost:5432/remoteiq",
                ssl:
                    (process.env.DATABASE_SSL ?? "").toLowerCase() === "true"
                        ? { rejectUnauthorized: false }
                        : false,
                max: Number.isFinite(+process.env.DATABASE_POOL_MAX!)
                    ? Number(process.env.DATABASE_POOL_MAX)
                    : 10,
                min: Number.isFinite(+process.env.DATABASE_POOL_MIN!)
                    ? Number(process.env.DATABASE_POOL_MIN)
                    : 0,
            });
        } catch (e) {
            console.warn(
                "PgBootstrap: configure() failed:",
                (e as Error)?.message ?? e
            );
        }
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\pg-pool.service.ts

``r

//backend\src\storage\pg-pool.service.ts

import { Injectable, OnModuleDestroy } from "@nestjs/common";

// We use require() + loose typing to avoid the “Cannot use namespace … as a type” errors
// that can happen in some TS configs when importing from 'pg'.
const { Pool } = require("pg") as { Pool: any };

export type PgRuntimeConfig = {
    connectionString?: string;
    ssl?: boolean | object;
    max?: number;
    min?: number;
};

@Injectable()
export class PgPoolService implements OnModuleDestroy {
    private pool: any = null;
    private lastKey: string | null = null;

    /** Build a default config from env (used on first access if not configured) */
    private envConfig(): PgRuntimeConfig {
        const url =
            process.env.DATABASE_URL ||
            process.env.PG_URL ||
            "postgres://remoteiq:remoteiqpass@localhost:5432/remoteiq";

        const ssl =
            (process.env.DATABASE_SSL ?? "").toLowerCase() === "true" ? true : false;

        const max = Number.isFinite(+process.env.DATABASE_POOL_MAX!)
            ? Number(process.env.DATABASE_POOL_MAX)
            : 10;
        const min = Number.isFinite(+process.env.DATABASE_POOL_MIN!)
            ? Number(process.env.DATABASE_POOL_MIN)
            : 0;

        return { connectionString: url, ssl, max, min };
    }

    /** Create a stable key for the current config so we can know when to recreate the pool */
    private keyOf(cfg: PgRuntimeConfig): string {
        return JSON.stringify({
            cs: cfg.connectionString ?? "",
            ssl: cfg.ssl ? "1" : "0",
            max: cfg.max ?? 10,
            min: cfg.min ?? 0,
        });
    }

    private makePool(cfg: PgRuntimeConfig): any {
        const base: any = {
            connectionString: cfg.connectionString,
            max: cfg.max ?? 10,
            min: cfg.min ?? 0,
        };
        if (cfg.ssl) {
            base.ssl = cfg.ssl === true ? { rejectUnauthorized: false } : cfg.ssl;
        }
        return new Pool(base);
    }

    /** Ensure pool exists; create from env if needed */
    private ensurePool(): any {
        if (!this.pool) {
            const cfg = this.envConfig();
            this.lastKey = this.keyOf(cfg);
            this.pool = this.makePool(cfg);
        }
        return this.pool!;
    }

    /**
     * Called by admin bootstrap when the database config changes.
     * Recreates the pool if the effective config differs.
     */
    configure(cfg: PgRuntimeConfig) {
        const nextKey = this.keyOf(cfg);
        if (this.pool && this.lastKey === nextKey) return; // no-op

        // tear down previous pool
        if (this.pool) {
            try {
                this.pool.end().catch(() => { });
            } catch { }
            this.pool = null;
        }

        this.pool = this.makePool(cfg);
        this.lastKey = nextKey;
    }

    async query<T = any>(text: string, params?: any[]): Promise<{ rows: T[]; rowCount: number }> {
        const res = await this.ensurePool().query(text, params);
        return { rows: res.rows as T[], rowCount: typeof res.rowCount === "number" ? res.rowCount : 0 };
    }

    async onModuleDestroy() {
        if (this.pool) {
            try {
                await this.pool.end();
            } catch { }
            this.pool = null;
        }
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\storage.controller.ts

``r

import {
    Body,
    Controller,
    Delete,
    Get,
    Param,
    Post,
    Put,
    UseGuards,
} from "@nestjs/common";
import { StorageConnectionsService } from "./storage-connections.service";
import { PermissionsGuard } from "../auth/permissions.guard";
import { RequirePerm } from "../auth/require-perm.decorator";

@Controller("/api/admin/storage")
@UseGuards(PermissionsGuard)
export class StorageController {
    constructor(private readonly svc: StorageConnectionsService) { }

    @Get("connections")
    @RequirePerm("backups.manage")
    async list() {
        return this.svc.list();
    }

    @Post("connections")
    @RequirePerm("backups.manage")
    async create(@Body() body: any) {
        return this.svc.create(body);
    }

    @Put("connections/:id")
    @RequirePerm("backups.manage")
    async update(@Param("id") id: string, @Body() body: any) {
        await this.svc.update(id, body);
        return { ok: true };
    }

    @Delete("connections/:id")
    @RequirePerm("backups.manage")
    async remove(@Param("id") id: string) {
        await this.svc.delete(id);
        return { ok: true };
    }

    @Get("connections/:id/dependents")
    @RequirePerm("backups.manage")
    async dependents(@Param("id") id: string) {
        return this.svc.getDependents(id);
    }

    @Post("test")
    @RequirePerm("backups.manage")
    async test(@Body() body: any) {
        return this.svc.test(body);
    }

    @Post("browse")
    @RequirePerm("backups.manage")
    async browse(@Body() body: any) {
        return this.svc.browseNextcloud(body);
    }
}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\storage.module.ts

``r

// backend/src/storage/storage.module.ts

import { Module } from "@nestjs/common";
import { Reflector } from "@nestjs/core";
import { PermissionsGuard } from "../auth/permissions.guard";
import { PgBootstrap } from "./pg.bootstrap";
import { OrganizationContextService } from "./organization-context.service";
import { PgPoolService } from "./pg-pool.service";
import { StorageConnectionsService } from "./storage-connections.service";
import { StorageController } from "./storage.controller";
import { StorageImportController } from "./storage-import.controller";

@Module({
    controllers: [StorageController, StorageImportController],
    providers: [
        PgPoolService,
        PgBootstrap,
        OrganizationContextService,
        StorageConnectionsService,
        PermissionsGuard,
        Reflector,
    ],
    exports: [PgPoolService, OrganizationContextService, StorageConnectionsService],
})
export class StorageModule { }


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\storage-connections.service.ts

``r

import {
    BadRequestException,
    Injectable,
    NotFoundException,
} from "@nestjs/common";
import { PgPoolService } from "./pg-pool.service";
import { OrganizationContextService } from "./organization-context.service";
import { s3PutObject, s3Head, s3Delete, webdavProbe, webdavListDirs, sftpProbe } from "../backups/storage-clients";

type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";

type StorageConnectionRow = {
    id: string;
    organization_id: string;
    name: string;
    kind: StorageKind;
    config: Record<string, any> | null;
    secrets: Record<string, any> | null;
    meta: Record<string, any> | null;
    capabilities: Record<string, any> | null;
    health: Record<string, any> | null;
};

type StorageConnectionDto = {
    id: string;
    name: string;
    kind: StorageKind;
    config: Record<string, any>;
    meta: Record<string, any>;
    capabilities: Record<string, any>;
    health: Record<string, any>;
    hasSecret?: {
        s3Credentials?: boolean;
        nextcloudPassword?: boolean;
        sftpPassword?: boolean;
        sftpPrivateKey?: boolean;
    };
};

type SecretMap = Record<string, any>;

type CreateUpdatePayload = {
    id?: string;
    name: string;
    kind: StorageKind;
    config: Record<string, any>;
    meta?: Record<string, any>;
};

const ALLOWED_KINDS: StorageKind[] = ["s3", "nextcloud", "gdrive", "sftp"];

const DEFAULT_CAPABILITIES = {
    canUse: true,
    canEdit: true,
    canRotate: true,
    canDelete: true,
};

const DEFAULT_HEALTH = { status: "unknown" };

@Injectable()
export class StorageConnectionsService {
    constructor(
        private readonly db: PgPoolService,
        private readonly orgCtx: OrganizationContextService,
    ) { }

    private async orgId(): Promise<string> {
        return this.orgCtx.getDefaultOrganizationId();
    }

    private ensureKind(kind: string): asserts kind is StorageKind {
        if (!ALLOWED_KINDS.includes(kind as StorageKind)) {
            throw new BadRequestException(`Unsupported storage kind: ${kind}`);
        }
    }

    private clone<T>(value: T): T {
        return value ? JSON.parse(JSON.stringify(value)) : value;
    }

    private withDefaults(meta: Record<string, any> | null | undefined): Record<string, any> {
        const incoming = { ...(meta ?? {}) };
        const defaultFor = {
            backups: false,
            exports: false,
            artifacts: false,
            ...(incoming.defaultFor ?? {}),
        };
        const tags = Array.isArray(incoming.tags) ? incoming.tags : [];
        return {
            ...incoming,
            environment: incoming.environment ?? "dev",
            defaultFor,
            tags,
            encryptionAtRest: incoming.encryptionAtRest ?? false,
            compression: incoming.compression ?? "none",
        };
    }

    private sanitizeConfig(kind: StorageKind, config: Record<string, any> | null | undefined): Record<string, any> {
        const base = this.clone(config ?? {});
        if (kind === "s3") {
            if (!base.provider) base.provider = "aws";
            if (!base.region) base.region = "us-east-1";
            if (base.pathStyle === undefined) base.pathStyle = false;
            if (!base.sse) base.sse = "none";
        }
        if (kind === "nextcloud") {
            if (!base.path) base.path = "/Backups/RemoteIQ";
        }
        if (kind === "sftp") {
            if (!base.port) base.port = 22;
            if (!base.path) base.path = "/srv/remoteiq/backups";
        }
        return base;
    }

    private buildHasSecret(kind: StorageKind, secrets: SecretMap): StorageConnectionDto["hasSecret"] {
        const map: StorageConnectionDto["hasSecret"] = {};
        if (kind === "s3") {
            map.s3Credentials = Boolean(
                secrets.accessKeyId || secrets.secretAccessKey || secrets.roleArn,
            );
        }
        if (kind === "nextcloud") {
            map.nextcloudPassword = Boolean(secrets.password);
        }
        if (kind === "sftp") {
            map.sftpPassword = Boolean(secrets.password);
            map.sftpPrivateKey = Boolean(secrets.privateKeyPem);
        }
        return map;
    }

    private partitionSecrets(
        kind: StorageKind,
        configInput: Record<string, any>,
        existingSecrets: SecretMap = {},
    ): { config: Record<string, any>; secrets: SecretMap } {
        const config = this.clone(configInput ?? {});
        const secrets = { ...existingSecrets };

        const take = (key: string) => {
            if (!(key in config)) return;
            const value = config[key];
            if (value === undefined || value === null || value === "") {
                delete secrets[key];
            } else {
                secrets[key] = value;
            }
            delete config[key];
        };

        if (kind === "s3") {
            ["accessKeyId", "secretAccessKey", "roleArn", "externalId"].forEach(take);
        }
        if (kind === "nextcloud") {
            ["password"].forEach(take);
        }
        if (kind === "gdrive") {
            ["serviceAccountJson", "refreshToken", "clientSecret"].forEach(take);
        }
        if (kind === "sftp") {
            ["password", "privateKeyPem", "passphrase"].forEach(take);
        }

        return { config, secrets };
    }

    private rowToDto(row: StorageConnectionRow): StorageConnectionDto {
        const config = this.sanitizeConfig(row.kind, row.config);
        const meta = this.withDefaults(row.meta);
        const capabilities = { ...DEFAULT_CAPABILITIES, ...(row.capabilities ?? {}) };
        const health = { ...DEFAULT_HEALTH, ...(row.health ?? {}) };
        const secrets = row.secrets ?? {};
        const hasSecret = this.buildHasSecret(row.kind, secrets);

        return {
            id: row.id,
            name: row.name,
            kind: row.kind,
            config,
            meta,
            capabilities,
            health,
            hasSecret,
        };
    }

    private validatePayload(body: CreateUpdatePayload) {
        if (!body) throw new BadRequestException("Payload required");
        if (!body.name || typeof body.name !== "string" || !body.name.trim()) {
            throw new BadRequestException("Name is required");
        }
        this.ensureKind(body.kind);
        if (!body.config || typeof body.config !== "object") {
            throw new BadRequestException("Config object required");
        }

        if (body.kind === "s3") {
            if (!body.config.bucket || !String(body.config.bucket).trim()) {
                throw new BadRequestException("S3 bucket is required");
            }
            if (body.config.sse === "aws:kms" && !body.config.kmsKeyId) {
                throw new BadRequestException("KMS Key ID required for aws:kms");
            }
            if (body.config.sessionDurationSec) {
                const dur = Number(body.config.sessionDurationSec);
                if (!Number.isFinite(dur) || dur < 900 || dur > 43200) {
                    throw new BadRequestException(
                        "STS session duration must be between 900 and 43200 seconds",
                    );
                }
            }
        }

        if (body.kind === "nextcloud") {
            if (!body.config.webdavUrl || typeof body.config.webdavUrl !== "string") {
                throw new BadRequestException("Nextcloud WebDAV URL is required");
            }
            if (!body.config.username || !String(body.config.username).trim()) {
                throw new BadRequestException("Nextcloud username is required");
            }
            if (!body.config.path || !String(body.config.path).startsWith("/")) {
                throw new BadRequestException("Nextcloud folder path must start with '/'");
            }
        }

        if (body.kind === "gdrive") {
            if (!body.config.folderId || !String(body.config.folderId).trim()) {
                throw new BadRequestException("Google Drive folderId is required");
            }
        }

        if (body.kind === "sftp") {
            if (!body.config.host || !String(body.config.host).trim()) {
                throw new BadRequestException("SFTP host is required");
            }
            if (!body.config.username || !String(body.config.username).trim()) {
                throw new BadRequestException("SFTP username is required");
            }
            if (!body.config.path || !String(body.config.path).trim()) {
                throw new BadRequestException("SFTP path is required");
            }
        }
    }

    async list(): Promise<{ items: StorageConnectionDto[] }> {
        const orgId = await this.orgId();
        const { rows } = await this.db.query<StorageConnectionRow>(
            `SELECT id, organization_id, name, kind, config, secrets, meta, capabilities, health
             FROM storage_connections
             WHERE organization_id = $1
             ORDER BY name ASC`,
            [orgId],
        );
        return { items: rows.map((row) => this.rowToDto(row)) };
    }

    async create(body: CreateUpdatePayload): Promise<{ id: string }> {
        this.validatePayload(body);
        const orgId = await this.orgId();
        const { config, secrets } = this.partitionSecrets(body.kind, body.config);
        const meta = this.withDefaults(body.meta ?? {});
        const capabilities = DEFAULT_CAPABILITIES;
        const health = DEFAULT_HEALTH;

        const result = await this.db.query<{ id: string }>(
            `INSERT INTO storage_connections (organization_id, name, kind, config, secrets, meta, capabilities, health)
             VALUES ($1, $2, $3, $4::jsonb, $5::jsonb, $6::jsonb, $7::jsonb, $8::jsonb)
             RETURNING id`,
            [
                orgId,
                body.name.trim(),
                body.kind,
                JSON.stringify(config),
                JSON.stringify(secrets),
                JSON.stringify(meta),
                JSON.stringify(capabilities),
                JSON.stringify(health),
            ],
        );

        return { id: result.rows[0].id };
    }

    async update(id: string, body: CreateUpdatePayload): Promise<void> {
        if (!id || id.length !== 36) throw new BadRequestException("Valid id required");
        this.validatePayload(body);
        const orgId = await this.orgId();

        const existing = await this.db.query<StorageConnectionRow>(
            `SELECT id, organization_id, name, kind, config, secrets, meta, capabilities, health
             FROM storage_connections
             WHERE id=$1 AND organization_id=$2`,
            [id, orgId],
        );
        const row = existing.rows[0];
        if (!row) throw new NotFoundException("Connection not found");

        this.ensureKind(body.kind);
        const { config, secrets } = this.partitionSecrets(body.kind, body.config, row.secrets ?? {});
        const meta = this.withDefaults(body.meta ?? {});

        await this.db.query(
            `UPDATE storage_connections
             SET name=$2,
                 kind=$3,
                 config=$4::jsonb,
                 secrets=$5::jsonb,
                 meta=$6::jsonb,
                 updated_at=NOW()
             WHERE id=$1 AND organization_id=$7`,
            [
                id,
                body.name.trim(),
                body.kind,
                JSON.stringify(config),
                JSON.stringify(secrets),
                JSON.stringify(meta),
                orgId,
            ],
        );
    }

    async delete(id: string): Promise<void> {
        if (!id || id.length !== 36) throw new BadRequestException("Valid id required");
        const orgId = await this.orgId();

        const deps = await this.getDependents(id);
        const inUse = deps.features.flatMap((f) => f.ids ?? []);
        if (inUse.length) {
            throw new BadRequestException("Connection still referenced by other features");
        }

        const result = await this.db.query<{ id: string }>(
            `DELETE FROM storage_connections
             WHERE id=$1 AND organization_id=$2
             RETURNING id`,
            [id, orgId],
        );
        if (!result.rows.length) throw new NotFoundException("Connection not found");
    }

    async getDependents(id: string): Promise<{ features: { name: string; ids: string[] }[] }> {
        const orgId = await this.orgId();
        const deps: { name: string; ids: string[] }[] = [];

        const policies = await this.db.query<{ id: string }>(
            `SELECT id
             FROM backup_destinations
             WHERE organization_id=$1 AND configuration ->> 'connectionId' = $2`,
            [orgId, id],
        );
        if (policies.rows.length) {
            deps.push({ name: "backup_destinations", ids: policies.rows.map((r) => r.id) });
        }

        return { features: deps };
    }

    async test(body: { id?: string; kind: StorageKind; config: Record<string, any> }): Promise<{ ok: boolean; phases: Record<string, boolean> }> {
        this.ensureKind(body.kind);
        let cfg = { ...(body.config || {}) };

        if (body.id) {
            const orgId = await this.orgId();
            const res = await this.db.query<StorageConnectionRow>(
                `SELECT id, kind, config, secrets
                   FROM storage_connections
                  WHERE id=$1 AND organization_id=$2`,
                [body.id, orgId],
            );
            const row = res.rows[0];
            if (row && row.kind === body.kind) {
                const savedCfg = row.config || {};
                const secrets = row.secrets || {};
                cfg = { ...savedCfg, ...cfg };
                if (body.kind === "nextcloud") {
                    if (!cfg.password && secrets.password) cfg.password = secrets.password;
                }
                if (body.kind === "s3") {
                    if (!cfg.accessKeyId && secrets.accessKeyId) cfg.accessKeyId = secrets.accessKeyId;
                    if (!cfg.secretAccessKey && secrets.secretAccessKey) cfg.secretAccessKey = secrets.secretAccessKey;
                    if (!cfg.roleArn && secrets.roleArn) cfg.roleArn = secrets.roleArn;
                    if (!cfg.externalId && secrets.externalId) cfg.externalId = secrets.externalId;
                }
                if (body.kind === "sftp") {
                    if (!cfg.password && secrets.password) cfg.password = secrets.password;
                    if (!cfg.privateKeyPem && secrets.privateKeyPem) cfg.privateKeyPem = secrets.privateKeyPem;
                    if (!cfg.passphrase && secrets.passphrase) cfg.passphrase = secrets.passphrase;
                }
            }
        }

        this.validatePayload({ name: "test", kind: body.kind, config: cfg });

        if (body.kind === "s3") {
            const bucket = cfg.bucket;
            const prefix = (cfg.prefix || "").replace(/^\/+|\/+$/g, "");
            const key = (prefix ? `${prefix}/` : "") + `.remoteiq_probe_${Date.now()}.txt`;
            const secret = {
                region: cfg.region,
                endpoint: cfg.endpoint,
                accessKeyId: cfg.accessKeyId,
                secretAccessKey: cfg.secretAccessKey,
                forcePathStyle: !!cfg.pathStyle,
            };
            await s3PutObject(secret, bucket, key, Buffer.from("probe"));
            const head = await s3Head(secret, bucket, key);
            const ok = !!head;
            await s3Delete(secret, bucket, key);
            return { ok, phases: { validate: true, write: true, read: ok, delete: true } };
        }

        if (body.kind === "nextcloud") {
            const phases = await webdavProbe({
                url: cfg.webdavUrl,
                username: cfg.username,
                password: cfg.password,
                path: cfg.path,
            });
            return { ok: phases.write && phases.read && phases.delete, phases: { validate: true, ...phases } };
        }

        if (body.kind === "sftp") {
            const phases = await sftpProbe({
                host: cfg.host,
                port: cfg.port ?? 22,
                username: cfg.username,
                password: cfg.password,
                privateKey: cfg.privateKeyPem,
                passphrase: cfg.passphrase,
                testPath: cfg.path,
            });
            return { ok: phases.write && phases.read && phases.delete, phases: { validate: true, ...phases } };
        }

        return { ok: true, phases: { validate: true, connect: true } };
    }

    // === UPDATED: hydrate secrets when browsing ===
    // backend/src/storage/storage-connections.service.ts
    async browseNextcloud(body: {
        connectionId?: string;
        config?: Record<string, any>;
        path: string;
    }): Promise<{ ok: boolean; dirs: string[] }> {
        if (!body?.path || !String(body.path).startsWith("/")) {
            throw new BadRequestException("Path must start with '/'");
        }

        const cfg = { ...(body.config ?? {}) };

        if (body.connectionId) {
            const orgId = await this.orgId();
            const { rows } = await this.db.query<{
                id: string; kind: string; config: any; secrets: any;
            }>(
                `SELECT id, kind, config, secrets
       FROM storage_connections
       WHERE id=$1 AND organization_id=$2`,
                [body.connectionId, orgId],
            );
            const row = rows[0];
            if (!row) throw new NotFoundException("Connection not found");
            if (row.kind !== "nextcloud") throw new BadRequestException("Connection is not Nextcloud/WebDAV");

            // Always prefer stored config + secret when id is provided
            const storedCfg = this.sanitizeConfig("nextcloud", row.config || {});
            cfg.webdavUrl = storedCfg.webdavUrl;
            cfg.username = storedCfg.username;
            cfg.password = row.secrets?.password; // <- use saved secret
        }

        if (!cfg.webdavUrl || !cfg.username || !cfg.password) {
            throw new BadRequestException("webdavUrl, username, and password are required to browse.");
        }

        const dirs = await webdavListDirs({
            url: cfg.webdavUrl,
            username: cfg.username,
            password: cfg.password,
            basePath: body.path,
        });
        return { ok: true, dirs };
    }

}


``r

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\storage-import.controller.ts

``r

// backend/src/storage/storage-import.controller.ts

import {
    BadRequestException,
    Body,
    Controller,
    HttpCode,
    Post,
} from "@nestjs/common";
import { StorageConnectionsService } from "./storage-connections.service";
import { normalizeConnectionImport } from "./connection-import.util";

/**
 * Narrow, literal union matching StorageConnectionsService's internal StorageKind.
 * (We redeclare it here to avoid importing private types.)
 */
type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";

/** Map any free-form input to our supported StorageKind (typed). */
function normalizeKind(input: any): StorageKind {
    const k = String(input || "")
        .toLowerCase()
        .replace(/\s+/g, "");

    if (k === "gdrive" || k === "googledrive") return "gdrive";
    if (k === "s3" || k === "aws" || k === "minio") return "s3";
    if (k === "nextcloud" || k === "webdav") return "nextcloud";
    if (k === "sftp" || k === "remote") return "sftp";

    // Default sensibly for raw service_account imports
    if (!k) return "gdrive";

    throw new BadRequestException(`Unsupported kind: ${input}`);
}

@Controller("api/storage/connections")
export class StorageImportController {
    constructor(private readonly svc: StorageConnectionsService) { }

    /**
     * Accepts:
     *  - Raw Google service_account JSON (pasted from Google)
     *  - { connections: [...] } in your native format
     *
     * Creates storage_connections using the existing service.
     */
    @Post("import")
    @HttpCode(200)
    async import(@Body() body: any) {
        let normalized: { connections: Array<any> };
        try {
            normalized = normalizeConnectionImport(body);
        } catch (e: any) {
            throw new BadRequestException(e?.message || "Invalid import payload");
        }

        const results: Array<{ id: string; name: string; kind: StorageKind }> = [];

        for (const raw of normalized.connections) {
            const kind: StorageKind = normalizeKind(raw.kind ?? "gdrive");
            const name = String(raw.name || `Imported ${kind} ${Date.now()}`);

            // Build config; ensure required fields exist for each kind
            const config: Record<string, any> = { ...(raw.config || {}) };

            if (kind === "gdrive") {
                // folderId needed by service validation; default to root
                if (!config.folderId || !String(config.folderId).trim()) {
                    config.folderId = "root";
                }
            }

            const meta = raw.meta || {};

            // Move "secrets" (e.g., serviceAccountJson) into config; the service
            // will strip and store them in secrets via partitionSecrets().
            if (raw.secrets && typeof raw.secrets === "object") {
                Object.assign(config, raw.secrets);
            }

            const { id } = await this.svc.create({
                name,
                kind,       // <- now typed as StorageKind, no TS2322
                config,
                meta,
            });

            results.push({ id, name, kind });
        }

        return { ok: true, imported: results.length, connections: results };
    }
}


``r

--------------------------------------------------------------------------------
| Frontend Â· BackupsTab.tsx |
--------------------------------------------------------------------------------

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-frontend\app\administration\tabs\BackupsTab.tsx

``r

"use client";

import * as React from "react";
import {
    Card, CardHeader, CardTitle, CardDescription, CardContent,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { TabsContent } from "@/components/ui/tabs";
import {
    Select, SelectTrigger, SelectValue, SelectContent, SelectItem,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Input } from "@/components/ui/input";
import {
    ArchiveRestore, Download, RefreshCcw, FileText, Shield, RotateCcw,
    XCircle, Repeat2, Filter, Trash2, Info, ListChecks, MoreVertical, Plus, Trash,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { LabeledInput, LabeledNumber, CheckToggle } from "../helpers";
import {
    getBackupConfig, updateBackupConfig, getBackupPermissions,
    listStorageConnectionsLite, listBackupHistory,
    runBackupNow as apiRunBackupNow, pruneBackups as apiPruneBackups,
    testBackupDestination, retryBackup, cancelBackup, startRestore,
    getCronNextRuns,
    type BackupConfig as ApiBackupConfig,
    type BackupHistoryRow, type BackupTarget, type Destination as ApiDestination,
    type LocalDest, type S3Dest, type NextcloudDest, type GDriveDest,
    type RemoteSFTPDest, type ConnectionLite, type StorageKind,
    type Permissions, type ScheduleKind,
} from "@/lib/backups";
import {
    AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent,
    AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { useToast, type ToastOptions } from "@/components/ui/use-toast";
import {
    DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem,
    DropdownMenuLabel, DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";

type Dest = ApiDestination;
type HistoryStatus = "any" | "success" | "failed" | "running";

type FanoutDest =
    | { kind: "local"; path: string; isPrimary?: boolean; priority?: number }
    | { kind: "s3"; connectionId: string; bucket?: string; prefix?: string; isPrimary?: boolean; priority?: number }
    | { kind: "nextcloud"; connectionId: string; path: string; isPrimary?: boolean; priority?: number }
    | { kind: "gdrive"; connectionId: string; subfolder?: string; isPrimary?: boolean; priority?: number }
    | { kind: "remote"; connectionId: string; path: string; isPrimary?: boolean; priority?: number };

type ConfigState = {
    enabled: boolean;
    targets: BackupTarget[];
    schedule: ScheduleKind;
    cronExpr: string;
    retentionDays: number | "";
    encrypt: boolean;
    destination: Dest;
    /** NEW */
    extraDestinations: FanoutDest[];
    notifications?: { email?: boolean; webhook?: boolean; slack?: boolean };
    /** hints */
    minSuccess?: number | "";
    parallelism?: number | "";
};

const TZ = "America/New_York";

/* ---------------- helpers ---------------- */

function isValidCron(expr: string) {
    return /^(\S+\s+){4}\S+$/.test((expr || "").trim());
}

function humanNextRun(schedule: ScheduleKind) {
    try {
        const now = new Date();
        const localNow = new Date(now.toLocaleString("en-US", { timeZone: TZ }));

        if (schedule === "hourly") {
            const list: string[] = [];
            let cursor = new Date(localNow);
            cursor.setMinutes(0, 0, 0);
            if (localNow.getMinutes() > 0 || localNow.getSeconds() > 0)
                cursor.setHours(cursor.getHours() + 1);
            for (let i = 0; i < 5; i++) {
                list.push(cursor.toLocaleString("en-US", {
                    timeZone: TZ, weekday: "short", hour: "2-digit", minute: "2-digit",
                }));
                cursor.setHours(cursor.getHours() + 1);
            }
            return list;
        }

        if (schedule === "daily") {
            const list: string[] = [];
            let cursor = new Date(localNow);
            cursor.setHours(3, 0, 0, 0);
            if (localNow >= cursor) cursor.setDate(cursor.getDate() + 1);
            for (let i = 0; i < 5; i++) {
                list.push(cursor.toLocaleString("en-US", {
                    timeZone: TZ, weekday: "short", hour: "2-digit", minute: "2-digit",
                }));
                cursor.setDate(cursor.getDate() + 1);
            }
            return list;
        }

        if (schedule === "weekly") {
            const list: string[] = [];
            let cursor = new Date(localNow);
            cursor.setHours(3, 0, 0, 0);
            const day = cursor.getDay();
            const add = (7 - day) % 7 || (localNow >= cursor ? 7 : 0);
            cursor.setDate(cursor.getDate() + add);
            if (localNow >= cursor) cursor.setDate(cursor.getDate() + 7);
            for (let i = 0; i < 5; i++) {
                list.push(cursor.toLocaleString("en-US", {
                    timeZone: TZ, weekday: "long", hour: "2-digit", minute: "2-digit",
                }));
                cursor.setDate(cursor.getDate() + 7);
            }
            return list;
        }

        if (schedule === "cron") return null;
    } catch { }
    return [];
}

function validateDest(d: FanoutDest): string[] {
    const errs: string[] = [];
    switch (d.kind) {
        case "local":
            if (!d.path) errs.push("Local path required");
            else {
                const abs = d.path.startsWith("/") || /^[A-Za-z]:\\/.test(d.path);
                if (!abs) errs.push("Local path must be absolute");
            }
            break;
        case "nextcloud":
            if (!("connectionId" in d) || !d.connectionId) errs.push("Nextcloud connection required");
            if (!d.path || !d.path.startsWith("/")) errs.push("Nextcloud path should start with '/'");
            break;
        case "remote":
            if (!("connectionId" in d) || !d.connectionId) errs.push("SFTP connection required");
            if (!d.path) errs.push("Remote directory path required");
            else {
                const abs = d.path.startsWith("/") || /^[A-Za-z]:\\/.test(d.path);
                if (!abs) errs.push("Remote directory path must be absolute");
            }
            break;
        case "s3":
            if (!("connectionId" in d) || !d.connectionId) errs.push("S3 connection required");
            break;
        case "gdrive":
            if (!("connectionId" in d) || !d.connectionId) errs.push("Google Drive connection required");
            break;
    }
    return errs;
}

function validateConfig(c: ConfigState): string[] {
    const errs: string[] = [];
    const days = Number(c.retentionDays);
    if (!Number.isFinite(days) || days < 1 || days > 3650)
        errs.push("Retention days must be between 1 and 3650.");
    if (c.schedule === "cron" && !isValidCron(c.cronExpr))
        errs.push("Cron expression looks invalid.");
    if (!c.targets.length) errs.push("Select at least one backup target.");

    // primary
    errs.push(...validateDest(c.destination as FanoutDest));

    // extras
    for (const e of c.extraDestinations) errs.push(...validateDest(e));

    if (c.minSuccess != null && Number(c.minSuccess) < 1) errs.push("Min success must be >= 1");
    if (c.parallelism != null && Number(c.parallelism) < 1) errs.push("Parallelism must be >= 1");
    return errs;
}

/* ---------------- component ---------------- */

export default function BackupsTab({ push }: { push?: (opts: ToastOptions) => void; }) {
    const { toast } = useToast();
    const notify = React.useMemo(() => push ?? toast, [push, toast]);

    const [loading, setLoading] = React.useState(true);
    const [saving, setSaving] = React.useState(false);
    const [running, setRunning] = React.useState(false);
    const [testingDest, setTestingDest] = React.useState(false);
    const [restoreId, setRestoreId] = React.useState<string | null>(null);
    const [restoreConfirm, setRestoreConfirm] = React.useState("");

    const [errors, setErrors] = React.useState<string[]>([]);

    const [backups, setBackups] = React.useState<ConfigState>({
        enabled: false,
        targets: [],
        schedule: "daily",
        cronExpr: "0 3 * * *",
        retentionDays: 30,
        encrypt: true,
        destination: { kind: "local", path: "/var/remoteiq/backups" } as LocalDest,
        extraDestinations: [],
        notifications: { email: false, webhook: false, slack: false },
        minSuccess: 1,
        parallelism: 2,
    });

    const [perms, setPerms] = React.useState<Permissions>({ restore: false, download: false });
    const [connAll, setConnAll] = React.useState<ConnectionLite[]>([]);
    const [selectedConnId, setSelectedConnId] = React.useState<string>("");

    // history
    const [historyLoading, setHistoryLoading] = React.useState(true);
    const [historyRaw, setHistoryRaw] = React.useState<BackupHistoryRow[]>([]);
    const [historyView, setHistoryView] = React.useState<BackupHistoryRow[]>([]);
    const [cursor, setCursor] = React.useState<string | null>(null);
    const [cursorStack, setCursorStack] = React.useState<string[]>([]);
    const [nextCursor, setNextCursor] = React.useState<string | null>(null);

    const [statusFilter, setStatusFilter] = React.useState<HistoryStatus>("any");
    const [search, setSearch] = React.useState("");
    const [dateFrom, setDateFrom] = React.useState<string>("");
    const [dateTo, setDateTo] = React.useState<string>("");

    const nextRunList = humanNextRun(backups.schedule);
    const [cronNextRuns, setCronNextRuns] = React.useState<string[] | null>(null);

    /* ------ load config + perms + connections ------ */
    const connsFor = (k: Dest["kind"]) => {
        const map: Record<Dest["kind"], StorageKind | null> = {
            local: null, s3: "s3", nextcloud: "nextcloud", gdrive: "gdrive", remote: "sftp",
        };
        const want = map[k];
        if (!want) return [];
        return connAll.filter((c) => c.kind === want);
    };

    const loadConfig = React.useCallback(async () => {
        try {
            const cfg = await getBackupConfig();
            const inDest: any = (cfg as any).destination || {};
            const extras: any[] = Array.isArray((cfg as any).extraDestinations) ? (cfg as any).extraDestinations : [];

            function mapIn(d: any): FanoutDest {
                switch (d?.kind) {
                    case "s3": return { kind: "s3", connectionId: d.connectionId ?? "", bucket: d.bucket ?? "", prefix: d.prefix ?? "" };
                    case "nextcloud": return { kind: "nextcloud", connectionId: d.connectionId ?? "", path: d.path ?? "/Backups/RemoteIQ" };
                    case "gdrive": return { kind: "gdrive", connectionId: d.connectionId ?? "", subfolder: d.subfolder ?? "" };
                    case "remote": return { kind: "remote", connectionId: d.connectionId ?? "", path: d.path ?? "/srv/remoteiq/backups" };
                    case "local":
                    default: return { kind: "local", path: d?.path ?? "/var/remoteiq/backups" };
                }
            }

            const dest = mapIn(inDest) as Dest;
            const extrasMapped = extras.map(mapIn);

            // set selectedConnId only for connection-backed kinds
            const connId =
                ("connectionId" in dest && (dest as any).connectionId) ? (dest as any).connectionId : "";

            setBackups({
                enabled: !!cfg.enabled,
                targets: (cfg.targets as BackupTarget[]) ?? [],
                schedule: (cfg.schedule as ScheduleKind) ?? "daily",
                cronExpr: cfg.cronExpr || "0 3 * * *",
                retentionDays: typeof cfg.retentionDays === "number" ? cfg.retentionDays : 30,
                encrypt: !!cfg.encrypt,
                destination: dest,
                extraDestinations: extrasMapped,
                notifications: (cfg as any).notifications ?? { email: false, webhook: false, slack: false },
                minSuccess: (cfg as any).minSuccess ?? 1,
                parallelism: (cfg as any).parallelism ?? 2,
            });
            setSelectedConnId(connId);
            setErrors([]);
        } catch (e: any) {
            notify({ title: e?.message || "Failed to load backup config", kind: "destructive", variant: "destructive" });
        } finally {
            setLoading(false);
        }
    }, [notify]);

    const loadPerms = React.useCallback(async () => {
        try {
            const p = await getBackupPermissions();
            if (p) setPerms({ restore: !!p.restore, download: !!p.download });
        } catch (e: any) {
            notify({ title: e?.message || "Failed to load backup permissions", kind: "destructive", variant: "destructive" });
        }
    }, [notify]);

    const loadConnections = React.useCallback(async () => {
        try {
            const res = await listStorageConnectionsLite();
            setConnAll(res?.items ?? []);
        } catch (e: any) {
            notify({ title: e?.message || "Failed to load storage connections", kind: "destructive", variant: "destructive" });
        }
    }, [notify]);

    React.useEffect(() => {
        loadConfig();
        loadPerms();
        loadConnections();
    }, [loadConfig, loadPerms, loadConnections]);

    /* ---------- history ---------- */
    const loadHistory = React.useCallback(
        async (cur?: string | null) => {
            setHistoryLoading(true);
            try {
                const res = await listBackupHistory({
                    cursor: cur ?? undefined,
                    status: statusFilter === "any" ? undefined : statusFilter,
                    q: search.trim() || undefined,
                    from: dateFrom || undefined,
                    to: dateTo || undefined,
                });
                setHistoryRaw(res?.items ?? []);
                setNextCursor(res?.nextCursor ?? null);
            } catch (e: any) {
                setHistoryRaw([]);
                setNextCursor(null);
                notify({ title: e?.message || "Failed to load backup history", kind: "destructive", variant: "destructive" });
            } finally {
                setHistoryLoading(false);
            }
        },
        [statusFilter, search, dateFrom, dateTo, notify]
    );

    React.useEffect(() => {
        loadHistory(cursor);
    }, [cursor, loadHistory]);

    React.useEffect(() => {
        const from = dateFrom ? Date.parse(dateFrom) : null;
        const to = dateTo ? Date.parse(dateTo) : null;
        const q = search.trim().toLowerCase();

        const out = historyRaw.filter((row) => {
            if (statusFilter !== "any" && row.status !== statusFilter) return false;

            if (from || to) {
                const t = Date.parse(row.at.replace(" ", "T") + ":00");
                if (Number.isFinite(from) && t < (from as number)) return false;
                if (Number.isFinite(to)) {
                    const end = new Date(to as number);
                    end.setDate(end.getDate() + 1);
                    if (t >= +end) return false;
                }
            }

            if (q) {
                const hay = `${row.id} ${row.note ?? ""}`.toLowerCase();
                if (!hay.includes(q)) return false;
            }
            return true;
        });

        setHistoryView(out);
    }, [historyRaw, statusFilter, search, dateFrom, dateTo]);

    /* ---------- cron next runs ---------- */
    React.useEffect(() => {
        if (backups.schedule !== "cron" || !isValidCron(backups.cronExpr)) {
            setCronNextRuns(null);
            return;
        }
        (async () => {
            try {
                const data = await getCronNextRuns(backups.cronExpr, TZ);
                setCronNextRuns(Array.isArray(data?.next) ? data.next.slice(0, 5) : null);
            } catch {
                setCronNextRuns(null);
            }
        })();
    }, [backups.schedule, backups.cronExpr]);

    /* ---------- UI helpers ---------- */
    const hasBlockingErrors = errors.length > 0;
    const typeLabel = (k: FanoutDest["kind"]) =>
        k === "remote" ? "Remote (SFTP)" :
            k === "gdrive" ? "Google Drive" :
                k === "nextcloud" ? "Nextcloud (WebDAV)" :
                    k.toUpperCase();

    /* ---------- actions ---------- */

    const saveConfig = async () => {
        const errs = validateConfig(backups);
        setErrors(errs);
        if (errs.length) {
            errs.forEach((e) => notify({ title: e, kind: "destructive", variant: "destructive" }));
            return;
        }
        setSaving(true);
        try {
            let destination: ApiDestination;
            switch (backups.destination.kind) {
                case "local":
                    destination = { kind: "local", path: (backups.destination as LocalDest).path };
                    break;
                case "s3":
                    destination = {
                        kind: "s3",
                        connectionId: (backups.destination as S3Dest).connectionId,
                        bucket: (backups.destination as S3Dest).bucket || undefined,
                        prefix: (backups.destination as S3Dest).prefix || undefined,
                    };
                    break;
                case "nextcloud":
                    destination = {
                        kind: "nextcloud",
                        connectionId: (backups.destination as NextcloudDest).connectionId,
                        path: (backups.destination as NextcloudDest).path,
                    };
                    break;
                case "gdrive":
                    destination = {
                        kind: "gdrive",
                        connectionId: (backups.destination as GDriveDest).connectionId,
                        subfolder: (backups.destination as GDriveDest).subfolder || undefined,
                    };
                    break;
                case "remote":
                default:
                    destination = {
                        kind: "remote",
                        connectionId: (backups.destination as RemoteSFTPDest).connectionId,
                        path: (backups.destination as RemoteSFTPDest).path,
                    };
                    break;
            }

            const payload: ApiBackupConfig & {
                extraDestinations?: FanoutDest[];
                minSuccess?: number;
                parallelism?: number;
            } = {
                enabled: backups.enabled,
                targets: backups.targets,
                schedule: backups.schedule,
                cronExpr: backups.cronExpr,
                retentionDays: Number(backups.retentionDays) || 0,
                encrypt: backups.encrypt,
                destination,
                extraDestinations: backups.extraDestinations,
                ...(backups.notifications ? { notifications: backups.notifications } : {}),
                ...(backups.minSuccess ? { minSuccess: Number(backups.minSuccess) } : {}),
                ...(backups.parallelism ? { parallelism: Number(backups.parallelism) } : {}),
            };

            await updateBackupConfig(payload as any);
            notify({ title: "Backup settings saved", kind: "success", variant: "success" });
            setErrors([]);
            await loadConfig();
        } catch (e: any) {
            notify({ title: e?.message || "Failed to save backup settings", kind: "destructive", variant: "destructive" });
        } finally {
            setSaving(false);
        }
    };

    const runBackupNow = async () => {
        const errs = validateConfig(backups);
        if (!backups.enabled) errs.unshift("Enable backups before running.");
        if (errs.length) {
            errs.forEach((e) => notify({ title: e, kind: "destructive", variant: "destructive" }));
            setErrors(errs);
            return;
        }
        setRunning(true);
        try {
            const res = await apiRunBackupNow();
            if (res?.id) {
                const at = (res?.startedAt || new Date().toISOString()).slice(0, 16).replace("T", " ");
                setHistoryRaw((prev) => [{ id: res.id, at, status: "running" }, ...prev]);
            }
            notify({ title: "Backup started", kind: "default", variant: "default" });
        } catch (e: any) {
            notify({ title: e?.message || "Failed to start backup", kind: "destructive", variant: "destructive" });
        } finally {
            setRunning(false);
        }
    };

    const pruneNow = async () => {
        try {
            const res = await apiPruneBackups();
            const n = res?.removed ?? 0;
            notify({ title: `Prune complete: removed ${n} old archives`, kind: "default", variant: "default" });
            loadHistory(cursor);
        } catch (e: any) {
            notify({ title: e?.message || "Prune failed", kind: "destructive", variant: "destructive" });
        }
    };

    const testPrimaryDestination = async () => {
        const errs = validateDest(backups.destination as any);
        setErrors(errs);
        if (errs.length) {
            errs.forEach((e) => notify({ title: e, kind: "destructive", variant: "destructive" }));
            return;
        }
        setTestingDest(true);
        try {
            const res = await testBackupDestination(backups.destination as ApiDestination);
            const detail = res?.phases
                ? ` (${Object.entries(res.phases).map(([k, v]) => `${k}:${v ? "ok" : "fail"}`).join(", ")})`
                : "";
            notify({ title: `Destination OK${detail}`, kind: "success", variant: "success" });
        } catch (e: any) {
            notify({ title: e?.message || "Destination test failed", kind: "destructive", variant: "destructive" });
        } finally {
            setTestingDest(false);
        }
    };

    const retryJob = async (id: string) => {
        try {
            await retryBackup(id);
            notify({ title: `Retry queued for ${id}`, kind: "default", variant: "default" });
            loadHistory(cursor);
        } catch (e: any) {
            notify({ title: e?.message || "Retry failed", kind: "destructive", variant: "destructive" });
        }
    };

    const cancelJob = async (id: string) => {
        try {
            await cancelBackup(id);
            notify({ title: `Cancel sent to ${id}`, kind: "default", variant: "default" });
            loadHistory(cursor);
        } catch (e: any) {
            notify({ title: e?.message || "Cancel failed", kind: "destructive", variant: "destructive" });
        }
    };

    const downloadArchive = (id: string) => {
        window.open(`/api/admin/backups/${encodeURIComponent(id)}/download`, "_blank", "noopener,noreferrer");
    };
    const viewLog = (id: string) => {
        window.open(`/api/admin/backups/${encodeURIComponent(id)}/log`, "_blank", "noopener,noreferrer");
    };
    const viewManifest = (id: string) => {
        window.open(`/api/admin/backups/${encodeURIComponent(id)}/manifest`, "_blank", "noopener,noreferrer");
    };

    const confirmRestore = (id: string) => { setRestoreId(id); setRestoreConfirm(""); };
    const doRestore = async () => {
        if (!restoreId) return;
        try {
            await startRestore(restoreId);
            notify({ title: `Restore from ${restoreId} started`, kind: "default", variant: "default" });
        } catch (e: any) {
            notify({ title: e?.message || "Restore failed to start", kind: "destructive", variant: "destructive" });
        } finally {
            setRestoreId(null);
            setRestoreConfirm("");
        }
    };

    /* ---------- render ---------- */

    const scheduleNext = nextRunList;

    return (
        <TabsContent value="backups" className="mt-0">
            <Card>
                <CardHeader>
                    <CardTitle className="flex items-center gap-2">
                        <ArchiveRestore className="h-5 w-5" />
                        Backups
                        <Badge variant={backups.enabled ? "default" : "secondary"} className="ml-1">
                            {backups.enabled ? "Enabled" : "Disabled"}
                        </Badge>
                    </CardTitle>
                    <CardDescription>
                        Configure targets, schedule, retention, <b>multiple destinations</b> (Local / S3 / Nextcloud / Google Drive / SFTP), and notifications. Runs write to all selected destinations.
                    </CardDescription>
                </CardHeader>

                <CardContent className="space-y-6">

                    {errors.length > 0 && (
                        <div className="rounded-md border border-amber-300/60 bg-amber-50/40 p-3 text-sm text-amber-800 dark:border-amber-900/50 dark:bg-amber-950/30 dark:text-amber-300">
                            <div className="font-medium mb-1">Please review:</div>
                            <ul className="list-disc ml-5 space-y-0.5">
                                {errors.map((e, i) => (<li key={i}>{e}</li>))}
                            </ul>
                        </div>
                    )}

                    {/* Configuration */}
                    <div className="rounded-md border p-3 space-y-3">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <Shield className="h-4 w-4" />
                                <div className="font-medium">Backup Configuration</div>
                            </div>
                            <div className="flex items-center gap-2">
                                <Switch checked={backups.enabled} onCheckedChange={(v) => setBackups({ ...backups, enabled: v })} />
                                <span className="text-sm">{backups.enabled ? "Enabled" : "Disabled"}</span>
                            </div>
                        </div>

                        {/* Targets */}
                        <div className="grid gap-2">
                            <Label className="text-sm">Targets</Label>
                            <div className="flex flex-wrap gap-2 text-sm">
                                {(["users", "roles", "devices", "policies", "audit_logs", "settings", "templates"] as BackupTarget[]).map((t) => (
                                    <button
                                        key={t}
                                        type="button"
                                        onClick={() => setBackups((prev) => ({
                                            ...prev,
                                            targets: prev.targets.includes(t)
                                                ? prev.targets.filter((x) => x !== t)
                                                : [...prev.targets, t],
                                        }))}
                                        className={cn(
                                            "rounded border px-2 py-1 capitalize",
                                            backups.targets.includes(t)
                                                ? "border-emerald-400 bg-emerald-50 dark:bg-emerald-900/20"
                                                : "border-border"
                                        )}
                                    >
                                        {t.replaceAll("_", " ")}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {/* Schedule */}
                        <div className="grid gap-4">
                            <div className="grid gap-3 md:grid-cols-12">
                                <div className="grid gap-1 md:col-span-3">
                                    <Label className="text-sm">Schedule</Label>
                                    <Select
                                        value={backups.schedule}
                                        onValueChange={(v: ScheduleKind) => { setBackups({ ...backups, schedule: v }); setErrors([]); }}
                                    >
                                        <SelectTrigger><SelectValue placeholder="Select schedule" /></SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="hourly">Hourly</SelectItem>
                                            <SelectItem value="daily">Daily</SelectItem>
                                            <SelectItem value="weekly">Weekly</SelectItem>
                                            <SelectItem value="cron">Custom (cron)</SelectItem>
                                        </SelectContent>
                                    </Select>
                                </div>

                                <div className="md:col-span-6">
                                    {backups.schedule === "cron" ? (
                                        <div className="space-y-2">
                                            <LabeledInput
                                                label="Cron expression"
                                                value={backups.cronExpr}
                                                onChange={(v) => { setBackups({ ...backups, cronExpr: v }); }}
                                            />
                                        </div>
                                    ) : (
                                        <div className="grid gap-1">
                                            <Label className="text-sm">Next runs (example)</Label>
                                            <Input readOnly value={(scheduleNext || []).slice(0, 5).join(" · ")} />
                                        </div>
                                    )}
                                </div>

                                <div className="grid gap-1 md:col-span-3">
                                    <LabeledNumber
                                        label="Retention (days)"
                                        value={backups.retentionDays}
                                        onChange={(v) => setBackups({ ...backups, retentionDays: v })}
                                    />
                                    {(!Number.isFinite(Number(backups.retentionDays)) ||
                                        Number(backups.retentionDays) < 1 ||
                                        Number(backups.retentionDays) > 3650) && (
                                            <span className="text-[11px] text-red-600">1–3650 days</span>
                                        )}
                                </div>
                            </div>

                            {backups.schedule === "cron" && (
                                <div className="md:col-span-12">
                                    <div className="flex flex-wrap gap-2 mb-2">
                                        {[{ label: "Every day 03:00", val: "0 3 * * *" },
                                        { label: "Every Sun 03:00", val: "0 3 * * 0" },
                                        { label: "Every hour", val: "0 * * * *" },
                                        { label: "Weekdays 02:00", val: "0 2 * * 1-5" }].map((p) => (
                                            <Button key={p.val} variant="outline" size="sm" onClick={() => setBackups({ ...backups, cronExpr: p.val })}>
                                                <ListChecks className="h-4 w-4 mr-1" /> {p.label}
                                            </Button>
                                        ))}
                                    </div>
                                    <div className="text-xs text-muted-foreground">
                                        Next 5 runs:{" "}
                                        {isValidCron(backups.cronExpr)
                                            ? (cronNextRuns ? cronNextRuns.join(" · ") : "Cannot compute client-side; backend endpoint can provide preview.")
                                            : <span className="text-red-600">Invalid cron</span>}
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Runner hints */}
                        <div className="grid md:grid-cols-6 gap-3">
                            <div className="md:col-span-3">
                                <LabeledNumber
                                    label="Min destinations that must succeed"
                                    value={backups.minSuccess ?? ""}
                                    onChange={(v) => setBackups({ ...backups, minSuccess: v })}
                                />
                            </div>
                            <div className="md:col-span-3">
                                <LabeledNumber
                                    label="Parallelism (workers)"
                                    value={backups.parallelism ?? ""}
                                    onChange={(v) => setBackups({ ...backups, parallelism: v })}
                                />
                            </div>
                        </div>

                        {/* PRIMARY Destination */}
                        <div className="rounded-md border p-3 space-y-3">
                            <div className="flex items-center justify-between">
                                <div className="font-medium">Primary destination</div>
                                <div className="flex items-center gap-2">
                                    <Button type="button" variant="outline" size="sm" onClick={testPrimaryDestination} disabled={testingDest}>
                                        <RefreshCcw className="mr-2 h-4 w-4" />
                                        {testingDest ? "Testing..." : "Test destination"}
                                    </Button>
                                    <Button type="button" variant="outline" size="sm" onClick={pruneNow}>
                                        <Trash2 className="mr-2 h-4 w-4" />
                                        Prune now
                                    </Button>
                                </div>
                            </div>

                            <div className="grid gap-3 md:grid-cols-12 items-start">
                                {/* Type */}
                                <div className="grid gap-1 md:col-span-3">
                                    <Label className="text-sm">Type</Label>
                                    <Select
                                        value={backups.destination.kind}
                                        onValueChange={(v: Dest["kind"]) => {
                                            if (v === "local") {
                                                setBackups({ ...backups, destination: { kind: "local", path: "/var/remoteiq/backups" } as LocalDest });
                                            } else if (v === "s3") {
                                                setBackups({ ...backups, destination: { kind: "s3", connectionId: "", bucket: "", prefix: "" } as S3Dest });
                                            } else if (v === "nextcloud") {
                                                setBackups({ ...backups, destination: { kind: "nextcloud", connectionId: "", path: "/Backups/RemoteIQ" } as NextcloudDest });
                                            } else if (v === "gdrive") {
                                                setBackups({ ...backups, destination: { kind: "gdrive", connectionId: "", subfolder: "" } as GDriveDest });
                                            } else {
                                                setBackups({ ...backups, destination: { kind: "remote", connectionId: "", path: "/srv/remoteiq/backups" } as RemoteSFTPDest });
                                            }
                                            setErrors([]);
                                        }}
                                    >
                                        <SelectTrigger><SelectValue placeholder="Select destination" /></SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="local">Local</SelectItem>
                                            <SelectItem value="s3">S3</SelectItem>
                                            <SelectItem value="nextcloud">Nextcloud (WebDAV)</SelectItem>
                                            <SelectItem value="gdrive">Google Drive</SelectItem>
                                            <SelectItem value="remote">Remote (SFTP)</SelectItem>
                                        </SelectContent>
                                    </Select>
                                </div>

                                {/* Connection (if needed) */}
                                {backups.destination.kind !== "local" ? (
                                    <div className="grid gap-1 md:col-span-5">
                                        <Label className="text-sm">Connection</Label>
                                        <Select
                                            value={("connectionId" in backups.destination ? (backups.destination as any).connectionId : "") || ""}
                                            onValueChange={(v) => {
                                                setBackups((prev) => {
                                                    const d = prev.destination as any;
                                                    return { ...prev, destination: { ...d, connectionId: v } };
                                                });
                                                setErrors([]);
                                            }}
                                        >
                                            <SelectTrigger>
                                                <SelectValue placeholder={connsFor(backups.destination.kind).length ? "Select connection" : "No connections"} />
                                            </SelectTrigger>
                                            <SelectContent>
                                                {connsFor(backups.destination.kind).map((c) => (
                                                    <SelectItem key={c.id} value={c.id}>{c.name}</SelectItem>
                                                ))}
                                                {connsFor(backups.destination.kind).length === 0 && (
                                                    <SelectItem value="__none" disabled>No connections</SelectItem>
                                                )}
                                            </SelectContent>
                                        </Select>
                                    </div>
                                ) : (<div className="hidden md:block md:col-span-5" />)}

                                {/* Per-kind fields */}
                                {backups.destination.kind === "local" && (
                                    <div className="grid gap-1 md:col-span-4">
                                        <LabeledInput
                                            label="Directory (server path)"
                                            value={(backups.destination as LocalDest).path}
                                            onChange={(v) => setBackups({ ...backups, destination: { kind: "local", path: v } as LocalDest })}
                                            placeholder="/var/remoteiq/backups"
                                        />
                                    </div>
                                )}
                                {backups.destination.kind === "s3" && (
                                    <>
                                        <div className="md:col-span-2">
                                            <LabeledInput
                                                label="Bucket (override)"
                                                value={(backups.destination as S3Dest).bucket ?? ""}
                                                onChange={(v) => setBackups({ ...backups, destination: { ...(backups.destination as S3Dest), kind: "s3", bucket: v } as S3Dest })}
                                            />
                                        </div>
                                        <div className="md:col-span-2">
                                            <LabeledInput
                                                label="Prefix (override)"
                                                value={(backups.destination as S3Dest).prefix ?? ""}
                                                onChange={(v) => setBackups({ ...backups, destination: { ...(backups.destination as S3Dest), kind: "s3", prefix: v } as S3Dest })}
                                            />
                                        </div>
                                    </>
                                )}
                                {backups.destination.kind === "nextcloud" && (
                                    <div className="grid gap-1 md:col-span-4">
                                        <LabeledInput
                                            label="Folder path"
                                            value={(backups.destination as NextcloudDest).path}
                                            onChange={(v) => setBackups({ ...backups, destination: { ...(backups.destination as NextcloudDest), kind: "nextcloud", path: v } as NextcloudDest })}
                                            placeholder="/Backups/RemoteIQ"
                                        />
                                    </div>
                                )}
                                {backups.destination.kind === "gdrive" && (
                                    <div className="md:col-span-4">
                                        <LabeledInput
                                            label="Subfolder (optional)"
                                            value={(backups.destination as GDriveDest).subfolder ?? ""}
                                            onChange={(v) => setBackups({ ...backups, destination: { ...(backups.destination as GDriveDest), kind: "gdrive", subfolder: v } as GDriveDest })}
                                            placeholder="e.g., nightly-dumps"
                                        />
                                    </div>
                                )}
                                {backups.destination.kind === "remote" && (
                                    <div className="grid gap-1 md:col-span-4">
                                        <LabeledInput
                                            label="Directory (remote absolute path)"
                                            value={(backups.destination as RemoteSFTPDest).path}
                                            onChange={(v) => setBackups({ ...backups, destination: { ...(backups.destination as RemoteSFTPDest), kind: "remote", path: v } as RemoteSFTPDest })}
                                            placeholder="/srv/remoteiq/backups"
                                        />
                                    </div>
                                )}
                            </div>

                            <CheckToggle
                                label="Encrypt backup archives"
                                checked={backups.encrypt}
                                onChange={(v) => setBackups({ ...backups, encrypt: v })}
                            />
                            <p className="text-xs text-muted-foreground flex items-center gap-1">
                                <Info className="h-3.5 w-3.5" /> Secrets live in Storage connections; the Backups UI never stores credentials.
                            </p>
                        </div>

                        {/* ADDITIONAL DESTINATIONS */}
                        <div className="rounded-md border p-3 space-y-3">
                            <div className="flex items-center justify-between">
                                <div className="font-medium">Additional destinations (redundancy)</div>
                                <Button
                                    type="button"
                                    variant="outline"
                                    size="sm"
                                    onClick={() =>
                                        setBackups((prev) => ({
                                            ...prev,
                                            extraDestinations: [...prev.extraDestinations, { kind: "s3", connectionId: "" }],
                                        }))
                                    }
                                >
                                    <Plus className="h-4 w-4 mr-1" /> Add destination
                                </Button>
                            </div>

                            {backups.extraDestinations.length === 0 ? (
                                <div className="text-xs text-muted-foreground">
                                    No additional destinations. Add S3, Nextcloud, Google Drive, SFTP or Local to write the same backup to multiple locations.
                                </div>
                            ) : (
                                <div className="space-y-3">
                                    {backups.extraDestinations.map((d, i) => {
                                        const update = (patch: Partial<FanoutDest>) =>
                                            setBackups((prev) => {
                                                const arr = [...prev.extraDestinations];
                                                arr[i] = { ...arr[i], ...patch } as FanoutDest;
                                                return { ...prev, extraDestinations: arr };
                                            });
                                        const remove = () =>
                                            setBackups((prev) => {
                                                const arr = [...prev.extraDestinations];
                                                arr.splice(i, 1);
                                                return { ...prev, extraDestinations: arr };
                                            });

                                        const fields = (
                                            <>
                                                {/* Type */}
                                                <div className="grid gap-1 md:col-span-2">
                                                    <Label className="text-xs">Type</Label>
                                                    <Select
                                                        value={d.kind}
                                                        onValueChange={(v: FanoutDest["kind"]) => {
                                                            if (v === "local") update({ kind: "local", path: "/var/remoteiq/backups" });
                                                            else if (v === "s3") update({ kind: "s3", connectionId: "", bucket: "", prefix: "" });
                                                            else if (v === "nextcloud") update({ kind: "nextcloud", connectionId: "", path: "/Backups/RemoteIQ" });
                                                            else if (v === "gdrive") update({ kind: "gdrive", connectionId: "", subfolder: "" });
                                                            else update({ kind: "remote", connectionId: "", path: "/srv/remoteiq/backups" });
                                                        }}
                                                    >
                                                        <SelectTrigger><SelectValue placeholder="Select" /></SelectTrigger>
                                                        <SelectContent>
                                                            <SelectItem value="local">Local</SelectItem>
                                                            <SelectItem value="s3">S3</SelectItem>
                                                            <SelectItem value="nextcloud">Nextcloud</SelectItem>
                                                            <SelectItem value="gdrive">Google Drive</SelectItem>
                                                            <SelectItem value="remote">Remote (SFTP)</SelectItem>
                                                        </SelectContent>
                                                    </Select>
                                                </div>

                                                {/* Connection if needed */}
                                                {d.kind !== "local" && (
                                                    <div className="grid gap-1 md:col-span-3">
                                                        <Label className="text-xs">Connection</Label>
                                                        <Select
                                                            value={("connectionId" in d ? (d as any).connectionId : "") || ""}
                                                            onValueChange={(v) => update({ ...(d as any), connectionId: v } as any)}
                                                        >
                                                            <SelectTrigger><SelectValue placeholder={connsFor(d.kind as any).length ? "Select connection" : "No connections"} /></SelectTrigger>
                                                            <SelectContent>
                                                                {connsFor(d.kind as any).map((c) => (
                                                                    <SelectItem key={c.id} value={c.id}>{c.name}</SelectItem>
                                                                ))}
                                                                {connsFor(d.kind as any).length === 0 && (
                                                                    <SelectItem value="__none" disabled>No connections</SelectItem>
                                                                )}
                                                            </SelectContent>
                                                        </Select>
                                                    </div>
                                                )}

                                                {/* Per-kind fields */}
                                                {d.kind === "local" && (
                                                    <div className="grid gap-1 md:col-span-4">
                                                        <LabeledInput
                                                            label="Directory"
                                                            value={(d as any).path ?? ""}
                                                            onChange={(v) => update({ ...(d as any), path: v } as any)}
                                                            placeholder="/var/remoteiq/backups"
                                                        />
                                                    </div>
                                                )}
                                                {d.kind === "s3" && (
                                                    <>
                                                        <div className="md:col-span-2">
                                                            <LabeledInput
                                                                label="Bucket (override)"
                                                                value={(d as any).bucket ?? ""}
                                                                onChange={(v) => update({ ...(d as any), bucket: v } as any)}
                                                            />
                                                        </div>
                                                        <div className="md:col-span-2">
                                                            <LabeledInput
                                                                label="Prefix (override)"
                                                                value={(d as any).prefix ?? ""}
                                                                onChange={(v) => update({ ...(d as any), prefix: v } as any)}
                                                            />
                                                        </div>
                                                    </>
                                                )}
                                                {d.kind === "nextcloud" && (
                                                    <div className="grid gap-1 md:col-span-4">
                                                        <LabeledInput
                                                            label="Folder path"
                                                            value={(d as any).path ?? "/Backups/RemoteIQ"}
                                                            onChange={(v) => update({ ...(d as any), path: v } as any)}
                                                            placeholder="/Backups/RemoteIQ"
                                                        />
                                                    </div>
                                                )}
                                                {d.kind === "gdrive" && (
                                                    <div className="md:col-span-4">
                                                        <LabeledInput
                                                            label="Subfolder (optional)"
                                                            value={(d as any).subfolder ?? ""}
                                                            onChange={(v) => update({ ...(d as any), subfolder: v } as any)}
                                                            placeholder="e.g., nightly-dumps"
                                                        />
                                                    </div>
                                                )}
                                                {d.kind === "remote" && (
                                                    <div className="grid gap-1 md:col-span-4">
                                                        <LabeledInput
                                                            label="Directory"
                                                            value={(d as any).path ?? "/srv/remoteiq/backups"}
                                                            onChange={(v) => update({ ...(d as any), path: v } as any)}
                                                            placeholder="/srv/remoteiq/backups"
                                                        />
                                                    </div>
                                                )}

                                                {/* Priority */}
                                                <div className="md:col-span-2">
                                                    <LabeledNumber
                                                        label="Priority"
                                                        value={(d as any).priority ?? ((i + 2) * 10)}
                                                        onChange={(v) => update({ ...(d as any), priority: Number(v) as any })}
                                                    />
                                                </div>

                                                {/* Remove */}
                                                <div className="md:col-span-1 flex items-end">
                                                    <Button type="button" variant="ghost" onClick={remove} aria-label="Remove">
                                                        <Trash className="h-4 w-4" />
                                                    </Button>
                                                </div>
                                            </>
                                        );

                                        return (
                                            <div key={i} className="grid md:grid-cols-12 gap-3 rounded-md border p-3">
                                                <div className="md:col-span-12 text-xs text-muted-foreground -mt-1 mb-1">
                                                    Destination #{i + 2} · <span className="font-medium">{typeLabel(d.kind)}</span>
                                                </div>
                                                {fields}
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </div>

                        {/* Notifications */}
                        <div className="rounded-md border p-3 space-y-3">
                            <div className="flex items-center justify-between">
                                <div className="font-medium">Notifications</div>
                                <Button
                                    type="button"
                                    variant="outline"
                                    size="sm"
                                    onClick={() => {
                                        (async () => {
                                            try {
                                                await fetch("/api/admin/backups/test-notification", { method: "POST" });
                                                notify({ title: "Notification test sent", kind: "success", variant: "success" });
                                            } catch (e: any) {
                                                notify({ title: e?.message || "Notification test failed", kind: "destructive", variant: "destructive" });
                                            }
                                        })();
                                    }}
                                >
                                    <RefreshCcw className="mr-2 h-4 w-4" /> Test notification
                                </Button>
                            </div>
                            <div className="flex gap-6">
                                <CheckToggle
                                    label="Email"
                                    checked={!!backups.notifications?.email}
                                    onChange={(v) => setBackups({ ...backups, notifications: { ...backups.notifications, email: v } })}
                                />
                                <CheckToggle
                                    label="Slack"
                                    checked={!!backups.notifications?.slack}
                                    onChange={(v) => setBackups({ ...backups, notifications: { ...backups.notifications, slack: v } })}
                                />
                                <CheckToggle
                                    label="Webhook"
                                    checked={!!backups.notifications?.webhook}
                                    onChange={(v) => setBackups({ ...backups, notifications: { ...backups.notifications, webhook: v } })}
                                />
                            </div>
                            <p className="text-xs text-muted-foreground">
                                Configure endpoints/recipients on the server. UI only toggles which events to notify.
                            </p>
                        </div>
                    </div>

                    {/* Filters */}
                    <div className="rounded-md border p-3 space-y-3">
                        <div className="flex items-center gap-2 text-sm font-medium">
                            <Filter className="h-4 w-4" /> Filters
                        </div>
                        <div className="grid md:grid-cols-4 gap-3">
                            <div className="grid gap-1">
                                <Label className="text-sm">Status</Label>
                                <Select value={statusFilter} onValueChange={(v: HistoryStatus) => setStatusFilter(v)}>
                                    <SelectTrigger><SelectValue placeholder="Any" /></SelectTrigger>
                                    <SelectContent>
                                        <SelectItem value="any">Any</SelectItem>
                                        <SelectItem value="success">Success</SelectItem>
                                        <SelectItem value="failed">Failed</SelectItem>
                                        <SelectItem value="running">Running</SelectItem>
                                    </SelectContent>
                                </Select>
                            </div>
                            <div className="grid gap-1">
                                <Label className="text-sm">From (YYYY-MM-DD)</Label>
                                <Input value={dateFrom} onChange={(e) => setDateFrom(e.target.value)} placeholder="2025-10-01" />
                            </div>
                            <div className="grid gap-1">
                                <Label className="text-sm">To (YYYY-MM-DD)</Label>
                                <Input value={dateTo} onChange={(e) => setDateTo(e.target.value)} placeholder="2025-10-31" />
                            </div>
                            <div className="grid gap-1">
                                <Label className="text-sm">Search (ID or note)</Label>
                                <Input value={search} onChange={(e) => setSearch(e.target.value)} placeholder="e.g. permission denied" />
                            </div>
                        </div>
                        <div className="flex gap-2 justify-end">
                            <Button
                                variant="outline"
                                onClick={() => { setStatusFilter("any"); setDateFrom(""); setDateTo(""); setSearch(""); }}
                            >
                                Reset
                            </Button>
                            <Button onClick={() => { setCursor(null); setCursorStack([]); loadHistory(null); }}>
                                Apply
                            </Button>
                        </div>
                    </div>

                    {/* History */}
                    <div className="rounded-md border">
                        <div className="grid grid-cols-12 border-b bg-muted/30 p-2 text-xs font-medium text-muted-foreground">
                            <div className="col-span-2 px-2">ID</div>
                            <div className="col-span-2 px-2">Time</div>
                            <div className="col-span-2 px-2">Status</div>
                            <div className="col-span-2 px-2">Size / Duration</div>
                            <div className="col-span-2 px-2">Note</div>
                            <div className="col-span-2 px-2 text-right">Actions</div>
                        </div>

                        {historyLoading ? (
                            Array.from({ length: 4 }).map((_, i) => (
                                <div key={i} className="grid grid-cols-12 items-center border-b p-2 last:border-b-0">
                                    <div className="col-span-2 px-2"><Skeleton className="h-4 w-24" /></div>
                                    <div className="col-span-2 px-2"><Skeleton className="h-4 w-28" /></div>
                                    <div className="col-span-2 px-2"><Skeleton className="h-4 w-16" /></div>
                                    <div className="col-span-2 px-2"><Skeleton className="h-4 w-24" /></div>
                                    <div className="col-span-2 px-2"><Skeleton className="h-4 w-36" /></div>
                                    <div className="col-span-2 px-2 text-right"><Skeleton className="h-8 w-48 ml-auto" /></div>
                                </div>
                            ))
                        ) : historyView.length === 0 ? (
                            <div className="p-4 text-sm text-muted-foreground">No backups found.</div>
                        ) : (
                            historyView.map((b) => {
                                const verified = (b as any).verified ? true : false;
                                const size = (b as any).sizeBytes != null ? `${Math.round((b as any).sizeBytes / 1024 / 1024)} MB` : "—";
                                const dur = (b as any).durationSec != null ? `${Math.round((b as any).durationSec)}s` : "—";
                                return (
                                    <div key={b.id} className="grid grid-cols-12 items-center border-b p-2 last:border-b-0 text-sm">
                                        <div className="col-span-2 px-2 font-mono flex items-center gap-2">
                                            {b.id}{verified ? (<Badge variant="secondary">Verified</Badge>) : null}
                                        </div>
                                        <div className="col-span-2 px-2">{b.at}</div>
                                        <div className={cn(
                                            "col-span-2 px-2 capitalize",
                                            b.status === "success" ? "text-emerald-600"
                                                : b.status === "failed" ? "text-red-600"
                                                    : b.status === "running" ? "text-amber-600"
                                                        : "text-muted-foreground"
                                        )}>
                                            {b.status}
                                        </div>
                                        <div className="col-span-2 px-2 text-muted-foreground">{size} / {dur}</div>
                                        <div className="col-span-2 px-2 text-muted-foreground min-w-0 overflow-hidden">
                                            <span className="inline-block w-full overflow-hidden text-ellipsis whitespace-nowrap" title={b.note ?? ""}>
                                                {b.note ?? "—"}
                                            </span>
                                        </div>
                                        <div className="col-span-2 px-2 text-right">
                                            <DropdownMenu>
                                                <DropdownMenuTrigger asChild>
                                                    <Button variant="outline" size="sm" aria-label="Actions">
                                                        <MoreVertical className="h-4 w-4" />
                                                    </Button>
                                                </DropdownMenuTrigger>

                                                <DropdownMenuContent align="end" className="w-44">
                                                    <DropdownMenuLabel>Actions</DropdownMenuLabel>
                                                    <DropdownMenuItem onClick={() => viewLog(b.id)}>
                                                        <FileText className="h-4 w-4 mr-2" /> View log
                                                    </DropdownMenuItem>
                                                    <DropdownMenuItem onClick={() => viewManifest(b.id)}>
                                                        <Info className="h-4 w-4 mr-2" /> Manifest
                                                    </DropdownMenuItem>
                                                    <DropdownMenuItem
                                                        onClick={() => downloadArchive(b.id)}
                                                        disabled={b.status !== "success" || !perms.download}
                                                    >
                                                        <Download className="h-4 w-4 mr-2" /> Download
                                                    </DropdownMenuItem>

                                                    {b.status === "failed" && (
                                                        <DropdownMenuItem onClick={() => retryJob(b.id)}>
                                                            <Repeat2 className="h-4 w-4 mr-2" /> Retry
                                                        </DropdownMenuItem>
                                                    )}
                                                    {b.status === "running" && (
                                                        <DropdownMenuItem onClick={() => cancelJob(b.id)}>
                                                            <XCircle className="h-4 w-4 mr-2" /> Cancel
                                                        </DropdownMenuItem>
                                                    )}

                                                    <DropdownMenuSeparator />
                                                    <DropdownMenuItem
                                                        onClick={() => confirmRestore(b.id)}
                                                        disabled={b.status !== "success" || !perms.restore}
                                                    >
                                                        <RotateCcw className="h-4 w-4 mr-2" /> Restore
                                                    </DropdownMenuItem>
                                                </DropdownMenuContent>
                                            </DropdownMenu>
                                        </div>
                                    </div>
                                );
                            })
                        )}
                    </div>

                    {/* Pagination */}
                    <div className="flex items-center justify-between">
                        <div className="text-xs text-muted-foreground">Timezone: {TZ}</div>
                        <div className="flex gap-2">
                            <Button
                                variant="outline"
                                disabled={cursorStack.length === 0}
                                onClick={() => {
                                    const prev = [...cursorStack];
                                    const last = prev.pop();
                                    setCursorStack(prev);
                                    setCursor(last ?? null);
                                }}
                            >
                                Prev
                            </Button>
                            <Button
                                variant="outline"
                                disabled={!nextCursor}
                                onClick={() => {
                                    if (nextCursor) {
                                        setCursorStack((s) => [...s, cursor ?? ""]);
                                        setCursor(nextCursor);
                                    }
                                }}
                            >
                                Next
                            </Button>
                        </div>
                    </div>

                    {/* Footer actions */}
                    <div className="flex items-center justify-end gap-2">
                        <Button
                            variant="outline"
                            onClick={runBackupNow}
                            disabled={running || !backups.enabled || hasBlockingErrors}
                        >
                            <RefreshCcw className="mr-2 h-4 w-4" />
                            {running ? "Starting…" : "Run backup now"}
                        </Button>
                        <Button variant="success" onClick={saveConfig} disabled={saving || hasBlockingErrors}>
                            {saving ? "Saving…" : "Save backup settings"}
                        </Button>
                    </div>
                </CardContent>
            </Card>

            {/* Restore confirm dialog */}
            <AlertDialog open={!!restoreId} onOpenChange={(open) => !open && setRestoreId(null)}>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Restore from backup?</AlertDialogTitle>
                        <AlertDialogDescription>
                            This will start a restore job from <span className="font-mono">{restoreId}</span>.
                            <br />
                            Type <span className="font-semibold">RESTORE</span> to confirm.
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <div className="px-6">
                        <Input value={restoreConfirm} onChange={(e) => setRestoreConfirm(e.target.value)} placeholder="RESTORE" />
                    </div>
                    <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction onClick={doRestore} disabled={restoreConfirm !== "RESTORE"}>
                            Start Restore
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>
        </TabsContent>
    );
}


``r

--------------------------------------------------------------------------------
| Frontend Â· StorageTab.tsx |
--------------------------------------------------------------------------------

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-frontend\app\administration\tabs\StorageTab.tsx

``r

/* remoteiq-frontend/app/administration/tabs/StorageTab.tsx */
"use client";

import * as React from "react";
import {
    Card,
    CardHeader,
    CardTitle,
    CardDescription,
    CardContent,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { TabsContent } from "@/components/ui/tabs";
import {
    Select,
    SelectTrigger,
    SelectValue,
    SelectContent,
    SelectItem,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import {
    Cloud,
    Plus,
    Save,
    Trash2,
    RefreshCcw,
    Cable,
    Database,
    Copy,
    Upload,
    Download as DownloadIcon,
    ShieldCheck,
    AlertTriangle,
    Eye,
    EyeOff,
} from "lucide-react";
import { LabeledInput, LabeledNumber, CheckToggle } from "../helpers";
import { jfetch } from "@/lib/api";
import { useToast } from "@/components/ui/use-toast";
import { Skeleton } from "@/components/ui/skeleton";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from "@/components/ui/alert-dialog";

import {
    listStorageConnections,
    type StorageConnection,
    type S3ConnConfig,
    type NextcloudConnConfig,
    type GDriveConnConfig,
    type SftpConnConfig,
    type DependentsResp,
} from "@/lib/storage";

// --- Toast helper
type ToastOpts = Parameters<ReturnType<typeof useToast>["toast"]>[0];
function toastWithDefaults(
    t: ReturnType<typeof useToast>["toast"],
    opts: ToastOpts
) {
    t({ duration: 6000, ...opts } as any);
}

type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";
type Env = "dev" | "staging" | "prod";

function looksLikeUrl(u: string) {
    try {
        const url = new URL(u);
        return !!url.protocol && !!url.host;
    } catch {
        return false;
    }
}
function isAbsPath(p: string) {
    return p.startsWith("/") || /^[A-Za-z]:\\/.test(p);
}
function toCsv(arr?: string[]) {
    return (arr ?? []).join(", ");
}

export default function StorageTab() {
    const { toast } = useToast();
    const didInitRef = React.useRef(false);

    const [loading, setLoading] = React.useState(true);
    const [saving, setSaving] = React.useState(false);
    const [testing, setTesting] = React.useState(false);
    const [browsing, setBrowsing] = React.useState<null | "nextcloud">(null);

    const [connections, setConnections] = React.useState<StorageConnection[]>([]);
    const [selectedId, setSelectedId] = React.useState<string | null>(null);

    const [confirmDeleteOpen, setConfirmDeleteOpen] = React.useState(false);
    const [errors, setErrors] = React.useState<string[]>([]);
    const [showNcPassword, setShowNcPassword] = React.useState(false);

    // raw text state for tags so commas/spaces aren't eaten while typing
    const [tagsRaw, setTagsRaw] = React.useState<string>("");

    const [draft, setDraft] = React.useState<StorageConnection>({
        id: "",
        name: "",
        kind: "s3",
        config: {
            provider: "aws",
            region: "us-east-1",
            bucket: "",
            prefix: "",
            pathStyle: false,
            sse: "none",
        } as S3ConnConfig,
        meta: {
            environment: "dev",
            tags: [],
            defaultFor: { backups: false, exports: false, artifacts: false },
            encryptionAtRest: false,
            compression: "none",
        },
        capabilities: {
            canUse: true,
            canEdit: true,
            canRotate: true,
            canDelete: true,
        },
        health: { status: "unknown" },
    });

    const selected = React.useMemo(
        () => connections.find((c) => c.id === selectedId) ?? null,
        [connections, selectedId]
    );

    const refresh = React.useCallback(async () => {
        setLoading(true);
        try {
            const { items } = await listStorageConnections();
            const list = items ?? [];
            setConnections(list);
            setSelectedId((prev) => prev ?? (list[0]?.id ?? null));
        } catch (err: any) {
            setConnections([]);
            setSelectedId(null);
            toastWithDefaults(toast, {
                id: "storage-unreachable",
                title: "Storage API unreachable",
                description:
                    err?.message ?? "Could not load connections. Check backend URL / auth.",
                variant: "destructive",
                kind: "destructive",
            });
        } finally {
            setLoading(false);
        }
    }, [toast]);

    React.useEffect(() => {
        if (didInitRef.current) return;
        didInitRef.current = true;
        refresh();
    }, [refresh]);

    React.useEffect(() => {
        if (!selected) return;
        const cfg = { ...(selected.config as any) };
        if (selected.kind === "nextcloud") cfg.password = "";
        if (selected.kind === "sftp") {
            cfg.password = "";
            cfg.privateKeyPem = "";
            cfg.passphrase = "";
        }
        if (selected.kind === "s3") {
            cfg.accessKeyId = "";
            cfg.secretAccessKey = "";
        }

        setDraft({
            id: selected.id,
            name: selected.name,
            kind: selected.kind,
            config: cfg,
            meta:
                selected.meta ?? {
                    environment: "dev",
                    tags: [],
                    defaultFor: { backups: false, exports: false, artifacts: false },
                    encryptionAtRest: false,
                    compression: "none",
                },
            capabilities:
                selected.capabilities ?? {
                    canUse: true,
                    canEdit: true,
                    canRotate: true,
                    canDelete: true,
                },
            health: selected.health ?? { status: "unknown" },
            hasSecret: selected.hasSecret,
        });
        setTagsRaw(toCsv(selected.meta?.tags ?? []));
        setErrors([]);
    }, [selected]);

    function resetToNew(kind: StorageKind = "s3") {
        setSelectedId(null);
        const base: StorageConnection = {
            id: "",
            name: "",
            kind,
            config: {} as any,
            meta: {
                environment: "dev",
                tags: [],
                defaultFor: { backups: false, exports: false, artifacts: false },
                encryptionAtRest: false,
                compression: "none",
            },
            capabilities: {
                canUse: true,
                canEdit: true,
                canRotate: true,
                canDelete: true,
            },
            health: { status: "unknown" },
        };
        if (kind === "s3") {
            base.config = {
                provider: "aws",
                region: "us-east-1",
                bucket: "",
                prefix: "",
                pathStyle: false,
                sse: "none",
                kmsKeyId: "",
                accessKeyId: "",
                secretAccessKey: "",
                roleArn: "",
                externalId: "",
                sessionDurationSec: 3600,
            } as S3ConnConfig;
        } else if (kind === "nextcloud") {
            base.config = {
                webdavUrl: "",
                username: "",
                password: "",
                path: "/Backups/RemoteIQ",
            } as NextcloudConnConfig;
        } else if (kind === "gdrive") {
            base.config = {
                folderId: "",
                accountEmail: "",
                authMode: undefined,
            } as GDriveConnConfig;
        } else {
            base.config = {
                host: "",
                port: 22,
                username: "",
                password: "",
                privateKeyPem: "",
                passphrase: "",
                hostKeyFingerprint: "",
                path: "/srv/remoteiq/backups",
            } as SftpConnConfig;
        }
        setDraft(base);
        setTagsRaw("");
        setErrors([]);
    }

    function validate(): string[] {
        const errs: string[] = [];
        if (!draft.name?.trim()) errs.push("Name is required.");
        if (draft.kind === "s3") {
            const c = draft.config as S3ConnConfig;
            if (!c.bucket?.trim()) errs.push("S3 bucket is required.");
            if (c.sse === "aws:kms" && !c.kmsKeyId?.trim())
                errs.push("KMS Key ID is required for aws:kms.");
            if (
                c.sessionDurationSec &&
                (c.sessionDurationSec < 900 || c.sessionDurationSec > 43200)
            ) {
                errs.push("STS session duration must be between 900 and 43200 seconds.");
            }
        }
        if (draft.kind === "nextcloud") {
            const c = draft.config as NextcloudConnConfig;
            if (!looksLikeUrl(c.webdavUrl || "")) errs.push("WebDAV URL looks invalid.");
            if (!c.username?.trim()) errs.push("Nextcloud username is required.");
            if (!c.path?.trim() || !c.path.startsWith("/"))
                errs.push("Nextcloud folder path must start with '/'.");
        }
        if (draft.kind === "gdrive") {
            const c = draft.config as GDriveConnConfig;
            if (!c.folderId?.trim()) errs.push("Google Drive Folder ID is required.");
        }
        if (draft.kind === "sftp") {
            const c = draft.config as SftpConnConfig;
            if (!c.host?.trim()) errs.push("SFTP host is required.");
            if (!c.username?.trim()) errs.push("SFTP username is required.");
            if (!c.path?.trim() || !isAbsPath(c.path))
                errs.push("SFTP path must be an absolute path.");
            if (c.privateKeyPem && c.privateKeyPem.length < 64)
                errs.push("SFTP private key looks too short.");
            if (c.hostKeyFingerprint && !/^SHA256:[A-Za-z0-9+/=]+$/.test(c.hostKeyFingerprint)) {
                errs.push("Host key fingerprint must look like 'SHA256:xxxx'.");
            }
        }
        return errs;
    }

    const canEdit = draft.capabilities?.canEdit !== false;
    const canDelete = draft.capabilities?.canDelete !== false;
    const onIfEditable =
        <T,>(fn: (v: T) => void) =>
            (v: T) => {
                if (canEdit) fn(v);
            };

    async function saveDraft(asCopy = false) {
        const errs = validate();
        setErrors(errs);
        if (errs.length) {
            errs.forEach((e) =>
                toast({
                    title: e,
                    variant: "destructive",
                    kind: "destructive",
                })
            );
            return;
        }
        setSaving(true);
        try {
            const cfg: any = { ...(draft.config as any) };
            if (draft.kind === "nextcloud" && !cfg.password) delete cfg.password;
            if (draft.kind === "sftp") {
                if (!cfg.password) delete cfg.password;
                if (!cfg.privateKeyPem) delete cfg.privateKeyPem;
                if (!cfg.passphrase) delete cfg.passphrase;
            }
            if (draft.kind === "s3") {
                if (!cfg.accessKeyId) delete cfg.accessKeyId;
                if (!cfg.secretAccessKey) delete cfg.secretAccessKey;
                if (!cfg.roleArn) delete cfg.roleArn;
                if (!cfg.externalId) delete cfg.externalId;
                if (!cfg.sessionDurationSec) delete cfg.sessionDurationSec;
            }
            // gdrive: we intentionally keep serviceAccountJson in config on save;
            // backend will move it to secrets.

            const payload = {
                id: asCopy ? undefined : draft.id || undefined,
                name: asCopy ? `${draft.name} (copy)` : draft.name.trim(),
                kind: draft.kind,
                config: cfg,
                meta: draft.meta,
            };

            const path =
                !asCopy && draft.id
                    ? `/api/admin/storage/connections/${draft.id}`
                    : "/api/admin/storage/connections";
            await jfetch(path, {
                method: !asCopy && draft.id ? "PUT" : "POST",
                headers: { "Content-Type": "application/json" },
                body: payload,
            });

            toast({
                title: asCopy ? "Connection duplicated" : "Connection saved",
                variant: "success",
                kind: "success",
            });
            await refresh();

            setDraft((d) => {
                const clean = { ...d };
                if (clean.kind === "nextcloud")
                    (clean.config as NextcloudConnConfig).password = "";
                if (clean.kind === "sftp") {
                    (clean.config as SftpConnConfig).password = "";
                    (clean.config as SftpConnConfig).privateKeyPem = "";
                    (clean.config as SftpConnConfig).passphrase = "";
                }
                if (clean.kind === "s3") {
                    (clean.config as S3ConnConfig).accessKeyId = "";
                    (clean.config as S3ConnConfig).secretAccessKey = "";
                }
                // gdrive: leave as-is; sensitive JSON is already moved server-side
                return clean;
            });
            setErrors([]);
        } catch (e: any) {
            toast({
                title: e?.message ?? "Save failed",
                variant: "destructive",
                kind: "destructive",
            });
        } finally {
            setSaving(false);
        }
    }

    async function testDraft() {
        const errs = validate();
        setErrors(errs);
        if (errs.length) {
            errs.forEach((e) =>
                toast({
                    title: e,
                    variant: "destructive",
                    kind: "destructive",
                })
            );
            return;
        }
        setTesting(true);
        try {
            const cfg: any = { ...(draft.config as any) };
            if (draft.kind === "nextcloud" && !cfg.password) delete cfg.password;
            if (draft.kind === "sftp") {
                if (!cfg.password) delete cfg.password;
                if (!cfg.privateKeyPem) delete cfg.privateKeyPem;
                if (!cfg.passphrase) delete cfg.passphrase;
            }
            if (draft.kind === "s3") {
                if (!cfg.accessKeyId) delete cfg.accessKeyId;
                if (!cfg.secretAccessKey) delete cfg.secretAccessKey;
            }

            const res = await jfetch<{
                ok: boolean;
                phases?: Record<string, boolean>;
                detail?: string;
            }>("/api/admin/storage/test", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: {
                    id: draft.id || undefined,
                    kind: draft.kind,
                    config: cfg,
                    meta: draft.meta,
                    probe: "write-read-delete",
                },
            });
            const detail = res?.phases
                ? ` (${Object.entries(res.phases)
                    .map(([k, v]) => `${k}:${v ? "ok" : "fail"}`)
                    .join(", ")})`
                : res?.detail || "";
            toast({
                title: res?.ok ? "Connection healthy" : "Connection check failed",
                description: detail,
                variant: res?.ok ? "success" : "destructive",
                kind: res?.ok ? "success" : "destructive",
            });
            refresh();
        } catch (e: any) {
            toast({
                title: e?.message ?? "Test failed",
                variant: "destructive",
                kind: "destructive",
            });
        } finally {
            setTesting(false);
        }
    }

    async function removeSelected() {
        if (!selected) return;
        try {
            let deps: DependentsResp | null = null;
            try {
                deps = await jfetch<DependentsResp>(
                    `/api/admin/storage/connections/${selected.id}/dependents`
                );
            } catch { }
            const used = (deps?.features ?? []).filter((f) => (f.ids?.length ?? 0) > 0);
            if (used.length > 0) {
                const lines = used
                    .map(
                        (f) => `${f.name}${f.ids && f.ids.length ? ` (${f.ids.length})` : ""}`
                    )
                    .join(", ");
                toast({
                    title: "Cannot delete: connection in use",
                    description: `Remove usages first: ${lines}`,
                    variant: "destructive",
                    kind: "destructive",
                });
                return;
            }
            await jfetch(`/api/admin/storage/connections/${selected.id}`, {
                method: "DELETE",
            });
            toast({
                title: "Connection deleted",
                variant: "default",
                kind: "default",
            });
            await refresh();
            setSelectedId((prev) => {
                const list = connections.filter((c) => c.id !== selected.id);
                return list[0]?.id ?? null;
            });
        } catch (e: any) {
            toast({
                title: e?.message ?? "Delete failed",
                variant: "destructive",
                kind: "destructive",
            });
        }
    }

    function exportJson() {
        const out = { ...draft, config: { ...(draft.config as any) } };
        if (out.kind === "nextcloud") delete (out.config as any).password;
        if (out.kind === "sftp") {
            delete (out.config as any).password;
            delete (out.config as any).privateKeyPem;
            delete (out.config as any).passphrase;
        }
        if (out.kind === "s3") {
            delete (out.config as any).accessKeyId;
            delete (out.config as any).secretAccessKey;
        }
        const blob = new Blob([JSON.stringify(out, null, 2)], {
            type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${draft.name || "connection"}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function importFile(e: React.ChangeEvent<HTMLInputElement>) {
        const file = e.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            try {
                const obj = JSON.parse(String(reader.result) || "{}");

                // --- Branch 1: Imported an exported StorageConnection JSON (our own format)
                const looksLikeConnection =
                    obj &&
                    typeof obj === "object" &&
                    obj.kind &&
                    obj.config &&
                    (typeof obj.name === "string" || obj.name === "");

                // --- Branch 2: Imported a raw Google service account JSON
                const looksLikeGService =
                    obj &&
                    typeof obj === "object" &&
                    obj.type === "service_account" &&
                    typeof obj.client_email === "string" &&
                    typeof obj.private_key === "string";

                if (looksLikeConnection) {
                    // sanitize secrets as usual
                    if (obj.kind === "nextcloud" && obj.config) obj.config.password = "";
                    if (obj.kind === "sftp" && obj.config) {
                        obj.config.password = "";
                        obj.config.privateKeyPem = "";
                        obj.config.passphrase = "";
                    }
                    if (obj.kind === "s3" && obj.config) {
                        obj.config.accessKeyId = "";
                        obj.config.secretAccessKey = "";
                    }
                    setDraft(obj);
                    setTagsRaw(toCsv(obj?.meta?.tags ?? []));
                    setErrors([]);
                    toast({
                        title: "Imported connection JSON",
                        variant: "success",
                        kind: "success",
                    });
                    return;
                }

                if (looksLikeGService) {
                    // Build a brand-new GDrive draft using the service account JSON
                    const suggestedName =
                        (obj.client_email as string)
                            ?.replace("@", " @ ")
                            ?.replace(".iam.gserviceaccount.com", "") ||
                        obj.project_id ||
                        "Google Drive (Service Account)";

                    const newDraft: StorageConnection = {
                        id: "",
                        name: suggestedName,
                        kind: "gdrive",
                        config: {
                            folderId: "",
                            // Let backend move this into secrets via partitionSecrets
                            serviceAccountJson: obj,
                            accountEmail: obj.client_email,
                            authMode: "service_account",
                        } as unknown as GDriveConnConfig,
                        meta: {
                            environment: "dev",
                            tags: ["gdrive", "backups"],
                            defaultFor: { backups: false, exports: false, artifacts: false },
                            encryptionAtRest: false,
                            compression: "none",
                        },
                        capabilities: {
                            canUse: true,
                            canEdit: true,
                            canRotate: true,
                            canDelete: true,
                        },
                        health: { status: "unknown" },
                    };

                    setDraft(newDraft);
                    setTagsRaw(toCsv(newDraft.meta?.tags ?? []));
                    setErrors([]);

                    toast({
                        title: "Google service account imported",
                        description:
                            "Paste the Drive Folder ID and click Save. Remember to share that folder with this service account email.",
                        variant: "success",
                        kind: "success",
                    });
                    return;
                }

                // Fallback: not recognized
                throw new Error(
                    "Unsupported JSON. Import an exported connection JSON or a Google service account JSON."
                );
            } catch (err: any) {
                toast({
                    title: "Invalid JSON",
                    description: err?.message,
                    variant: "destructive",
                    kind: "destructive",
                });
            }
        };
        reader.readAsText(file);
        e.currentTarget.value = "";
    }

    async function browseNextcloud() {
        if (draft.kind !== "nextcloud") return;
        setBrowsing("nextcloud");
        try {
            const cfg: any = { ...(draft.config as any) };
            delete cfg.password; // ensure server reads stored secret

            const res = await jfetch<{
                ok: boolean;
                dirs?: string[];
                error?: string;
            }>("/api/admin/storage/browse", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: {
                    kind: "nextcloud",
                    connectionId: draft.id || undefined,
                    config: cfg,
                    path: (draft.config as any).path || "/",
                },
            });

            const dirs = res?.dirs ?? [];
            setDraft((d) => ({
                ...d,
                config: { ...(d.config as any), _browse: dirs },
            }));
            if (!res?.ok) throw new Error(res?.error || "Browse failed");
        } catch (e: any) {
            toast({
                title: e?.message ?? "Browse failed",
                variant: "destructive",
                kind: "destructive",
            });
        } finally {
            setBrowsing(null);
        }
    }

    const healthColor =
        draft.health?.status === "healthy"
            ? "bg-emerald-500"
            : draft.health?.status === "unhealthy"
                ? "bg-red-500"
                : "bg-zinc-400";

    const hasBlockingErrors = errors.length > 0;

    return (
        <TabsContent value="storage" className="mt-0">
            <Card>
                <CardHeader>
                    <CardTitle className="flex items-center gap-2">
                        <Cloud className="h-5 w-5" />
                        Storage
                        <Badge variant="secondary" className="ml-1">
                            Connections
                        </Badge>
                        <span
                            className={`inline-block h-2 w-2 rounded-full ${healthColor}`}
                            title={`Health: ${draft.health?.status || "unknown"}`}
                        />
                        <span className="text-xs text-muted-foreground">
                            {draft.health?.lastCheckedAt
                                ? `Last checked: ${(draft.health.lastCheckedAt || "")
                                    .replace("T", " ")
                                    .slice(0, 16)}`
                                : "Not checked"}
                        </span>
                        {draft.health?.lastResult && (
                            <span className="text-xs text-muted-foreground">
                                · {draft.health.lastResult}
                            </span>
                        )}
                    </CardTitle>
                    <CardDescription>
                        Define reusable storage connections. Backups/Exports/Artifacts
                        reference a connection by name so credentials remain centralized and
                        secure.
                    </CardDescription>
                </CardHeader>

                <CardContent className="space-y-8">
                    {errors.length > 0 && (
                        <div className="rounded-md border border-red-300/60 bg-red-50/40 p-3 text-sm text-red-700 dark:border-red-900/50 dark:bg-red-950/30 dark:text-red-300">
                            <div className="font-medium mb-1">Please fix the following:</div>
                            <ul className="list-disc ml-5 space-y-0.5">
                                {errors.map((e, i) => (
                                    <li key={i}>{e}</li>
                                ))}
                            </ul>
                        </div>
                    )}

                    <div className="rounded-md border p-4 space-y-4 bg-muted/30">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <Database className="h-4 w-4" />
                                <div className="font-medium">Connections</div>
                            </div>
                            <div className="flex items-center gap-2">
                                <Button
                                    type="button"
                                    variant="outline"
                                    size="sm"
                                    onClick={() => refresh()}
                                >
                                    <RefreshCcw className="h-4 w-4 mr-2" /> Refresh
                                </Button>
                                <Button
                                    type="button"
                                    size="sm"
                                    onClick={() => resetToNew("s3")}
                                    disabled={!canEdit}
                                >
                                    <Plus className="h-4 w-4 mr-2" /> New
                                </Button>
                                <Button
                                    type="button"
                                    size="sm"
                                    variant="outline"
                                    onClick={() => saveDraft(true)}
                                    disabled={!canEdit}
                                >
                                    <Copy className="h-4 w-4 mr-2" /> Save as copy
                                </Button>
                                <Button
                                    type="button"
                                    size="sm"
                                    variant="outline"
                                    onClick={exportJson}
                                >
                                    <DownloadIcon className="h-4 w-4 mr-2" /> Export JSON
                                </Button>
                                <label
                                    className={`inline-flex items-center gap-2 text-sm px-3 py-2 rounded-md border ${canEdit ? "cursor-pointer" : "opacity-60 cursor-not-allowed"
                                        }`}
                                >
                                    <Upload className="h-4 w-4" />
                                    Import JSON
                                    <input
                                        type="file"
                                        accept="application/json"
                                        onChange={canEdit ? importFile : undefined}
                                        className="hidden"
                                        disabled={!canEdit}
                                    />
                                </label>
                            </div>
                        </div>

                        <div className="grid gap-4 md:grid-cols-12 items-start">
                            <div className="md:col-span-9">
                                <div className="grid gap-3 md:grid-cols-12 items-start">
                                    <div className="md:col-span-4 self-start">
                                        <Label className="text-sm">Edit existing connection</Label>
                                        {loading ? (
                                            <Skeleton className="h-9 w-full" />
                                        ) : (
                                            <Select
                                                value={selectedId ?? ""}
                                                onValueChange={onIfEditable<string | "">((v) =>
                                                    setSelectedId(v || null)
                                                )}
                                            >
                                                <SelectTrigger>
                                                    <SelectValue
                                                        placeholder={
                                                            connections.length
                                                                ? "Choose to edit…"
                                                                : "No connections yet"
                                                        }
                                                    />
                                                </SelectTrigger>
                                                <SelectContent>
                                                    {connections.map((c) => (
                                                        <SelectItem key={c.id} value={c.id}>
                                                            {c.name}{" "}
                                                            <span className="text-muted-foreground">· {c.kind}</span>
                                                        </SelectItem>
                                                    ))}
                                                    {connections.length === 0 && (
                                                        <SelectItem value="__none" disabled>
                                                            No connections
                                                        </SelectItem>
                                                    )}
                                                </SelectContent>
                                            </Select>
                                        )}
                                    </div>

                                    <div className="md:col-span-4 self-start">
                                        <Label className="text-sm">Kind</Label>
                                        <Select
                                            value={draft.kind}
                                            onValueChange={onIfEditable<StorageKind>((v) => resetToNew(v))}
                                        >
                                            <SelectTrigger>
                                                <SelectValue placeholder="Select kind" />
                                            </SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="s3">S3 / MinIO</SelectItem>
                                                <SelectItem value="nextcloud">Nextcloud (WebDAV)</SelectItem>
                                                <SelectItem value="gdrive">Google Drive</SelectItem>
                                                <SelectItem value="sftp">Remote SFTP</SelectItem>
                                            </SelectContent>
                                        </Select>
                                    </div>

                                    <div className="md:col-span-4 self-start">
                                        <LabeledInput
                                            label="Name"
                                            value={draft.name}
                                            onChange={onIfEditable<string>((v) =>
                                                setDraft((d) => ({ ...d, name: v }))
                                            )}
                                            placeholder="e.g. Prod S3, Offsite Nextcloud, GDrive Backups"
                                        />
                                    </div>

                                    <div className="md:col-span-4 self-start">
                                        <Label className="text-sm">Environment</Label>
                                        <Select
                                            value={draft.meta?.environment ?? "dev"}
                                            onValueChange={onIfEditable<Env>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: { ...(d.meta || {}), environment: v },
                                                }))
                                            )}
                                        >
                                            <SelectTrigger>
                                                <SelectValue />
                                            </SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="dev">Dev</SelectItem>
                                                <SelectItem value="staging">Staging</SelectItem>
                                                <SelectItem value="prod">Prod</SelectItem>
                                            </SelectContent>
                                        </Select>
                                    </div>

                                    {/* TAGS */}
                                    <div className="md:col-span-8 self-start">
                                        <div className="grid gap-1">
                                            <Label className="text-sm">Tags (comma-separated)</Label>
                                            <Input
                                                type="text"
                                                inputMode="text"
                                                autoComplete="off"
                                                spellCheck={false}
                                                value={tagsRaw}
                                                onChange={(e) => {
                                                    if (!canEdit) return;
                                                    const v = e.currentTarget.value;
                                                    setTagsRaw(v);
                                                    const parsed = v
                                                        .split(",")
                                                        .map((x) => x.trim())
                                                        .filter(Boolean);
                                                    setDraft((d) => ({
                                                        ...d,
                                                        meta: { ...(d.meta || {}), tags: parsed },
                                                    }));
                                                }}
                                                placeholder="backup, offsite, cost-optimized"
                                            />
                                            <span className="text-[11px] text-muted-foreground">
                                                Separate tags with commas. Spaces are OK.
                                            </span>
                                        </div>
                                    </div>

                                    <div className="md:col-span-12">
                                        <p className="text-xs text-muted-foreground">
                                            Backups choose a connection in the{" "}
                                            <span className="font-medium">Backups</span> tab. This
                                            selector is only for editing/testing saved connections.
                                        </p>
                                    </div>
                                </div>
                            </div>

                            <div className="md:col-span-3 md:self-stretch">
                                <div className="rounded-md border p-3 h-full">
                                    <div className="text-xs font-medium uppercase text-muted-foreground tracking-wide">
                                        Defaults
                                    </div>
                                    <div className="mt-2 space-y-2">
                                        <CheckToggle
                                            label="Default for Backups"
                                            checked={!!draft.meta?.defaultFor?.backups}
                                            onChange={onIfEditable<boolean>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: {
                                                        ...(d.meta || {}),
                                                        defaultFor: {
                                                            ...(d.meta?.defaultFor || {}),
                                                            backups: v,
                                                        },
                                                    },
                                                }))
                                            )}
                                        />
                                        <CheckToggle
                                            label="Default for Exports"
                                            checked={!!draft.meta?.defaultFor?.exports}
                                            onChange={onIfEditable<boolean>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: {
                                                        ...(d.meta || {}),
                                                        defaultFor: {
                                                            ...(d.meta?.defaultFor || {}),
                                                            exports: v,
                                                        },
                                                    },
                                                }))
                                            )}
                                        />
                                        <CheckToggle
                                            label="Default for Artifacts"
                                            checked={!!draft.meta?.defaultFor?.artifacts}
                                            onChange={onIfEditable<boolean>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: {
                                                        ...(d.meta || {}),
                                                        defaultFor: {
                                                            ...(d.meta?.defaultFor || {}),
                                                            artifacts: v,
                                                        },
                                                    },
                                                }))
                                            )}
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Per-kind form */}
                    <div className="rounded-md border p-4 bg-muted/20 space-y-6">
                        {draft.kind === "s3" && (
                            <div className="space-y-6">
                                <div className="grid gap-4 md:grid-cols-3">
                                    <div className="grid gap-1">
                                        <Label className="text-sm">Provider</Label>
                                        <Select
                                            value={(draft.config as S3ConnConfig)?.provider ?? "aws"}
                                            onValueChange={onIfEditable<"aws" | "minio" | "wasabi" | "other">(
                                                (v) =>
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: { ...(d.config as S3ConnConfig), provider: v },
                                                    }))
                                            )}
                                        >
                                            <SelectTrigger>
                                                <SelectValue />
                                            </SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="aws">AWS S3</SelectItem>
                                                <SelectItem value="minio">MinIO</SelectItem>
                                                <SelectItem value="wasabi">Wasabi</SelectItem>
                                                <SelectItem value="other">Other</SelectItem>
                                            </SelectContent>
                                        </Select>
                                    </div>

                                    <LabeledInput
                                        label="Region"
                                        value={(draft.config as S3ConnConfig)?.region ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), region: v },
                                            }))
                                        )}
                                    />
                                    <div className="grid gap-1">
                                        <LabeledInput
                                            label="Bucket"
                                            value={(draft.config as S3ConnConfig)?.bucket ?? ""}
                                            onChange={onIfEditable<string>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    config: { ...(d.config as S3ConnConfig), bucket: v },
                                                }))
                                            )}
                                        />
                                        {!errors.length &&
                                            !((draft.config as S3ConnConfig)?.bucket ?? "").trim() && (
                                                <span className="text-[11px] text-muted-foreground">
                                                    Required for S3 connections.
                                                </span>
                                            )}
                                    </div>
                                    <LabeledInput
                                        label="Endpoint (MinIO/Other)"
                                        value={(draft.config as S3ConnConfig)?.endpoint ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), endpoint: v },
                                            }))
                                        )}
                                    />
                                    <LabeledInput
                                        label="Key prefix (optional)"
                                        value={(draft.config as S3ConnConfig)?.prefix ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), prefix: v },
                                            }))
                                        )}
                                    />
                                    <div className="flex items-center gap-4 mt-6">
                                        <CheckToggle
                                            label="Path-style access"
                                            checked={!!(draft.config as S3ConnConfig)?.pathStyle}
                                            onChange={onIfEditable<boolean>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    config: { ...(d.config as S3ConnConfig), pathStyle: v },
                                                }))
                                            )}
                                        />
                                    </div>
                                </div>

                                <Separator />

                                <div className="grid gap-4 md:grid-cols-3">
                                    <div className="grid gap-1">
                                        <Label className="text-sm">Server-side encryption</Label>
                                        <Select
                                            value={((draft.config as S3ConnConfig)?.sse as any) ?? "none"}
                                            onValueChange={onIfEditable<"none" | "AES256" | "aws:kms">(
                                                (v) =>
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: { ...(d.config as S3ConnConfig), sse: v },
                                                    }))
                                            )}
                                        >
                                            <SelectTrigger>
                                                <SelectValue />
                                            </SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="none">None</SelectItem>
                                                <SelectItem value="AES256">AES256</SelectItem>
                                                <SelectItem value="aws:kms">AWS KMS</SelectItem>
                                            </SelectContent>
                                        </Select>
                                    </div>
                                    {(draft.config as S3ConnConfig)?.sse === "aws:kms" && (
                                        <div className="grid gap-1">
                                            <LabeledInput
                                                label="KMS Key ID (ARN)"
                                                value={(draft.config as S3ConnConfig)?.kmsKeyId ?? ""}
                                                onChange={onIfEditable<string>((v) =>
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: { ...(d.config as S3ConnConfig), kmsKeyId: v },
                                                    }))
                                                )}
                                            />
                                            {!errors.length &&
                                                (draft.config as S3ConnConfig)?.sse === "aws:kms" &&
                                                !((draft.config as S3ConnConfig)?.kmsKeyId ?? "").trim() && (
                                                    <span className="text-[11px] text-muted-foreground">
                                                        Required when using AWS KMS.
                                                    </span>
                                                )}
                                        </div>
                                    )}
                                </div>

                                <Separator />

                                <div className="grid gap-4 md:grid-cols-3">
                                    <LabeledInput
                                        label="Access Key ID (optional)"
                                        value={(draft.config as S3ConnConfig)?.accessKeyId ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), accessKeyId: v },
                                            }))
                                        )}
                                        placeholder={draft.hasSecret?.s3Credentials ? "•••••••• (set)" : ""}
                                    />
                                    <LabeledInput
                                        label="Secret Access Key (optional)"
                                        type="password"
                                        value={(draft.config as S3ConnConfig)?.secretAccessKey ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as S3ConnConfig),
                                                    secretAccessKey: v,
                                                },
                                            }))
                                        )}
                                        placeholder={draft.hasSecret?.s3Credentials ? "•••••••• (set)" : ""}
                                    />
                                    <LabeledInput
                                        label="Assume Role ARN (optional)"
                                        value={(draft.config as S3ConnConfig)?.roleArn ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), roleArn: v },
                                            }))
                                        )}
                                        placeholder="arn:aws:iam::123456789012:role/RemoteIQBackupRole"
                                    />
                                    <LabeledInput
                                        label="External ID (optional)"
                                        value={(draft.config as S3ConnConfig)?.externalId ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), externalId: v },
                                            }))
                                        )}
                                    />
                                    <LabeledNumber
                                        label="STS Session Duration (sec)"
                                        value={(draft.config as S3ConnConfig)?.sessionDurationSec ?? 3600}
                                        onChange={onIfEditable<string | number>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as S3ConnConfig),
                                                    sessionDurationSec: v === "" ? 3600 : Number(v),
                                                },
                                            }))
                                        )}
                                    />
                                </div>

                                {(draft.config as S3ConnConfig)?.bucketLifecycleSummary && (
                                    <div className="flex items-center gap-2 text-xs text-muted-foreground">
                                        <ShieldCheck className="h-3.5 w-3.5" />
                                        Lifecycle: {(draft.config as S3ConnConfig).bucketLifecycleSummary}
                                    </div>
                                )}
                            </div>
                        )}

                        {draft.kind === "nextcloud" && (
                            <div className="space-y-4">
                                <div className="grid gap-4 md:grid-cols-3">
                                    <LabeledInput
                                        label="WebDAV URL"
                                        value={(draft.config as NextcloudConnConfig)?.webdavUrl ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as NextcloudConnConfig),
                                                    webdavUrl: v,
                                                },
                                            }))
                                        )}
                                        placeholder="https://cloud.example.com/remote.php/dav/files/username/"
                                    />
                                    <LabeledInput
                                        label="Username"
                                        value={(draft.config as NextcloudConnConfig)?.username ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as NextcloudConnConfig),
                                                    username: v,
                                                },
                                            }))
                                        )}
                                    />

                                    {/* Password with eye toggle */}
                                    <div className="grid gap-1">
                                        <Label className="text-sm">Password</Label>
                                        <div className="relative">
                                            <Input
                                                type={showNcPassword ? "text" : "password"}
                                                autoComplete="new-password"
                                                name="nc-password"
                                                data-lpignore="true"
                                                data-1p-ignore
                                                value={(draft.config as NextcloudConnConfig)?.password ?? ""}
                                                onChange={(e) => {
                                                    if (!canEdit) return;
                                                    const v = e.currentTarget.value;
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: {
                                                            ...(d.config as NextcloudConnConfig),
                                                            password: v,
                                                        },
                                                    }));
                                                }}
                                                placeholder={
                                                    draft.hasSecret?.nextcloudPassword ? "•••••••• (set)" : ""
                                                }
                                                className="pr-10"
                                            />
                                            <button
                                                type="button"
                                                onClick={() => setShowNcPassword((s) => !s)}
                                                className="absolute inset-y-0 right-2 inline-flex items-center text-muted-foreground hover:text-foreground"
                                                aria-label={showNcPassword ? "Hide password" : "Show password"}
                                                tabIndex={0}
                                            >
                                                {showNcPassword ? (
                                                    <EyeOff className="h-4 w-4" />
                                                ) : (
                                                    <Eye className="h-4 w-4" />
                                                )}
                                            </button>
                                        </div>
                                    </div>

                                    <LabeledInput
                                        label="Folder path"
                                        value={(draft.config as NextcloudConnConfig)?.path ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as NextcloudConnConfig), path: v },
                                            }))
                                        )}
                                        placeholder="/Backups/RemoteIQ"
                                    />
                                </div>

                                <div className="flex items-center gap-2">
                                    <Button
                                        type="button"
                                        variant="outline"
                                        size="sm"
                                        onClick={browseNextcloud}
                                        disabled={browsing === "nextcloud" || !canEdit}
                                    >
                                        <RefreshCcw className="h-4 w-4 mr-2" />
                                        {browsing === "nextcloud" ? "Browsing…" : "Browse folders"}
                                    </Button>
                                    <span className="text-xs text-muted-foreground">
                                        Fetches subfolders via WebDAV PROPFIND.
                                    </span>
                                </div>

                                {!!(draft.config as NextcloudConnConfig)?._browse?.length && (
                                    <div className="text-xs">
                                        <div className="mb-1 text-muted-foreground">Pick a folder:</div>
                                        <div className="flex flex-wrap gap-2">
                                            {(draft.config as NextcloudConnConfig)._browse!.map((dir) => (
                                                <button
                                                    key={dir}
                                                    type="button"
                                                    onClick={() => {
                                                        if (!canEdit) return;
                                                        setDraft((d) => ({
                                                            ...d,
                                                            config: {
                                                                ...(d.config as NextcloudConnConfig),
                                                                path: dir,
                                                            },
                                                        }));
                                                    }}
                                                    className={`rounded border px-2 py-1 hover:bg-muted ${!canEdit ? "opacity-60 cursor-not-allowed" : ""
                                                        }`}
                                                >
                                                    {dir}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {draft.kind === "gdrive" && (
                            <div className="grid gap-4 md:grid-cols-3">
                                <LabeledInput
                                    label="Folder ID"
                                    value={(draft.config as GDriveConnConfig)?.folderId ?? ""}
                                    onChange={onIfEditable<string>((v) =>
                                        setDraft((d) => ({
                                            ...d,
                                            config: { ...(d.config as GDriveConnConfig), folderId: v },
                                        }))
                                    )}
                                    placeholder="1aBcD2EfGhIjKlMnOpQrStUvWxYz"
                                />
                                <div className="grid gap-1">
                                    <Label className="text-sm">Connected account</Label>
                                    <Input
                                        value={(draft.config as GDriveConnConfig)?.accountEmail ?? ""}
                                        readOnly
                                        placeholder="(from service account JSON)"
                                    />
                                </div>
                                <div className="grid gap-1">
                                    <Label className="text-sm">Auth mode</Label>
                                    <Input
                                        value={(draft.config as GDriveConnConfig)?.authMode ?? ""}
                                        readOnly
                                        placeholder="(server provided)"
                                    />
                                </div>
                                <p className="text-xs text-muted-foreground md:col-span-3">
                                    Import your Google <span className="font-medium">service account</span> JSON using
                                    the <span className="font-medium">Import JSON</span> button. Then paste the
                                    target Drive <span className="font-medium">Folder ID</span> and save. Be sure
                                    to share that folder with the service account email.
                                </p>
                            </div>
                        )}

                        {draft.kind === "sftp" && (
                            <div className="space-y-4">
                                <div className="grid gap-4 md:grid-cols-3">
                                    <LabeledInput
                                        label="Host / IP"
                                        value={(draft.config as SftpConnConfig)?.host ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as SftpConnConfig), host: v },
                                            }))
                                        )}
                                    />
                                    <LabeledNumber
                                        label="Port"
                                        value={(draft.config as SftpConnConfig)?.port ?? 22}
                                        onChange={onIfEditable<string | number>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as SftpConnConfig),
                                                    port: v === "" ? 22 : Number(v),
                                                },
                                            }))
                                        )}
                                    />
                                    <LabeledInput
                                        label="Username"
                                        value={(draft.config as SftpConnConfig)?.username ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as SftpConnConfig),
                                                    username: v,
                                                },
                                            }))
                                        )}
                                    />
                                    <LabeledInput
                                        label="Password (optional)"
                                        type="password"
                                        value={(draft.config as SftpConnConfig)?.password ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as SftpConnConfig),
                                                    password: v,
                                                },
                                            }))
                                        )}
                                        placeholder={draft.hasSecret?.sftpPassword ? "•••••••• (set)" : ""}
                                    />
                                    <div className="md:col-span-3 grid md:grid-cols-3 gap-4">
                                        <div className="grid gap-1 md:col-span-2">
                                            <Label className="text-sm">Private key (PEM, optional)</Label>
                                            <textarea
                                                className="h-28 w-full rounded-md border bg-background px-3 py-2 text-sm"
                                                placeholder={
                                                    draft.hasSecret?.sftpPrivateKey
                                                        ? "•••••••• (set)"
                                                        : "-----BEGIN OPENSSH PRIVATE KEY-----"
                                                }
                                                value={(draft.config as SftpConnConfig)?.privateKeyPem ?? ""}
                                                onChange={(e) =>
                                                    canEdit &&
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: {
                                                            ...(d.config as SftpConnConfig),
                                                            privateKeyPem: e.target.value,
                                                        },
                                                    }))
                                                }
                                            />
                                        </div>
                                        <LabeledInput
                                            label="Passphrase (optional)"
                                            type="password"
                                            value={(draft.config as SftpConnConfig)?.passphrase ?? ""}
                                            onChange={onIfEditable<string>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    config: { ...(d.config as SftpConnConfig), passphrase: v },
                                                }))
                                            )}
                                        />
                                    </div>
                                    <LabeledInput
                                        label="Host key fingerprint (pin, optional)"
                                        value={(draft.config as SftpConnConfig)?.hostKeyFingerprint ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as SftpConnConfig),
                                                    hostKeyFingerprint: v,
                                                },
                                            }))
                                        )}
                                        placeholder="SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                                    />
                                    <LabeledInput
                                        label="Directory (absolute)"
                                        value={(draft.config as SftpConnConfig)?.path ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as SftpConnConfig), path: v },
                                            }))
                                        )}
                                        placeholder="/srv/remoteiq/backups"
                                    />
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="rounded-md border p-4">
                        <div className="grid gap-4 md:grid-cols-4">
                            <LabeledNumber
                                label="Bandwidth limit (MB/s, optional)"
                                value={draft.meta?.bandwidthLimitMBps ?? ""}
                                onChange={onIfEditable<string | number>((v) =>
                                    setDraft((d) => ({
                                        ...d,
                                        meta: {
                                            ...(d.meta || {}),
                                            bandwidthLimitMBps: v === "" ? undefined : Number(v),
                                        },
                                    }))
                                )}
                            />
                            <LabeledNumber
                                label="Concurrency (optional)"
                                value={draft.meta?.concurrency ?? ""}
                                onChange={onIfEditable<string | number>((v) =>
                                    setDraft((d) => ({
                                        ...d,
                                        meta: {
                                            ...(d.meta || {}),
                                            concurrency: v === "" ? undefined : Number(v),
                                        },
                                    }))
                                )}
                            />
                            <div className="grid gap-1">
                                <Label className="text-sm">Compression</Label>
                                <Select
                                    value={draft.meta?.compression ?? "none"}
                                    onValueChange={onIfEditable<"none" | "gzip" | "zstd">((v) =>
                                        setDraft((d) => ({
                                            ...d,
                                            meta: { ...(d.meta || {}), compression: v },
                                        }))
                                    )}
                                >
                                    <SelectTrigger>
                                        <SelectValue />
                                    </SelectTrigger>
                                    <SelectContent>
                                        <SelectItem value="none">None</SelectItem>
                                        <SelectItem value="gzip">Gzip</SelectItem>
                                        <SelectItem value="zstd">Zstd</SelectItem>
                                    </SelectContent>
                                </Select>
                            </div>
                            <div className="flex items-end">
                                <CheckToggle
                                    label="Pipeline encryption at rest"
                                    checked={!!draft.meta?.encryptionAtRest}
                                    onChange={onIfEditable<boolean>((v) =>
                                        setDraft((d) => ({
                                            ...d,
                                            meta: { ...(d.meta || {}), encryptionAtRest: v },
                                        }))
                                    )}
                                />
                            </div>
                        </div>

                        {(draft.meta?.createdBy ||
                            draft.meta?.updatedBy ||
                            draft.meta?.createdAt ||
                            draft.meta?.updatedAt) && (
                                <div className="flex flex-wrap gap-3 text-xs text-muted-foreground mt-3">
                                    {draft.meta?.createdBy && (
                                        <span>Created by: {draft.meta.createdBy}</span>
                                    )}
                                    {draft.meta?.createdAt && (
                                        <span>
                                            at {(draft.meta.createdAt || "").replace("T", " ").slice(0, 16)}
                                        </span>
                                    )}
                                    {draft.meta?.updatedBy && (
                                        <span>· Updated by: {draft.meta.updatedBy}</span>
                                    )}
                                    {draft.meta?.updatedAt && (
                                        <span>
                                            at {(draft.meta.updatedAt || "").replace("T", " ").slice(0, 16)}
                                        </span>
                                    )}
                                </div>
                            )}

                        <div className="mt-4 flex items-center justify-end gap-2">
                            <Button variant="outline" onClick={testDraft} disabled={testing || !canEdit}>
                                <RefreshCcw className="h-4 w-4 mr-2" />
                                {testing ? "Testing…" : "Test connection"}
                            </Button>

                            {selected && (
                                <>
                                    <Button
                                        variant="destructive"
                                        onClick={() => setConfirmDeleteOpen(true)}
                                        disabled={!canDelete}
                                    >
                                        <Trash2 className="h-4 w-4 mr-2" /> Delete
                                    </Button>
                                    <AlertDialog
                                        open={confirmDeleteOpen}
                                        onOpenChange={setConfirmDeleteOpen}
                                    >
                                        <AlertDialogContent>
                                            <AlertDialogHeader>
                                                <AlertDialogTitle>Delete connection?</AlertDialogTitle>
                                                <AlertDialogDescription>
                                                    This action cannot be undone. Any features that use{" "}
                                                    <span className="font-medium">{selected?.name}</span> will
                                                    stop working until you reconfigure them.
                                                </AlertDialogDescription>
                                            </AlertDialogHeader>
                                            <AlertDialogFooter>
                                                <AlertDialogCancel>Cancel</AlertDialogCancel>
                                                <AlertDialogAction
                                                    onClick={removeSelected}
                                                    className="bg-red-600 text-white hover:bg-red-700"
                                                >
                                                    Delete
                                                </AlertDialogAction>
                                            </AlertDialogFooter>
                                        </AlertDialogContent>
                                    </AlertDialog>
                                </>
                            )}

                            {!canEdit && (
                                <span className="text-xs text-muted-foreground flex items-center gap-1">
                                    <AlertTriangle className="h-3.5 w-3.5" /> You don’t have edit permission.
                                </span>
                            )}
                            <Button
                                onClick={() => saveDraft(false)}
                                disabled={saving || !canEdit || hasBlockingErrors}
                            >
                                <Save className="h-4 w-4 mr-2" />
                                {saving ? "Saving…" : "Save connection"}
                            </Button>
                        </div>
                    </div>

                    <div className="rounded-md border p-3">
                        <div className="flex items-center gap-2 text-sm font-medium">
                            <Cable className="h-4 w-4" /> How it integrates
                        </div>
                        <p className="text-sm text-muted-foreground mt-2">
                            Features reference a <span className="font-medium">connection name</span>, not raw
                            credentials. This centralizes secrets, enables rotation &amp; RBAC,
                            and keeps the UI safer.
                        </p>
                    </div>
                </CardContent>
            </Card>
        </TabsContent>
    );
}


``r

--------------------------------------------------------------------------------
| Frontend Â· lib/backups.ts (API client & types) |
--------------------------------------------------------------------------------

[FILE] C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-frontend\lib\backups.ts

``r

// remoteiq-frontend/lib/backups.ts
// Centralized API client for the Backups feature.
// Mirrors the pattern used by lib/storage.ts so UI tabs stay clean.

import { jfetch } from "@/lib/api";

// ---- Shared types (UI already has more detailed ones in ../types) ----
export type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";
export type ConnectionLite = { id: string; name: string; kind: StorageKind };

export type BackupTarget =
    | "users"
    | "roles"
    | "devices"
    | "policies"
    | "audit_logs"
    | "settings"
    | "templates";

export type HistoryStatus = "any" | "success" | "failed" | "running";

export type BackupHistoryRow = {
    id: string;
    at: string; // "YYYY-MM-DD HH:mm"
    status: "success" | "failed" | "running";
    note?: string;
    // optional server-provided extras:
    sizeBytes?: number;
    durationSec?: number;
    verified?: boolean;
};

export type ScheduleKind = "hourly" | "daily" | "weekly" | "cron";

export type LocalDest = { kind: "local"; path: string };
export type S3Dest = {
    kind: "s3";
    connectionId: string;
    bucket?: string;
    prefix?: string;
};
export type NextcloudDest = {
    kind: "nextcloud";
    connectionId: string;
    path: string;
};
export type GDriveDest = {
    kind: "gdrive";
    connectionId: string;
    subfolder?: string;
};
export type RemoteSFTPDest = {
    kind: "remote";
    connectionId: string;
    path: string;
};
export type Destination =
    | LocalDest
    | S3Dest
    | NextcloudDest
    | GDriveDest
    | RemoteSFTPDest;

export type BackupConfig = {
    enabled: boolean;
    targets: BackupTarget[];
    schedule: ScheduleKind;
    cronExpr?: string;
    retentionDays: number;
    encrypt: boolean;
    destination: Destination;
    notifications?: { email?: boolean; webhook?: boolean; slack?: boolean };
};

export type Permissions = { restore: boolean; download: boolean };

// ---- API: Config / Permissions ----
export async function getBackupConfig() {
    return jfetch<BackupConfig>("/api/admin/backups/config");
}

export async function updateBackupConfig(cfg: BackupConfig) {
    return jfetch("/api/admin/backups/config", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: cfg,
    });
}

export async function getBackupPermissions() {
    return jfetch<Permissions>("/api/admin/backups/permissions");
}

// ---- API: Storage connections (for destination connection pickers) ----
export async function listStorageConnectionsLite() {
    return jfetch<{ items: ConnectionLite[] }>("/api/admin/storage/connections");
}

// ---- API: History ----
export async function listBackupHistory(params: {
    cursor?: string | null;
    status?: Exclude<HistoryStatus, "any">;
    q?: string;
    from?: string; // YYYY-MM-DD
    to?: string; // YYYY-MM-DD
}) {
    const qs = new URLSearchParams();
    if (params.cursor) qs.set("cursor", params.cursor);
    if (params.status) qs.set("status", params.status);
    if (params.q?.trim()) qs.set("q", params.q.trim());
    if (params.from) qs.set("from", params.from);
    if (params.to) qs.set("to", params.to);

    return jfetch<{ items: BackupHistoryRow[]; nextCursor?: string }>(
        `/api/admin/backups/history?${qs.toString()}`
    );
}

// ---- API: Actions ----
export async function runBackupNow() {
    return jfetch<{ id: string; startedAt: string }>("/api/admin/backups/run", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
    });
}

export async function pruneBackups() {
    return jfetch<{ removed?: number }>("/api/admin/backups/prune", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
    });
}

export async function testBackupDestination(destination: Destination) {
    return jfetch<{ ok: boolean; phases?: Record<string, boolean> }>(
        "/api/admin/backups/test-destination",
        {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: { destination },
        }
    );
}

export async function retryBackup(id: string) {
    return jfetch(`/api/admin/backups/${encodeURIComponent(id)}/retry`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
    });
}

export async function cancelBackup(id: string) {
    return jfetch(`/api/admin/backups/${encodeURIComponent(id)}/cancel`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
    });
}

export async function startRestore(id: string) {
    return jfetch(`/api/admin/backups/${encodeURIComponent(id)}/restore`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
    });
}

export async function getCronNextRuns(cronExpr: string, tz: string) {
    return jfetch<{ next: string[] }>(
        `/api/admin/backups/next-runs?cron=${encodeURIComponent(
            cronExpr
        )}&tz=${encodeURIComponent(tz)}`
    );
}


``r

--------------------------------------------------------------------------------
| SUMMARY |
--------------------------------------------------------------------------------

All targeted core files were collected successfully.

