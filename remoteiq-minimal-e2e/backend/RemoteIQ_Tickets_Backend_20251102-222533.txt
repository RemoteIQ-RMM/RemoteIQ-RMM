========================================================================================
RemoteIQ — Tickets Integration Backend Snapshot (NO SQL)
Generated: 2025-11-02 22:25:33 -05:00
Backend root: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend
========================================================================================

This file contains the exact source of the requested backend files (excluding SQL), with
metadata and SHA256 hashes. Sections are numbered and separated for quick navigation.

========================================================================================
[1] FILE
Path       : src/app.module.ts
Size       : 3,251 bytes
Last Write : 2025-10-29 22:38:40
SHA256     : EFACBECC386D0A86C58C5C39AEE009C1B521FA67EC86E2EE4ECF84241BCA9250
========================================================================================

// remoteiq-minimal-e2e/backend/src/app.module.ts

import { Module, MiddlewareConsumer, NestModule } from "@nestjs/common";
import { ServeStaticModule } from "@nestjs/serve-static";
import { join } from "path";

import { CommonModule } from "./common/common.module";
import { AuthModule } from "./auth/auth.module";
import { WsModule } from "./ws/ws.module";
import { AgentsModule } from "./agents/agents.module";
import { JobsModule } from "./jobs/jobs.module";
import { DevicesModule } from "./devices/devices.module";
import { HealthModule } from "./health/health.module";
import { AdminModule } from "./admin/admin.module";
import { CompanyModule } from "./company/company.module";
import { BrandingModule } from "./branding/branding.module";
import { LocalizationModule } from "./localization/localization.module";
import { SupportModule } from "./support/support.module";
import { SupportLegalModule } from "./support-legal/support-legal.module";
import { UsersModule } from "./users/users.module";
import { RolesModule } from "./roles/roles.module";
import { SmtpModule } from "./smtp/smtp.module";
import { ScheduleModule } from "@nestjs/schedule";
import { ImapModule } from "./imap/imap.module";
import { SessionCleanerService } from "./maintenance/session-cleaner.service";

import { JwtModule } from "@nestjs/jwt";

// ✅ correct path: the middleware file is under /auth, not /common
import { AuthCookieMiddleware } from "./auth/auth-cookie.middleware";

// ✅ bring PgPoolService into the AppModule DI context
import { StorageModule } from "./storage/storage.module";

@Module({
    imports: [
        // Static files mounted at /static -> maps to /public
        ServeStaticModule.forRoot({
            rootPath: join(__dirname, "..", "public"),
            serveRoot: "/static",
        }),

        // JwtService for middleware
        JwtModule.register({
            secret: process.env.JWT_SECRET ?? "dev-secret",
        }),

        // Base/shared
        CommonModule,

        // ✅ Storage (PgPoolService) must be available for main.ts interceptor registration
        StorageModule,

        // Feature modules
        BrandingModule,
        AuthModule,
        WsModule,
        AgentsModule,
        JobsModule,
        DevicesModule,
        HealthModule,
        AdminModule,
        CompanyModule,
        LocalizationModule,
        SupportModule,
        SupportLegalModule,
        UsersModule,
        RolesModule,

        // SMTP + IMAP
        SmtpModule,
        ScheduleModule.forRoot(),
        ImapModule,
    ],
    providers: [
        // Daily cleanup of revoked sessions
        SessionCleanerService,
    ],
})
export class AppModule implements NestModule {
    configure(consumer: MiddlewareConsumer) {
        // Apply cookie->req.user middleware to everything except obvious public/static routes
        consumer
            .apply(AuthCookieMiddleware)
            .exclude(
                "healthz",
                "docs",
                "docs/(.*)",
                "static/(.*)",      // static files
                "api/auth/login",   // login doesn’t need req.user
                "api/auth/logout"   // logout doesn’t need req.user
            )
            .forRoutes("*");
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[2] FILE
Path       : src/storage/pg-pool.service.ts
Size       : 3,368 bytes
Last Write : 2025-10-21 12:21:39
SHA256     : 677A5E175769CB6BB7F0CC433367F7448DC7511BEAE0122BC9F99924829A43B0
========================================================================================

//backend\src\storage\pg-pool.service.ts

import { Injectable, OnModuleDestroy } from "@nestjs/common";

// We use require() + loose typing to avoid the “Cannot use namespace … as a type” errors
// that can happen in some TS configs when importing from 'pg'.
const { Pool } = require("pg") as { Pool: any };

export type PgRuntimeConfig = {
    connectionString?: string;
    ssl?: boolean | object;
    max?: number;
    min?: number;
};

@Injectable()
export class PgPoolService implements OnModuleDestroy {
    private pool: any = null;
    private lastKey: string | null = null;

    /** Build a default config from env (used on first access if not configured) */
    private envConfig(): PgRuntimeConfig {
        const url =
            process.env.DATABASE_URL ||
            process.env.PG_URL ||
            "postgres://remoteiq:remoteiqpass@localhost:5432/remoteiq";

        const ssl =
            (process.env.DATABASE_SSL ?? "").toLowerCase() === "true" ? true : false;

        const max = Number.isFinite(+process.env.DATABASE_POOL_MAX!)
            ? Number(process.env.DATABASE_POOL_MAX)
            : 10;
        const min = Number.isFinite(+process.env.DATABASE_POOL_MIN!)
            ? Number(process.env.DATABASE_POOL_MIN)
            : 0;

        return { connectionString: url, ssl, max, min };
    }

    /** Create a stable key for the current config so we can know when to recreate the pool */
    private keyOf(cfg: PgRuntimeConfig): string {
        return JSON.stringify({
            cs: cfg.connectionString ?? "",
            ssl: cfg.ssl ? "1" : "0",
            max: cfg.max ?? 10,
            min: cfg.min ?? 0,
        });
    }

    private makePool(cfg: PgRuntimeConfig): any {
        const base: any = {
            connectionString: cfg.connectionString,
            max: cfg.max ?? 10,
            min: cfg.min ?? 0,
        };
        if (cfg.ssl) {
            base.ssl = cfg.ssl === true ? { rejectUnauthorized: false } : cfg.ssl;
        }
        return new Pool(base);
    }

    /** Ensure pool exists; create from env if needed */
    private ensurePool(): any {
        if (!this.pool) {
            const cfg = this.envConfig();
            this.lastKey = this.keyOf(cfg);
            this.pool = this.makePool(cfg);
        }
        return this.pool!;
    }

    /**
     * Called by admin bootstrap when the database config changes.
     * Recreates the pool if the effective config differs.
     */
    configure(cfg: PgRuntimeConfig) {
        const nextKey = this.keyOf(cfg);
        if (this.pool && this.lastKey === nextKey) return; // no-op

        // tear down previous pool
        if (this.pool) {
            try {
                this.pool.end().catch(() => { });
            } catch { }
            this.pool = null;
        }

        this.pool = this.makePool(cfg);
        this.lastKey = nextKey;
    }

    async query<T = any>(text: string, params?: any[]): Promise<{ rows: T[] }> {
        const res = await this.ensurePool().query(text, params);
        return { rows: res.rows as T[] };
    }

    async onModuleDestroy() {
        if (this.pool) {
            try {
                await this.pool.end();
            } catch { }
            this.pool = null;
        }
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[3] FILE
Path       : src/storage/storage.module.ts
Size       : 310 bytes
Last Write : 2025-10-21 12:22:03
SHA256     : A88B4D5835B31C4900A8BEF2635A9057A3AB3BDB8ACB553BF36C0E255674EAD2
========================================================================================

//backend\src\storage\storage.module.ts

import { Module } from "@nestjs/common";
import { PgPoolService } from "./pg-pool.service";
import { PgBootstrap } from "./pg.bootstrap";

@Module({
    providers: [PgPoolService, PgBootstrap],
    exports: [PgPoolService],
})
export class StorageModule { }



----------------------------------------------------------------------------------------



========================================================================================
[4] FILE
Path       : src/storage/pg.bootstrap.ts
Size       : 1,665 bytes
Last Write : 2025-10-21 20:57:04
SHA256     : 5E794328065DC76D0BC9B9986CA61CF84769D803665C1731CE14C962FA9480FD
========================================================================================

// backend/src/storage/pg.bootstrap.ts
import { Injectable, OnModuleInit, Optional } from "@nestjs/common";
import { PgPoolService } from "./pg-pool.service";

/**
 * Optional bootstrap that applies env-based defaults at startup.
 * If PgPoolService isn’t present in the DI graph, this safely no-ops.
 */
@Injectable()
export class PgBootstrap implements OnModuleInit {
    constructor(@Optional() private readonly pg?: PgPoolService) { }

    onModuleInit() {
        if (!this.pg) {
            // Not wired yet (or not exported/imported). Don’t crash.
            console.warn("PgBootstrap: PgPoolService not found; skipping PG bootstrap.");
            return;
        }

        try {
            this.pg.configure({
                connectionString:
                    process.env.DATABASE_URL ||
                    process.env.PG_URL ||
                    "postgres://remoteiq:remoteiqpass@localhost:5432/remoteiq",
                ssl:
                    (process.env.DATABASE_SSL ?? "").toLowerCase() === "true"
                        ? { rejectUnauthorized: false }
                        : false,
                max: Number.isFinite(+process.env.DATABASE_POOL_MAX!)
                    ? Number(process.env.DATABASE_POOL_MAX)
                    : 10,
                min: Number.isFinite(+process.env.DATABASE_POOL_MIN!)
                    ? Number(process.env.DATABASE_POOL_MIN)
                    : 0,
            });
        } catch (e) {
            console.warn(
                "PgBootstrap: configure() failed:",
                (e as Error)?.message ?? e
            );
        }
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[5] FILE
Path       : src/auth/auth.module.ts
Size       : 1,308 bytes
Last Write : 2025-10-29 13:12:12
SHA256     : FA79AA063B6A3CA3F688F44635D3812CDAC756F039BF1F1DEB6C7782AFF03935
========================================================================================

// backend/src/auth/auth.module.ts
import { Module } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";
import { StorageModule } from "../storage/storage.module";
import { AuthService } from "./auth.service";
import { AuthController } from "./auth.controller";
import { UserAuthService } from "./user-auth.service";

function parseExpiresToSeconds(input: string | undefined, fallbackSeconds: number): number {
  if (!input) return fallbackSeconds;
  if (/^\d+$/.test(input)) return Number(input);
  const m = input.trim().match(/^(\d+)\s*([smhd])$/i);
  if (!m) return fallbackSeconds;
  const n = Number(m[1]);
  const unit = m[2].toLowerCase();
  const factor = unit === "s" ? 1 : unit === "m" ? 60 : unit === "h" ? 3600 : unit === "d" ? 86400 : 1;
  return n * factor;
}
const EXPIRES_IN_SECONDS = parseExpiresToSeconds(process.env.JWT_EXPIRES, 60 * 60 * 24 * 7);

@Module({
  imports: [
    StorageModule, // ✅ PgPoolService lives here; no Prisma
    JwtModule.register({
      secret: process.env.JWT_SECRET ?? "dev-secret",
      signOptions: { expiresIn: EXPIRES_IN_SECONDS },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, UserAuthService],
  exports: [AuthService, UserAuthService, JwtModule],
})
export class AuthModule { }



----------------------------------------------------------------------------------------



========================================================================================
[6] FILE
Path       : src/auth/auth.service.ts
Size       : 3,971 bytes
Last Write : 2025-10-29 13:12:12
SHA256     : 40CBF01FEF9A260E7328A8F7ABCADB95F9EDF29203AD910C8EB20674BC8CDD82
========================================================================================

// backend/src/auth/auth.service.ts
import {
  Injectable,
  UnauthorizedException,
  InternalServerErrorException,
  Logger,
} from "@nestjs/common";
import { createHash, randomBytes } from "node:crypto";
import { PgPoolService } from "../storage/pg-pool.service";

function newOpaqueToken(): string {
  return randomBytes(18).toString("base64url");
}
function hashToken(token: string): string {
  return createHash("sha256").update(token, "utf8").digest("hex");
}

type EnrollInput = {
  enrollmentSecret: string;
  deviceId: string;
  hostname: string;
  os: string;
  arch: string;
  version: string;
};

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(private readonly pg: PgPoolService) { }

  /**
   * Enroll (or re-enroll) an agent.
   * - Validates the shared enrollment secret
   * - If deviceId exists, rotates token & updates metadata
   * - Otherwise creates a new agent
   * - Returns { agentId, agentToken }
   *
   * Tables/columns expected:
   *   agents(id uuid pk, device_id text unique, hostname text, os text, arch text,
   *          version text, token_hash text, created_at timestamptz, updated_at timestamptz)
   */
  async enrollAgent(input: EnrollInput) {
    const expected = process.env.ENROLLMENT_SECRET || "";
    if (!expected || input.enrollmentSecret !== expected) {
      throw new UnauthorizedException("Invalid enrollment secret");
    }

    try {
      const token = newOpaqueToken();
      const tokenHash = hashToken(token);

      // Look up existing agent by deviceId to avoid duplicates
      const existing = await this.pg.query<{ id: string }>(
        `SELECT id FROM agents WHERE device_id = $1 LIMIT 1`,
        [input.deviceId],
      );

      let agentId: string;

      if (existing.rows[0]) {
        const { rows } = await this.pg.query<{ id: string }>(
          `UPDATE agents
              SET hostname   = $2,
                  os         = $3,
                  arch       = $4,
                  version    = $5,
                  token_hash = $6,
                  updated_at = now()
            WHERE id = $1
          RETURNING id`,
          [
            existing.rows[0].id,
            input.hostname,
            input.os,
            input.arch,
            input.version,
            tokenHash,
          ],
        );
        agentId = rows[0].id;
        this.logger.log(`Re-enrolled agent ${agentId} (deviceId=${input.deviceId}).`);
      } else {
        const { rows } = await this.pg.query<{ id: string }>(
          `INSERT INTO agents (device_id, hostname, os, arch, version, token_hash, created_at, updated_at)
           VALUES ($1, $2, $3, $4, $5, $6, now(), now())
           RETURNING id`,
          [
            input.deviceId,
            input.hostname,
            input.os,
            input.arch,
            input.version,
            tokenHash,
          ],
        );
        agentId = rows[0].id;
        this.logger.log(`Enrolled new agent ${agentId} (deviceId=${input.deviceId}).`);
      }

      return { agentId, agentToken: token };
    } catch (e: any) {
      const msg = e?.message ?? String(e);
      this.logger.error(`Enroll failed: ${msg}`, e?.stack ?? undefined);
      const dev = (process.env.NODE_ENV || "").toLowerCase() === "development";
      throw new InternalServerErrorException(dev ? `Enroll failed: ${msg}` : "Enroll failed");
    }
  }

  /**
   * Validate an agent’s bearer token (opaque string).
   * Returns the agentId on success, or null on failure.
   */
  async validateAgentToken(rawToken: string): Promise<string | null> {
    const tokenHash = hashToken(rawToken);
    const { rows } = await this.pg.query<{ id: string }>(
      `SELECT id FROM agents WHERE token_hash = $1 LIMIT 1`,
      [tokenHash],
    );
    return rows[0]?.id ?? null;
  }
}



----------------------------------------------------------------------------------------



========================================================================================
[7] FILE
Path       : src/auth/auth.controller.ts
Size       : 5,198 bytes
Last Write : 2025-10-22 20:15:52
SHA256     : BBB2B1B76AC099AD57898F0078E0427FD03313E1B0001D4FCDC1AE39EAFEEFC9
========================================================================================

//remoteiq-minimal-e2e\backend\src\auth\auth.controller.ts

import { Body, Controller, Get, Post, Req, Res, BadRequestException } from "@nestjs/common";
import { ApiOkResponse, ApiTags } from "@nestjs/swagger";
import type { Request, Response } from "express";
import { LoginDto } from "./dto/login.dto";
import { Verify2FADto } from "./dto/verify-2fa.dto";
import { UserAuthService } from "./user-auth.service";

@ApiTags("auth")
@Controller("api/auth")
export class AuthController {
    constructor(private readonly users: UserAuthService) { }

    @Post("login")
    @ApiOkResponse({ description: "Sets auth cookie on success or returns 2FA challenge when required" })
    async login(
        @Body() dto: LoginDto & { deviceFingerprint?: string },
        @Req() req: Request,
        @Res({ passthrough: true }) res: Response,
    ) {
        // 1) Validate user
        const user = await this.users.validateUser(dto.email, dto.password);

        // 2) 2FA gate
        const is2FAEnabled = await this.users.isTwoFactorEnabled(user.id);
        const deviceTrusted = await this.users.isDeviceTrusted(user.id, dto.deviceFingerprint ?? null);
        if (is2FAEnabled && !deviceTrusted) {
            const { token: challengeToken, jti } = await this.users.createChallengeToken(user.id);
            return { status: "2fa_required" as const, challengeToken, jti };
        }

        // 3) Issue JWT with JTI
        const { token, jti } = await this.users.signWithJti(user);

        // 4) Record session
        const ua = req.headers["user-agent"] || "";
        const ip =
            (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
            (req.socket as any)?.remoteAddress ||
            "";
        await this.users.recordSessionOnLogin(user.id, jti, String(ua), String(ip));

        // 5) Set cookie
        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        const maxAgeMs = Number(process.env.AUTH_COOKIE_MAX_AGE_MS || 7 * 24 * 60 * 60 * 1000); // 7d
        res.cookie(cookieName, token, {
            httpOnly: true,
            sameSite: "lax",
            secure: process.env.NODE_ENV === "production",
            path: "/",
            maxAge: maxAgeMs,
        });

        return { user };
    }

    @Post("2fa/verify")
    @ApiOkResponse({ description: "Verifies TOTP or recovery code and sets auth cookie" })
    async verify2FA(@Body() dto: Verify2FADto, @Req() req: Request, @Res({ passthrough: true }) res: Response) {
        // Normalize incoming values
        if (dto.code) dto.code = dto.code.trim();
        if (dto.recoveryCode) dto.recoveryCode = dto.recoveryCode.trim();

        if (!dto.code && !dto.recoveryCode) {
            throw new BadRequestException("Provide either 'code' or 'recoveryCode'.");
        }

        // 1) Validate challenge and extract userId + jti
        const { userId, jti } = await this.users.verifyChallengeToken(dto.challengeToken);

        // 2) Verify TOTP or recovery
        let ok = false;
        if (dto.code) ok = await this.users.verifyTOTP(userId, dto.code);
        else if (dto.recoveryCode) ok = await this.users.consumeRecoveryCode(userId, dto.recoveryCode);

        if (!ok) throw new BadRequestException("Invalid code");

        // 3) Sign normal auth token with JTI and set cookie
        const user = await this.users.findUserById(userId);
        const { token, jti: newJti } = await this.users.signWithJti(user);

        const ua = req.headers["user-agent"] || "";
        const ip =
            (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
            (req.socket as any)?.remoteAddress ||
            "";
        await this.users.recordSessionOnLogin(userId, newJti, String(ua), String(ip));

        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        const maxAgeMs = Number(process.env.AUTH_COOKIE_MAX_AGE_MS || 7 * 24 * 60 * 60 * 1000);
        res.cookie(cookieName, token, {
            httpOnly: true,
            sameSite: "lax",
            secure: process.env.NODE_ENV === "production",
            path: "/",
            maxAge: maxAgeMs,
        });

        // 4) Trust device if requested
        if (dto.rememberDevice) {
            const fp = dto.deviceFingerprint ?? jti;
            await this.users.trustCurrentDevice(userId, fp);
        }

        return { ok: true };
    }

    @Post("logout")
    @ApiOkResponse({ description: "Clears auth cookie" })
    async logout(@Res({ passthrough: true }) res: Response) {
        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        res.clearCookie(cookieName, { path: "/" });
        return { ok: true };
    }

    @Get("me")
    @ApiOkResponse({ description: "Current user (if authenticated)" })
    async me(@Req() req: Request) {
        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        const token = (req as any).cookies?.[cookieName];
        if (!token) return { user: null };
        const user = await this.users.verify(token);
        return { user };
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[8] FILE
Path       : src/auth/user-auth.service.ts
Size       : 11,986 bytes
Last Write : 2025-10-22 20:17:47
SHA256     : 9F5DEEF2AB8C0D08E376C946E7DA2D793EDFB77E5EEF4689D639A7E6775DA520
========================================================================================

//remoteiq-minimal-e2e\backend\src\auth\user-auth.service.ts

import { Injectable, UnauthorizedException } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";
import * as bcrypt from "bcryptjs";
import { PgPoolService } from "../storage/pg-pool.service";
import { randomUUID, createHash, createHmac } from "crypto";

type WebUser = { id: string; email: string; name: string; role: "admin" | "user" | string };

// DB user type that includes 2FA fields when needed
type DbUser = {
    id: string;
    email: string;
    name: string | null;
    role: string | null;
    status?: string;
    suspended?: boolean | null;
    password_hash?: string | null;
    two_factor_enabled?: boolean | null;
    two_factor_secret?: string | null;            // base32 or otpauth URI
    two_factor_recovery_codes?: string[] | null;  // stored as hashes
};

@Injectable()
export class UserAuthService {
    constructor(
        private readonly jwt: JwtService,
        private readonly pg: PgPoolService,
    ) { }

    /** Validate against Postgres users table */
    async validateUser(email: string, password: string): Promise<WebUser> {
        const { rows } = await this.pg.query(
            `
      SELECT id, name, email, role, status, suspended, password_hash
      FROM users
      WHERE LOWER(email) = LOWER($1)
      LIMIT 1
      `,
            [email],
        );

        const u = rows[0];
        if (!u) throw new UnauthorizedException("Invalid email or password");
        if (u.status !== "active" || u.suspended === true) {
            throw new UnauthorizedException("Invalid email or password");
        }
        if (!u.password_hash || typeof u.password_hash !== "string") {
            throw new UnauthorizedException("Invalid email or password");
        }

        const ok = await bcrypt.compare(password, u.password_hash);
        if (!ok) throw new UnauthorizedException("Invalid email or password");

        const role: string = u.role || "User";
        return { id: u.id, email: u.email, name: u.name, role };
    }

    /** Issue a JWT **with JTI** (uses JwtModule config). */
    async signWithJti(user: WebUser): Promise<{ token: string; jti: string }> {
        const jti = randomUUID();
        const token = await this.jwt.signAsync({
            sub: user.id,
            email: user.email,
            name: user.name,
            role: user.role,
            jti,
        });
        return { token, jti };
    }

    /** Back-compat signer without JTI (not used by login anymore) */
    async sign(user: WebUser): Promise<string> {
        return this.jwt.signAsync({
            sub: user.id,
            email: user.email,
            name: user.name,
            role: user.role,
        });
    }

    /** Verify cookie token and re-hydrate a minimal user */
    async verify(token: string): Promise<WebUser | null> {
        try {
            const payload = await this.jwt.verifyAsync<{ sub: string; email: string; name?: string; role: string }>(token);
            const { rows } = await this.pg.query(
                `SELECT id, name, email, role, status, suspended FROM users WHERE id = $1 LIMIT 1`,
                [payload.sub],
            );
            const u = rows[0];
            if (!u || u.status !== "active" || u.suspended === true) return null;
            return { id: u.id, email: u.email, name: u.name, role: u.role || "User" };
        } catch {
            return null;
        }
    }

    /** Record a session row keyed by JTI (upsert on jti). */
    async recordSessionOnLogin(userId: string, jti: string, ua?: string, ip?: string) {
        await this.pg.query(
            `
      INSERT INTO sessions (user_id, jti, user_agent, ip)
      VALUES ($1, $2, $3, $4)
      ON CONFLICT (jti) DO UPDATE
         SET last_seen_at = now(),
             user_agent   = COALESCE(EXCLUDED.user_agent, sessions.user_agent),
             ip           = COALESCE(EXCLUDED.ip, sessions.ip)
      `,
            [userId, jti, ua || null, ip || null],
        );
    }

    // =============== 2FA: feature toggles & device trust =================

    async isTwoFactorEnabled(userId: string): Promise<boolean> {
        try {
            const { rows } = await this.pg.query<{ enabled: boolean }>(
                `
      select
        (coalesce(two_factor_enabled,false) = true)
        and (two_factor_secret is not null and length(trim(two_factor_secret)) > 0)
        as enabled
      from users
      where id = $1
      limit 1
      `,
                [userId],
            );
            return !!rows[0]?.enabled;
        } catch (e: any) {
            if (e?.code === "42703") return false; // columns not migrated yet
            throw e;
        }
    }


    async isDeviceTrusted(userId: string, deviceFingerprint: string | null): Promise<boolean> {
        if (!deviceFingerprint) return false;
        try {
            const { rows } = await this.pg.query(
                `SELECT 1
           FROM trusted_devices
          WHERE user_id = $1
            AND device_fingerprint = $2
            AND now() < expires_at
          LIMIT 1`,
                [userId, deviceFingerprint],
            );
            return !!rows[0];
        } catch {
            // table may not exist yet
            return false;
        }
    }

    async trustCurrentDevice(userId: string, deviceFingerprint: string) {
        try {
            await this.pg.query(
                `INSERT INTO trusted_devices (user_id, device_fingerprint, created_at, expires_at)
         VALUES ($1, $2, now(), now() + interval '90 days')
         ON CONFLICT (user_id, device_fingerprint)
         DO UPDATE SET expires_at = EXCLUDED.expires_at`,
                [userId, deviceFingerprint],
            );
        } catch {
            // ignore if table not present
        }
    }

    // =============== 2FA: challenge token (short-lived) ==================

    async createChallengeToken(userId: string): Promise<{ token: string; jti: string }> {
        const jti = randomUUID();
        const token = await this.jwt.signAsync(
            { sub: userId, typ: "2fa_challenge", jti },
            { expiresIn: "10m" },
        );
        try {
            await this.pg.query(
                `INSERT INTO login_challenges (id, user_id, created_at)
         VALUES ($1, $2, now())
         ON CONFLICT DO NOTHING`,
                [jti, userId],
            );
        } catch {
            // ignore if table not present
        }
        return { token, jti };
    }

    async verifyChallengeToken(challengeToken: string): Promise<{ userId: string; jti: string }> {
        let decoded: any;
        try {
            decoded = await this.jwt.verifyAsync(challengeToken);
        } catch {
            throw new UnauthorizedException("Invalid or expired challenge");
        }
        if (!decoded?.sub || decoded?.typ !== "2fa_challenge" || !decoded?.jti) {
            throw new UnauthorizedException("Invalid challenge");
        }
        return { userId: decoded.sub as string, jti: decoded.jti as string };
    }

    // =============== 2FA: verification (TOTP or recovery) =================

    async verifyTOTP(userId: string, code: string): Promise<boolean> {
        const u = await this.findUserTwoFactor(userId);
        if (!u?.two_factor_enabled || !u.two_factor_secret) return false;

        // Accept otpauth:// URIs & normalize base32 secret
        const normalized = this.normalizeTotpSecret(u.two_factor_secret);
        return this.verifyTotpBasic(normalized, code.trim());
    }

    async consumeRecoveryCode(userId: string, recoveryCode: string): Promise<boolean> {
        const u = await this.findUserTwoFactor(userId);
        if (!u) return false;
        const codes = u.two_factor_recovery_codes || [];
        if (codes.length === 0) return false;

        const candidateHash = this.sha256Hex(recoveryCode.trim().toLowerCase());
        const idx = codes.findIndex((h) => h === candidateHash);
        if (idx === -1) return false;

        const next = [...codes.slice(0, idx), ...codes.slice(idx + 1)];
        await this.pg.query(
            `UPDATE users SET two_factor_recovery_codes = $1 WHERE id = $2`,
            [next, userId],
        );
        return true;
    }

    // =============== Lookups =================

    async findUserById(userId: string): Promise<WebUser> {
        const { rows } = await this.pg.query<DbUser>(
            `SELECT id, name, email, role FROM users WHERE id = $1 LIMIT 1`,
            [userId],
        );
        const u = rows[0];
        if (!u) throw new UnauthorizedException("User not found");
        return { id: u.id, email: String(u.email), name: String(u.name), role: u.role || "User" };
    }

    async findUserTwoFactor(userId: string): Promise<DbUser | null> {
        try {
            const { rows } = await this.pg.query<DbUser>(
                `SELECT id, two_factor_enabled, two_factor_secret, two_factor_recovery_codes
           FROM users WHERE id = $1 LIMIT 1`,
                [userId],
            );
            return rows[0] ?? null;
        } catch (e: any) {
            // 42703 = undefined_column -> 2FA columns not migrated yet
            if (e?.code === "42703") return null;
            throw e;
        }
    }

    // =============== Minimal TOTP (robust parsing) =================

    /** Accepts raw base32 or full otpauth:// URI; strips spaces and uppercases */
    private normalizeTotpSecret(input: string): string {
        try {
            if (input.toLowerCase().startsWith("otpauth://")) {
                const u = new URL(input);
                const secret = u.searchParams.get("secret") || "";
                return secret.replace(/\s+/g, "").toUpperCase();
            }
        } catch {
            // not a valid URL; fall through
        }
        return input.replace(/\s+/g, "").toUpperCase();
    }

    private sha256Hex(s: string) {
        return createHash("sha256").update(s).digest("hex");
    }

    private verifyTotpBasic(base32Secret: string, code: string): boolean {
        try {
            const secret = this.base32Decode(base32Secret);
            const step = 30;
            const t = Math.floor(Date.now() / 1000 / step);

            // Allow a bit more skew: [-2, -1, 0, +1, +2]
            for (const off of [-2, -1, 0, 1, 2]) {
                const counter = Buffer.alloc(8);
                counter.writeBigUInt64BE(BigInt(t + off));
                const hmac = createHmac("sha1", secret).update(counter).digest();
                const offset = hmac[hmac.length - 1] & 0xf;
                const bin =
                    ((hmac[offset] & 0x7f) << 24) |
                    ((hmac[offset + 1] & 0xff) << 16) |
                    ((hmac[offset + 2] & 0xff) << 8) |
                    (hmac[offset + 3] & 0xff);
                const otp = (bin % 1_000_000).toString().padStart(6, "0");
                if (otp === code) return true;
            }
            return false;
        } catch {
            return false;
        }
    }

    private base32Decode(b32: string): Buffer {
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
        const clean = b32.replace(/=+$/, "").toUpperCase().replace(/[^A-Z2-7]/g, "");
        let bits = "";
        for (const c of clean) {
            const v = alphabet.indexOf(c);
            if (v < 0) continue;
            bits += v.toString(2).padStart(5, "0");
        }
        const bytes: number[] = [];
        for (let i = 0; i + 8 <= bits.length; i += 8) {
            bytes.push(parseInt(bits.substring(i, i + 8), 2));
        }
        return Buffer.from(bytes);
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[9] FILE
Path       : src/auth/user-auth.controller.ts
Size       : 5,136 bytes
Last Write : 2025-10-21 15:15:45
SHA256     : 84ED10881FD02FACB2CF20BDBACB7757F6378445BEF06B37ECF3970DF44FE723
========================================================================================

import { Body, Controller, Get, Post, Req, Res, BadRequestException } from "@nestjs/common";
import { ApiOkResponse, ApiTags } from "@nestjs/swagger";
import type { Request, Response } from "express";
import { LoginDto } from "./dto/login.dto";
import { Verify2FADto } from "./dto/verify-2fa.dto";
import { UserAuthService } from "./user-auth.service";

@ApiTags("auth")
@Controller("api/auth")
export class AuthController {
    constructor(private readonly users: UserAuthService) { }

    @Post("login")
    @ApiOkResponse({ description: "Sets auth cookie on success or returns 2FA challenge when required" })
    async login(
        @Body() dto: LoginDto & { deviceFingerprint?: string },
        @Req() req: Request,
        @Res({ passthrough: true }) res: Response,
    ) {
        // 1) Validate user
        const user = await this.users.validateUser(dto.email, dto.password);

        // 2) 2FA gate
        const is2FAEnabled = await this.users.isTwoFactorEnabled(user.id);
        const deviceTrusted = await this.users.isDeviceTrusted(user.id, dto.deviceFingerprint ?? null);
        if (is2FAEnabled && !deviceTrusted) {
            const { token: challengeToken, jti } = await this.users.createChallengeToken(user.id);
            return { status: "2fa_required" as const, challengeToken, jti };
        }

        // 3) Issue JWT with JTI
        const { token, jti } = await this.users.signWithJti(user);

        // 4) Record session
        const ua = req.headers["user-agent"] || "";
        const ip =
            (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
            (req.socket as any)?.remoteAddress ||
            "";
        await this.users.recordSessionOnLogin(user.id, jti, String(ua), String(ip));

        // 5) Set cookie
        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        const maxAgeMs = Number(process.env.AUTH_COOKIE_MAX_AGE_MS || 7 * 24 * 60 * 60 * 1000); // 7d
        res.cookie(cookieName, token, {
            httpOnly: true,
            sameSite: "lax",
            secure: process.env.NODE_ENV === "production",
            path: "/",
            maxAge: maxAgeMs,
        });

        return { user };
    }

    @Post("2fa/verify")
    @ApiOkResponse({ description: "Verifies TOTP or recovery code and sets auth cookie" })
    async verify2FA(@Body() dto: Verify2FADto, @Req() req: Request, @Res({ passthrough: true }) res: Response) {
        // Normalize incoming values
        if (dto.code) dto.code = dto.code.trim();
        if (dto.recoveryCode) dto.recoveryCode = dto.recoveryCode.trim();

        if (!dto.code && !dto.recoveryCode) {
            throw new BadRequestException("Provide either 'code' or 'recoveryCode'.");
        }

        // 1) Validate challenge and extract userId + jti
        const { userId, jti } = await this.users.verifyChallengeToken(dto.challengeToken);

        // 2) Verify TOTP or recovery
        let ok = false;
        if (dto.code) ok = await this.users.verifyTOTP(userId, dto.code);
        else if (dto.recoveryCode) ok = await this.users.consumeRecoveryCode(userId, dto.recoveryCode);

        if (!ok) throw new BadRequestException("Invalid code");

        // 3) Sign normal auth token with JTI and set cookie
        const user = await this.users.findUserById(userId);
        const { token, jti: newJti } = await this.users.signWithJti(user);

        const ua = req.headers["user-agent"] || "";
        const ip =
            (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
            (req.socket as any)?.remoteAddress ||
            "";
        await this.users.recordSessionOnLogin(userId, newJti, String(ua), String(ip));

        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        const maxAgeMs = Number(process.env.AUTH_COOKIE_MAX_AGE_MS || 7 * 24 * 60 * 60 * 1000);
        res.cookie(cookieName, token, {
            httpOnly: true,
            sameSite: "lax",
            secure: process.env.NODE_ENV === "production",
            path: "/",
            maxAge: maxAgeMs,
        });

        // 4) Trust device if requested
        if (dto.rememberDevice) {
            const fp = dto.deviceFingerprint ?? jti;
            await this.users.trustCurrentDevice(userId, fp);
        }

        return { ok: true };
    }

    @Post("logout")
    @ApiOkResponse({ description: "Clears auth cookie" })
    async logout(@Res({ passthrough: true }) res: Response) {
        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        res.clearCookie(cookieName, { path: "/" });
        return { ok: true };
    }

    @Get("me")
    @ApiOkResponse({ description: "Current user (if authenticated)" })
    async me(@Req() req: Request) {
        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        const token = (req as any).cookies?.[cookieName];
        if (!token) return { user: null };
        const user = await this.users.verify(token);
        return { user };
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[10] FILE
Path       : src/auth/auth-cookie.guard.ts
Size       : 3,990 bytes
Last Write : 2025-10-21 12:57:07
SHA256     : 3017C21FB876F115485C276BBCF9FFB79608AFFCF884EB8BB8B80F44C88A795A
========================================================================================

// src/auth/auth-cookie.guard.ts
import {
    CanActivate,
    ExecutionContext,
    Injectable,
    UnauthorizedException,
} from "@nestjs/common";
import type { Request, Response } from "express";
import { JwtService } from "@nestjs/jwt";
import { PgPoolService } from "../storage/pg-pool.service";
import { randomUUID } from "crypto";

function parseCookieMaxAge(): number {
    const v = process.env.AUTH_COOKIE_MAX_AGE_MS;
    const n = Number(v);
    return Number.isFinite(n) && n > 0 ? n : 7 * 24 * 60 * 60 * 1000; // 7d
}

@Injectable()
export class AuthCookieGuard implements CanActivate {
    constructor(
        private readonly jwt: JwtService,
        private readonly pg: PgPoolService,
    ) { }

    async canActivate(context: ExecutionContext): Promise<boolean> {
        const req = context.switchToHttp().getRequest<Request>();
        const res = context.switchToHttp().getResponse<Response>();

        const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
        const tokenFromCookie =
            (req as any).cookies?.[cookieName] ||
            (req as any).cookies?.["auth_token"];
        const tokenFromHeader =
            req.headers.authorization?.replace(/^Bearer\s+/i, "") || null;

        const token = tokenFromCookie || tokenFromHeader;
        if (!token) throw new UnauthorizedException("No auth token provided");

        let payload: any;
        try {
            payload = await this.jwt.verifyAsync(token);
        } catch {
            throw new UnauthorizedException("Invalid token");
        }
        if (!payload?.sub) throw new UnauthorizedException("Invalid token payload");

        (req as any).user = {
            id: String(payload.sub),
            email: payload.email,
            name: payload.name,
            role: payload.role,
        };

        // Legacy token migration: mint a new token with jti and set cookie
        let jti: string | null = payload?.jti != null ? String(payload.jti) : null;
        if (!jti) {
            jti = randomUUID();
            const newToken = await this.jwt.signAsync({
                sub: payload.sub,
                email: payload.email,
                name: payload.name,
                role: payload.role,
                jti,
            });

            res.cookie(cookieName, newToken, {
                httpOnly: true,
                sameSite: "lax",
                secure: process.env.NODE_ENV === "production",
                path: "/",
                maxAge: parseCookieMaxAge(),
            });

            const ipHdr = (req.headers["x-forwarded-for"] as string) || "";
            const ip = (ipHdr.split(",")[0] || req.ip || "").trim() || null;
            const ua = req.get("user-agent") || null;

            await this.pg.query(
                `
        INSERT INTO sessions (user_id, jti, user_agent, ip)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (jti) DO UPDATE
           SET last_seen_at = now(),
               user_agent   = COALESCE(EXCLUDED.user_agent, sessions.user_agent),
               ip           = COALESCE(EXCLUDED.ip, sessions.ip)
        `,
                [String(payload.sub), jti, ua, ip],
            );
        }

        (req as any).jti = jti;

        // Best-effort "touch"
        if (jti) {
            const ipHdr = (req.headers["x-forwarded-for"] as string) || "";
            const ip = (ipHdr.split(",")[0] || req.ip || "").trim() || null;
            const ua = req.get("user-agent") || null;
            this.pg
                .query(
                    `UPDATE sessions
             SET last_seen_at = now(),
                 ip = COALESCE($2, ip),
                 user_agent = COALESCE($3, user_agent)
           WHERE jti = $1 AND revoked_at IS NULL`,
                    [jti, ip, ua],
                )
                .catch(() => { });
        }

        return true;
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[11] FILE
Path       : src/auth/auth-cookie.middleware.ts
Size       : 2,422 bytes
Last Write : 2025-10-21 12:11:59
SHA256     : F2B1FCBB59C80DC0BED91DB96F4F88CF39335B4A0D718621A5B8C98508D177E5
========================================================================================

import { Injectable, NestMiddleware } from "@nestjs/common";
import type { Request, Response, NextFunction } from "express";
import { JwtService } from "@nestjs/jwt";
import { PgPoolService } from "../storage/pg-pool.service";

const SESSION_IDLE_UPDATE_SECS =
    parseInt(process.env.SESSION_IDLE_UPDATE_SECS || "300", 10) || 300;

@Injectable()
export class AuthCookieMiddleware implements NestMiddleware {
    private readonly cookieName: string;

    constructor(
        private readonly jwt: JwtService,
        private readonly pg: PgPoolService,
    ) {
        this.cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
    }

    async use(req: Request & { user?: any; jti?: string }, res: Response, next: NextFunction) {
        try {
            const token = (req as any).cookies?.[this.cookieName];
            if (!token) return next();

            const payload = await this.jwt.verifyAsync<any>(token, {
                secret: process.env.JWT_SECRET ?? "dev-secret",
            });

            // Normalize to the fields your app expects AND capture JTI
            req.user = {
                id: payload.sub ?? payload.id,
                email: payload.email,
                name: payload.name,
                role: payload.role,
            };
            req.jti = payload.jti;

            // If we have a JTI, ensure it's not revoked and gently bump last_seen
            if (req.jti) {
                const { rows } = await this.pg.query<{ revoked_at: string | null; last_seen_at: string }>(
                    `SELECT revoked_at, last_seen_at FROM sessions WHERE jti = $1 LIMIT 1`,
                    [req.jti],
                );
                if (rows.length > 0) {
                    if (rows[0].revoked_at) {
                        return res.status(401).json({ message: "Session revoked." });
                    }
                    const lastSeen = new Date(rows[0].last_seen_at).getTime();
                    const now = Date.now();
                    if ((now - lastSeen) / 1000 > SESSION_IDLE_UPDATE_SECS) {
                        await this.pg.query(`UPDATE sessions SET last_seen_at = now() WHERE jti = $1`, [req.jti]);
                    }
                }
            }
        } catch {
            // ignore broken/expired token; route can still choose to 401
        }
        next();
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[12] FILE
Path       : src/auth/session-heartbeat.interceptor.ts
Size       : 3,023 bytes
Last Write : 2025-10-21 14:06:40
SHA256     : F8B5A78BEE74F56BD3EA811CCC063FD1F82F8F85D099E726B9D502751DAB6643
========================================================================================

// backend/src/auth/session-heartbeat.interceptor.ts
import {
    Injectable,
    NestInterceptor,
    ExecutionContext,
    CallHandler,
} from "@nestjs/common";
import type { Request } from "express";
import { Observable } from "rxjs";
import { finalize } from "rxjs/operators";
import { PgPoolService } from "../storage/pg-pool.service";

/**
 * Updates sessions.last_seen_at for authenticated web users.
 * - NO-OP when req.user or req.jti are missing
 * - NO-OP for non-API paths and obvious public routes
 * - Never throws; DB errors are swallowed
 */
@Injectable()
export class SessionHeartbeatInterceptor implements NestInterceptor {
    constructor(private readonly pg: PgPoolService) { }

    intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
        const http = context.switchToHttp();
        const req = http.getRequest<Request>();

        // Only touch HTTP requests
        if (!req || !req.url) return next.handle();

        const url = req.url;

        // Skip non-API requests and public/docs/static routes
        // (adjust if your app has different mounts)
        const skip =
            !url.startsWith("/api") ||
            url.startsWith("/docs") ||
            url.startsWith("/static") ||
            url === "/healthz";

        if (skip) return next.handle();

        const user: any = (req as any).user;
        const jti: any = (req as any).jti;

        // If not authenticated or no JTI, do nothing
        if (!user?.id || !jti) {
            return next.handle();
        }

        // Capture request metadata before the stream completes
        const userId = String(user.id);
        const jtiText = String(jti);
        const ua = String(req.headers["user-agent"] || "");
        const ip =
            (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
            (req.socket as any)?.remoteAddress ||
            null;

        return next.handle().pipe(
            finalize(() => {
                // Fire-and-forget: never block response, never throw
                this.pg
                    .query(
                        `
            UPDATE sessions
               SET last_seen_at = now(),
                   user_agent   = COALESCE($3, user_agent),
                   ip           = COALESCE($4, ip)
             WHERE user_id = $1
               AND revoked_at IS NULL
               AND (
                    jti::text = $2
                 OR id::text  = $2
               )
            `,
                        [userId, jtiText, ua || null, ip || null],
                    )
                    .catch(() => {
                        // swallow errors; optionally add dev-only log:
                        if (process.env.NODE_ENV !== "production") {
                            // console.debug("Session heartbeat failed:", err?.message);
                        }
                    });
            }),
        );
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[13] FILE
Path       : src/auth/session-heartbeat.middleware.ts
Size       : 2,143 bytes
Last Write : 2025-10-21 14:09:23
SHA256     : 38EB2D2C46F1ED510BCD4E72FABFF3198C0D3AE6E0DB191378CD90D5CE974D08
========================================================================================

// backend/src/auth/session-heartbeat.middleware.ts
import { Injectable, NestMiddleware } from "@nestjs/common";
import type { Request, Response, NextFunction } from "express";
import { PgPoolService } from "../storage/pg-pool.service";

/**
 * SessionHeartbeatMiddleware
 * - Runs only where you register it (we’ll scope it to /api/users/me/* in AppModule)
 * - Requires req.user.id and req.jti (populated by your AuthCookieMiddleware)
 * - Updates sessions.last_seen_at AFTER the response to avoid blocking requests
 * - Never throws; errors are swallowed (optional debug log in dev)
 */
@Injectable()
export class SessionHeartbeatMiddleware implements NestMiddleware {
    constructor(private readonly pg: PgPoolService) { }

    use(req: Request, res: Response, next: NextFunction) {
        const user: any = (req as any).user;
        const jti: any = (req as any).jti;

        if (!user?.id || !jti) {
            return next();
        }

        const userId = String(user.id);
        const jtiText = String(jti);
        const ua = String(req.headers["user-agent"] || "");
        const ip =
            (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
            (req.socket as any)?.remoteAddress ||
            null;

        // Fire-and-forget after response completes
        res.on("finish", () => {
            this.pg
                .query(
                    `
          UPDATE sessions
             SET last_seen_at = now(),
                 user_agent   = COALESCE($3, user_agent),
                 ip           = COALESCE($4, ip)
           WHERE user_id = $1
             AND revoked_at IS NULL
             AND (
                  jti::text = $2
               OR id::text  = $2
             )
          `,
                    [userId, jtiText, ua || null, ip || null],
                )
                .catch(() => {
                    // Optional dev log:
                    // if (process.env.NODE_ENV !== "production") console.debug("session heartbeat update failed");
                });
        });

        next();
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[14] FILE
Path       : src/common/agent-token.util.ts
Size       : 3,332 bytes
Last Write : 2025-10-29 13:12:12
SHA256     : A88D1C70BD0F6E702D647A180479BB19C761B8B77E5CC97C0389D6DE6EF10955
========================================================================================

// remoteiq-minimal-e2e/backend/src/common/agent-token.util.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import type { Request } from 'express';
import crypto from 'node:crypto';
import jwt from 'jsonwebtoken';
import { PgPoolService } from '../storage/pg-pool.service';

/** ───────────────────────────
 *  Crypto helpers
 *  ─────────────────────────── */
const algo = 'sha256';

export function hashToken(token: string): string {
  return crypto.createHash(algo).update(token, 'utf8').digest('hex');
}

export function newOpaqueToken(): string {
  return crypto.randomBytes(24).toString('base64url');
}

export function signAgentJwt(agentId: string): string {
  const secret = process.env.JWT_SECRET || 'dev';
  return jwt.sign({ sub: agentId, typ: 'agent' }, secret, { algorithm: 'HS256' });
}

export function verifyAgentJwt(token: string): string | null {
  try {
    const secret = process.env.JWT_SECRET || 'dev';
    const payload = jwt.verify(token, secret) as any;
    return payload?.sub as string;
  } catch {
    return null;
  }
}

/** ───────────────────────────
 *  Request augmentation helper
 *  ─────────────────────────── */
export type AgentAuthContext = {
  id: number;
  token?: string;
};

export function getAgentFromRequest(req: any): AgentAuthContext {
  return (req as any).agent as AgentAuthContext;
}

/** ───────────────────────────
 *  DB row shape(s)
 *  ─────────────────────────── */
type AgentRow = {
  id: number;
  token_hash: string | null;
};

/** ───────────────────────────
 *  Bearer token guard for agents
 *  ─────────────────────────── */
@Injectable()
export class AgentTokenGuard implements CanActivate {
  constructor(private readonly db: PgPoolService) { }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const req = context.switchToHttp().getRequest<Request>();

    const authHeader = req.headers['authorization'];
    if (!authHeader || Array.isArray(authHeader)) {
      throw new UnauthorizedException('Missing Authorization header');
    }

    const match = /^Bearer\s+(.+)$/.exec(authHeader);
    if (!match) {
      throw new UnauthorizedException('Invalid Authorization header format');
    }

    const token = match[1];
    const tokenHash = hashToken(token);

    // Use the typed query helper (no private pool access)
    const { rows } = await this.db.query<AgentRow>(
      `SELECT id, token_hash
         FROM public.agents
        WHERE token_hash = $1
        LIMIT 1`,
      [tokenHash],
    );

    if (rows.length === 0) {
      throw new UnauthorizedException('Invalid or unknown agent token');
    }

    // Stash minimal agent context on the request
    (req as any).agent = { id: rows[0].id, token } as AgentAuthContext;

    return true;
  }
}



----------------------------------------------------------------------------------------



========================================================================================
[15] FILE
Path       : src/common/pagination.ts
Size       : 455 bytes
Last Write : 2025-10-18 15:26:48
SHA256     : 1D1DA623213E12D2CBC3DD19A5A6EB958EB3000E71405A9E5C25626BD1669AA7
========================================================================================

// src/common/pagination.ts
export function encodeCursor(val: string | number | Date): string {
  const s = typeof val === "string" ? val : (val instanceof Date ? val.toISOString() : String(val));
  return Buffer.from(s, "utf8").toString("base64url");
}
export function decodeCursor(cursor?: string): string | undefined {
  if (!cursor) return undefined;
  try { return Buffer.from(cursor, "base64url").toString("utf8"); }
  catch { return undefined; }
}



----------------------------------------------------------------------------------------



========================================================================================
[16] FILE
Path       : src/common/online.util.ts
Size       : 245 bytes
Last Write : 2025-10-15 23:04:35
SHA256     : 181EB31B886B6C91770461EF4D355D66854CB1CCCBB66E4040A63D6911BF8B52
========================================================================================

// src/common/online.util.ts
export function isAgentOnline(lastHeartbeatAt?: Date | null, thresholdMs = 30_000): boolean {
    if (!lastHeartbeatAt) return false;
    return Date.now() - new Date(lastHeartbeatAt).getTime() < thresholdMs;
}



----------------------------------------------------------------------------------------



========================================================================================
[17] FILE
Path       : src/common/socket-registry.service.ts
Size       : 2,046 bytes
Last Write : 2025-10-29 21:54:55
SHA256     : 81535AEA63E27380F7D75175CFA18CE2065BCA5B12F90BC435B01B74B5439E6C
========================================================================================

//remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts

import { Injectable } from "@nestjs/common";
import type { WebSocket } from "ws";

export type AgentSocket = WebSocket & {
    agentId?: string;
    deviceId?: string;
};

@Injectable()
export class SocketRegistry {
    private socketsByAgent = new Map<string, AgentSocket>();
    private socketsByDevice = new Map<string, AgentSocket>();

    // --- Primary API ---
    getByAgent(agentId: string): AgentSocket | undefined {
        return this.socketsByAgent.get(agentId);
    }

    getByDevice(deviceId: string): AgentSocket | undefined {
        return this.socketsByDevice.get(deviceId);
    }

    set(agentId: string | undefined, deviceId: string | undefined, socket: AgentSocket) {
        if (agentId) {
            this.socketsByAgent.set(agentId, socket);
            socket.agentId = agentId;
        }
        if (deviceId) {
            this.socketsByDevice.set(deviceId, socket);
            socket.deviceId = deviceId;
        }
    }

    deleteByAgent(agentId: string) {
        const sock = this.socketsByAgent.get(agentId);
        if (sock?.deviceId) this.socketsByDevice.delete(sock.deviceId);
        this.socketsByAgent.delete(agentId);
    }

    deleteByDevice(deviceId: string) {
        const sock = this.socketsByDevice.get(deviceId);
        if (sock?.agentId) this.socketsByAgent.delete(sock.agentId);
        this.socketsByDevice.delete(deviceId);
    }

    // --- Back-compat aliases (so older callers like dispatcher.service can keep using .get) ---
    /** Alias for getByAgent */
    get(agentId: string): AgentSocket | undefined {
        return this.getByAgent(agentId);
    }
    /** Aliases in case other code uses these names */
    setByAgent(agentId: string, socket: AgentSocket) {
        this.set(agentId, /*deviceId*/ undefined, socket);
    }
    setByDevice(deviceId: string, socket: AgentSocket) {
        this.set(/*agentId*/ undefined, deviceId, socket);
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[18] FILE
Path       : src/common/ui-socket-registry.service.ts
Size       : 7,003 bytes
Last Write : 2025-10-30 21:23:24
SHA256     : DE78FAA32439E6B6E692F3DABC18FE711BCFD111B43D0322529B43100DE5F85D
========================================================================================

// backend/src/common/ui-socket-registry.service.ts
import { Injectable, Logger } from "@nestjs/common";
import type { WebSocket } from "ws";

/**
 * UI (dashboard) socket with metadata.
 * - userId: authenticated user identifier (string)
 * - subscriptions: deviceIds this socket has subscribed to
 */
export type UiSocket = WebSocket & {
    userId?: string;
    subscriptions?: Set<string>;
};

function isOpen(ws: WebSocket): boolean {
    // 'OPEN' is a numeric const on ws WebSocket instances
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (ws as any).readyState === (ws as any).OPEN;
}

/**
 * Registry for **dashboard/user** WebSocket connections and their subscriptions.
 * Isolation from the Agent socket registry keeps privileges and broadcasting clean.
 *
 * Notes:
 * - In-memory only (per-process). For multi-node deployments, back this with Redis or a message bus.
 * - Broadcast methods return the number of sockets that were attempted (best-effort).
 */
@Injectable()
export class UiSocketRegistry {
    private readonly log = new Logger("UiSocketRegistry");

    /** All sockets for a given user */
    private socketsByUser = new Map<string, Set<UiSocket>>();

    /** Subscribers for a given deviceId */
    private socketsByDevice = new Map<string, Set<UiSocket>>();

    /** Track every active socket for cleanup/metrics */
    private allSockets = new Set<UiSocket>();

    /* ---------------------------- Socket lifecycle ---------------------------- */

    /** Register a new UI socket for a specific user (auth already verified). */
    add(userId: string, socket: UiSocket): void {
        socket.userId = String(userId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();

        // Per-user index
        if (!this.socketsByUser.has(userId)) this.socketsByUser.set(userId, new Set());
        this.socketsByUser.get(userId)!.add(socket);

        // Global index
        this.allSockets.add(socket);
    }

    /** Remove a UI socket from all indexes (called on close/error). */
    remove(socket: UiSocket): void {
        // Unsubscribe from all device topics first
        if (socket.subscriptions && socket.subscriptions.size) {
            for (const deviceId of socket.subscriptions) {
                this.unsubscribe(socket, deviceId);
            }
            socket.subscriptions.clear();
        }

        // Detach from per-user map
        const uid = socket.userId;
        if (uid && this.socketsByUser.has(uid)) {
            const set = this.socketsByUser.get(uid)!;
            set.delete(socket);
            if (set.size === 0) this.socketsByUser.delete(uid);
        }

        // Global index
        this.allSockets.delete(socket);
    }

    /** Remove all sockets for a given user (e.g., on logout/revoke). */
    removeAllForUser(userId: string): number {
        const set = this.socketsByUser.get(userId);
        if (!set || !set.size) return 0;
        let n = 0;
        for (const s of Array.from(set)) {
            try {
                // Close with policy code; UI can auto-reconnect if appropriate
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (s as any).close?.(4401, "User sessions revoked");
            } catch {
                /* ignore */
            }
            this.remove(s);
            n++;
        }
        return n;
    }

    /* ----------------------------- Subscriptions ------------------------------ */

    /** Subscribe a socket to a device topic (idempotent). */
    subscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();
        if (socket.subscriptions.has(id)) return;

        socket.subscriptions.add(id);

        if (!this.socketsByDevice.has(id)) this.socketsByDevice.set(id, new Set());
        this.socketsByDevice.get(id)!.add(socket);
    }

    /** Unsubscribe a socket from a device topic (no-op if not subscribed). */
    unsubscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        if (socket.subscriptions && socket.subscriptions.has(id)) {
            socket.subscriptions.delete(id);
        }
        const set = this.socketsByDevice.get(id);
        if (set) {
            set.delete(socket);
            if (set.size === 0) this.socketsByDevice.delete(id);
        }
    }

    /** Unsubscribe a socket from all topics. */
    unsubscribeAll(socket: UiSocket): void {
        if (!socket.subscriptions) return;
        for (const id of Array.from(socket.subscriptions)) {
            this.unsubscribe(socket, id);
        }
    }

    /* -------------------------------- Broadcasts ------------------------------ */

    /** Broadcast to all UI sockets (rare; prefer topic broadcasts). */
    broadcastAll(payload: unknown): number {
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of this.allSockets) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets subscribed to a specific deviceId. */
    broadcastToDevice(deviceId: string, payload: unknown): number {
        const set = this.socketsByDevice.get(String(deviceId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets for a given userId (e.g., personal notices). */
    broadcastToUser(userId: string, payload: unknown): number {
        const set = this.socketsByUser.get(String(userId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /* --------------------------------- Metrics -------------------------------- */

    countAll(): number {
        return this.allSockets.size;
    }
    countUsers(): number {
        return this.socketsByUser.size;
    }
    countDeviceSubscribers(deviceId: string): number {
        const set = this.socketsByDevice.get(String(deviceId));
        return set ? set.size : 0;
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[19] FILE
Path       : src/common/admin-api.guard.ts
Size       : 510 bytes
Last Write : 2025-10-15 15:36:43
SHA256     : 7924FAE514CEB95BC9A139278D12EEEDA4C90CEC8714434D0750A1FA0DDEB960
========================================================================================

import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from "@nestjs/common";

@Injectable()
export class AdminApiGuard implements CanActivate {
  canActivate(ctx: ExecutionContext): boolean {
    const req = ctx.switchToHttp().getRequest();
    const key = req.header("x-admin-api-key");
    const expected = process.env.ADMIN_API_KEY || "";
    if (!expected || key !== expected) {
      throw new UnauthorizedException("Invalid or missing x-admin-api-key");
    }
    return true;
  }
}


----------------------------------------------------------------------------------------



========================================================================================
[20] FILE
Path       : src/common/guards/admin-api.guard.ts
Size       : 823 bytes
Last Write : 2025-10-20 16:58:06
SHA256     : F1EAE70363807A07B32274066E1B19D7C852AE54FEF9F128E073102CD9E8F637
========================================================================================

import {
    CanActivate,
    ExecutionContext,
    Injectable,
    UnauthorizedException,
} from "@nestjs/common";

/**
 * Simple header-based guard:
 * - If ADMIN_API_KEY is not set, allow (dev-friendly)
 * - If set, require header: x-admin-api-key: <ADMIN_API_KEY>
 */
@Injectable()
export class AdminApiGuard implements CanActivate {
    canActivate(ctx: ExecutionContext): boolean {
        const req = ctx.switchToHttp().getRequest();
        const provided = req.headers["x-admin-api-key"] as string | undefined;

        // Dev fallback: no key set => allow
        const expected = process.env.ADMIN_API_KEY?.trim();
        if (!expected) return true;

        if (provided && provided === expected) return true;
        throw new UnauthorizedException("Invalid admin API key");
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[21] FILE
Path       : src/company/company.module.ts
Size       : 467 bytes
Last Write : 2025-10-19 00:39:18
SHA256     : DA4669542E3AF23B4AE58283A2C50427F76F066C56BD557C23802B004241CCE7
========================================================================================

// backend/src/company/company.module.ts
import { Module } from "@nestjs/common";
import { CompanyController } from "./company.controller";
import { CompanyService } from "./company.service";
import { StorageModule } from "../storage/storage.module"; // PgPoolService provider

@Module({
    imports: [StorageModule],
    controllers: [CompanyController],
    providers: [CompanyService],
    exports: [CompanyService],
})
export class CompanyModule { }



----------------------------------------------------------------------------------------



========================================================================================
[22] FILE
Path       : src/company/company.controller.ts
Size       : 903 bytes
Last Write : 2025-10-19 00:39:08
SHA256     : F4A3432B0EED99915EAAC9E4788F756747B3ADCBDF02BDC9FD8438676BAF66BB
========================================================================================

// backend/src/company/company.controller.ts
import { Body, Controller, Get, HttpCode, Post, UsePipes, ValidationPipe } from "@nestjs/common";
import { CompanyService } from "./company.service";
import { CompanyProfile, CompanyProfileDto } from "./company.dto";

@UsePipes(new ValidationPipe({ whitelist: true, transform: true }))
@Controller("/api/admin/company") // keep paths used by the frontend
export class CompanyController {
    constructor(private readonly svc: CompanyService) { }

    @Get()
    async get(): Promise<CompanyProfile | { exists: false }> {
        const row = await this.svc.get();
        return row ?? { exists: false };
    }

    @Post("save")
    @HttpCode(204)
    async save(@Body() body: CompanyProfileDto): Promise<void> {
        // ValidationPipe(whitelist:true) will drop unknown props (e.g., id)
        await this.svc.upsert(body);
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[23] FILE
Path       : src/company/company.service.ts
Size       : 2,340 bytes
Last Write : 2025-10-19 00:39:00
SHA256     : CFBC3756E3CEEABF80EEE86B006F97E8ED5997F7C1194D301AD101779CBB2BC7
========================================================================================

// backend/src/company/company.service.ts
import { Injectable } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";
import { CompanyProfile, CompanyProfileDto } from "./company.dto";

@Injectable()
export class CompanyService {
    private readonly rowId = 1;
    constructor(private readonly pg: PgPoolService) { }

    async get(): Promise<CompanyProfile | null> {
        const { rows } = await this.pg.query(
            `SELECT id,
              name,
              legal_name AS "legalName",
              email, phone, fax, website,
              vat_tin   AS "vatTin",
              address1, address2, city, state, postal, country
         FROM company_profile
        WHERE id = $1
        LIMIT 1`,
            [this.rowId]
        );
        return (rows[0] as CompanyProfile) ?? null;
    }

    async upsert(input: CompanyProfileDto): Promise<void> {
        await this.pg.query(
            `INSERT INTO company_profile
         (id, name, legal_name, email, phone, fax, website, vat_tin,
          address1, address2, city, state, postal, country)
       VALUES
         ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14)
       ON CONFLICT (id) DO UPDATE SET
         name       = EXCLUDED.name,
         legal_name = EXCLUDED.legal_name,
         email      = EXCLUDED.email,
         phone      = EXCLUDED.phone,
         fax        = EXCLUDED.fax,
         website    = EXCLUDED.website,
         vat_tin    = EXCLUDED.vat_tin,
         address1   = EXCLUDED.address1,
         address2   = EXCLUDED.address2,
         city       = EXCLUDED.city,
         state      = EXCLUDED.state,
         postal     = EXCLUDED.postal,
         country    = EXCLUDED.country`,
            [
                this.rowId,
                input.name,
                input.legalName ?? null,
                input.email ?? null,
                input.phone ?? null,
                input.fax ?? null,
                input.website ?? null,
                input.vatTin ?? null,
                input.address1 ?? null,
                input.address2 ?? null,
                input.city ?? null,
                input.state ?? null,
                input.postal ?? null,
                input.country ?? null,
            ]
        );
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[24] FILE
Path       : src/company/company.dto.ts
Size       : 877 bytes
Last Write : 2025-10-19 00:37:10
SHA256     : 85FE3454D1180EB963D2406A447945DB64CADFF0F1ADE4F677EA054A47FC11CB
========================================================================================

// backend/src/company/company.dto.ts
import { IsEmail, IsOptional, IsString } from "class-validator";

export class CompanyProfileDto {
    @IsString() name!: string;
    @IsOptional() @IsString() legalName?: string;
    @IsOptional() @IsEmail() email?: string;
    @IsOptional() @IsString() phone?: string;
    @IsOptional() @IsString() fax?: string;
    @IsOptional() @IsString() website?: string;
    @IsOptional() @IsString() vatTin?: string;
    @IsOptional() @IsString() address1?: string;
    @IsOptional() @IsString() address2?: string;
    @IsOptional() @IsString() city?: string;
    @IsOptional() @IsString() state?: string;
    @IsOptional() @IsString() postal?: string;
    @IsOptional() @IsString() country?: string;
}

// Returned to the client (single-row model with fixed id=1)
export type CompanyProfile = CompanyProfileDto & { id: 1 };



----------------------------------------------------------------------------------------



========================================================================================
[25] FILE
Path       : src/devices/devices.module.ts
Size       : 715 bytes
Last Write : 2025-10-29 13:12:12
SHA256     : 6F7EB0A26E5314D95EFE941ED5EA706232666852DD65E7C4350BBFBA57D0E228
========================================================================================

//remoteiq-minimal-e2e\backend\src\devices\devices.module.ts

import { Module, forwardRef } from "@nestjs/common";
import { DevicesController } from "./devices.controller";
import { DeviceActionsController } from "./device-actions.controller";
import { DeviceInsightsController } from "./device-insights.controller";
import { JobsModule } from "../jobs/jobs.module";
import { StorageModule } from "../storage/storage.module";
import { DevicesService } from "./devices.service";

@Module({
  imports: [StorageModule, forwardRef(() => JobsModule)],
  controllers: [DevicesController, DeviceActionsController, DeviceInsightsController],
  providers: [DevicesService],
})
export class DevicesModule { }



----------------------------------------------------------------------------------------



========================================================================================
[26] FILE
Path       : src/devices/devices.service.ts
Size       : 9,251 bytes
Last Write : 2025-10-30 11:23:10
SHA256     : A35AA1A8936108D84755C47088ABCE3E13CBA9F89A9D5F57C7732580A4DCE469
========================================================================================

// backend/src/devices/devices.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | null;
  version?: string | null;
  primaryIp?: string | null;
  agentUuid?: string | null; // <-- NEW
};

function decodeCursor(cur?: string | null) {
  if (!cur) return 0;
  try {
    const n = parseInt(Buffer.from(cur, "base64url").toString("utf8"), 10);
    return Number.isFinite(n) && n >= 0 ? n : 0;
  } catch {
    return 0;
  }
}
function encodeCursor(n: number) {
  return Buffer.from(String(n), "utf8").toString("base64url");
}

@Injectable()
export class DevicesService {
  constructor(private readonly pg: PgPoolService) { }

  async list(opts: {
    pageSize: number;
    cursor?: string | null;
    q?: string;
    status?: "online" | "offline";
    os?: string[];
  }): Promise<{ items: Device[]; nextCursor: string | null }> {
    const { pageSize, cursor, q, status, os } = opts;
    const offset = decodeCursor(cursor);

    const where: string[] = [];
    const params: any[] = [];
    let p = 1;

    if (q && q.trim()) {
      where.push(`hostname ILIKE $${p++}`);
      params.push(`%${q.trim()}%`);
    }
    if (status) {
      where.push(`status = $${p++}`);
      params.push(status);
    }
    if (os && os.length) {
      where.push(`lower(os) = ANY($${p++})`);
      params.push(os.map((o) => String(o).toLowerCase()));
    }

    const limit = pageSize + 1;
    const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";

    const sql = `
      WITH agent_rows AS (
        SELECT
          a.id::text                                   AS id,
          COALESCE(a.hostname, a.device_id, 'unknown') AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')        AS os,
          a.arch                                       AS arch,
          a.last_seen_at                               AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                          AS status,
          a.client                                     AS client,
          a.site                                       AS site,
          NULLIF(a.logged_in_user, '')                 AS "user",
          NULLIF(a.version, '')                        AS version,
          NULLIF(a.primary_ip, '')                     AS primary_ip,
          a.agent_uuid::text                           AS agent_uuid   -- <-- NEW
        FROM public.agents a
      ),
      device_rows AS (
        SELECT
          d.id::text            AS id,
          d.hostname            AS hostname,
          d.os                  AS os,
          d.arch                AS arch,
          d.last_seen           AS last_seen,
          d.status              AS status,
          d.client              AS client,
          d.site                AS site,
          NULLIF(d."user", '')  AS "user",
          NULL::text            AS version,
          NULL::text            AS primary_ip,
          NULL::text            AS agent_uuid                          -- <-- NEW
        FROM devices d
        WHERE NOT EXISTS (
          SELECT 1 FROM public.agents a
          WHERE COALESCE(a.hostname, a.device_id, 'unknown') = d.hostname
        )
      ),
      all_devs AS (
        SELECT * FROM agent_rows
        UNION ALL
        SELECT * FROM device_rows
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM all_devs
      ${whereSql}
      ORDER BY hostname ASC
      LIMIT ${limit} OFFSET ${offset};
    `;

    const { rows } = await this.pg.query(sql, params);
    const hasNext = rows.length > pageSize;

    const items = rows.slice(0, pageSize).map((r: any) => ({
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    })) as Device[];

    return { items, nextCursor: hasNext ? encodeCursor(offset + pageSize) : null };
  }

  async getOne(id: string): Promise<Device | null> {
    const sql = `
      WITH rows AS (
        SELECT
          0                                                AS pref,
          a.id::text                                      AS id,
          COALESCE(a.hostname, a.device_id, 'unknown')    AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')           AS os,
          a.arch                                          AS arch,
          a.last_seen_at                                  AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                             AS status,
          a.client                                        AS client,
          a.site                                          AS site,
          NULLIF(a.logged_in_user, '')                    AS "user",
          NULLIF(a.version, '')                           AS version,
          NULLIF(a.primary_ip, '')                        AS primary_ip,
          a.agent_uuid::text                              AS agent_uuid  -- <-- NEW
        FROM public.agents a
        WHERE a.id::text = $1

        UNION ALL

        SELECT
          1                        AS pref,
          d.id::text               AS id,
          d.hostname               AS hostname,
          d.os                     AS os,
          d.arch                   AS arch,
          d.last_seen              AS last_seen,
          d.status                 AS status,
          d.client                 AS client,
          d.site                   AS site,
          NULLIF(d."user", '')     AS "user",
          NULL::text               AS version,
          NULL::text               AS primary_ip,
          NULL::text               AS agent_uuid                         -- <-- NEW
        FROM devices d
        WHERE d.id::text = $1
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM rows
      ORDER BY pref ASC
      LIMIT 1;
    `;
    const { rows } = await this.pg.query(sql, [id]);
    const r = rows[0];
    if (!r) return null;

    return {
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    };
  }

  async listSoftware(
    id: string
  ): Promise<
    Array<{
      id: string;
      name: string;
      version: string;
      publisher?: string | null;
      installDate?: string | null;
    }>
  > {
    const { rows } = await this.pg.query(
      `
      SELECT
        s.id::text            AS id,
        s.name,
        s.version,
        s.publisher,
        s.install_date        AS install_date
      FROM public.agent_software s
      JOIN public.agents a ON a.id = s.agent_id
      WHERE a.id::text = $1
      ORDER BY lower(s.name) ASC, COALESCE(s.version,'') ASC
      `,
      [id]
    );

    return rows.map((r: any) => ({
      id: r.id,
      name: r.name,
      version: r.version ?? "",
      publisher: r.publisher ?? null,
      installDate: r.install_date ?? null,
    }));
  }

  // NEW: create uninstall job in a simple job queue
  async requestUninstall(
    id: string,
    body: { name: string; version?: string | null }
  ): Promise<string> {
    // ensure agent exists
    const { rows: arows } = await this.pg.query(
      `SELECT id FROM public.agents WHERE id::text = $1`,
      [id]
    );
    const agentId: number | undefined = arows[0]?.id;
    if (!agentId) throw new NotFoundException("Agent not found");

    const payload = {
      action: "uninstall_software",
      name: body.name,
      version: body.version ?? null,
    };

    const { rows } = await this.pg.query(
      `
      INSERT INTO public.agent_jobs (agent_id, kind, payload)
      VALUES ($1, $2, $3::jsonb)
      RETURNING id::text AS id
      `,
      [agentId, "uninstall_software", JSON.stringify(payload)]
    );

    return rows[0].id as string;
  }
}



----------------------------------------------------------------------------------------



========================================================================================
[27] FILE
Path       : src/devices/devices.controller.ts
Size       : 8,396 bytes
Last Write : 2025-10-29 13:12:12
SHA256     : B1C6952110BB0616D0CAED4353011A08EC31AA38FF27BAE1DFF226077AB273A2
========================================================================================

// backend/src/devices/devices.controller.ts
import {
  BadRequestException,
  Body,
  Controller,
  Get,
  HttpCode,
  NotFoundException,
  Param,
  Post,
  Query,
  UsePipes,
  ValidationPipe,
} from "@nestjs/common";
import { ListDevicesQuery } from "./dto";
import { DevicesService, type Device } from "./devices.service";
import { UninstallSoftwareDto } from "./dto/uninstall-software.dto";
import { JobsService } from "../jobs/jobs.service";
import { PgPoolService } from "../storage/pg-pool.service";

@Controller("/api/devices")
@UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
export class DevicesController {
  constructor(
    private readonly devices: DevicesService,
    private readonly jobs: JobsService,
    private readonly pg: PgPoolService,
  ) { }

  @Get()
  async list(
    @Query() query: ListDevicesQuery
  ): Promise<{ items: Device[]; nextCursor: string | null }> {
    const { pageSize, cursor, q, status, os } = query;
    return this.devices.list({ pageSize, cursor, q, status, os });
  }

  @Get(":id")
  async getOne(@Param("id") id: string): Promise<Device> {
    const dev = await this.devices.getOne(id);
    if (!dev) throw new NotFoundException("Device not found");
    return dev;
  }

  @Get(":id/software")
  async software(
    @Param("id") id: string
  ): Promise<{
    items: Array<{
      id: string;
      name: string;
      version: string;
      publisher?: string | null;
      installDate?: string | null;
    }>;
  }> {
    const items = await this.devices.listSoftware(id);
    return { items };
  }

  /**
   * Queue an uninstall job for the device’s agent.
   * Returns 202 + { jobId } so the UI can poll/subscribe for status.
   */
  @Post(":id/actions/uninstall")
  @HttpCode(202)
  async uninstall(
    @Param("id") id: string,
    @Body() body: UninstallSoftwareDto
  ): Promise<{ accepted: true; jobId: string }> {
    // Validate device exists (and grab some identifying fields)
    const device = await this.devices.getOne(id);
    if (!device) throw new NotFoundException("Device not found");

    const name = body?.name?.trim();
    const version = body?.version?.trim();
    if (!name) throw new BadRequestException("name is required");

    // -------------------------------
    // Find agent even if agents.device_id is a string/hostname
    // Strategies (in order):
    //   1) a.device_id equals the numeric path param (as text)
    //   2) a.device_id equals device.external id/hostname (if present)
    //   3) a.hostname equals device hostname (if present)
    // -------------------------------
    const numericIdText = String(id);

    const deviceExternalId =
      (device as any).device_id ||
      (device as any).externalId ||
      (device as any).external_id ||
      (device as any).hostname ||
      null;

    const deviceHostname =
      (device as any).hostname ||
      (device as any).host ||
      (device as any).name ||
      null;

    const { rows } = await this.pg.query<{ id: string }>(
      `
      SELECT a.id
        FROM agents a
       WHERE a.device_id = $1
          OR ($2::text IS NOT NULL AND a.device_id = $2::text)
          OR ($3::text IS NOT NULL AND a.hostname  = $3::text)
       LIMIT 1
      `,
      [numericIdText, deviceExternalId ?? null, deviceHostname ?? null]
    );

    const agent = rows[0];
    if (!agent) {
      throw new NotFoundException("Agent not connected for this device");
    }

    // Pick script per OS (default to bash for non-Windows)
    const { shell, script } = buildUninstallScript((device as any).os, name, version);

    // Create a DB-backed job; dispatcher will push over WS to the agent when connected
    const job = await this.jobs.createRunScriptJob({
      agentId: agent.id,
      language: shell === "powershell" ? "powershell" : "bash",
      scriptText: script,
      timeoutSec: 900, // 15 minutes
    });

    return { accepted: true, jobId: job.id };
  }
}

/** Build a best-effort uninstall command per OS */
function buildUninstallScript(
  osRaw: string | undefined,
  name: string,
  version?: string
): { shell: "powershell" | "bash"; script: string } {
  const os = (osRaw || "").toLowerCase();

  // -------------------------- Windows (PowerShell) --------------------------
  if (os.includes("win")) {
    // NOTE: No stray PowerShell backticks. Use proper quoting for -like and -match.
    const ps = `
$ErrorActionPreference = "Stop"

function Try-Winget {
  param([string]$Pkg, [string]$Ver)
  try {
    if ($Ver) {
      winget.exe uninstall --silent --exact --accept-source-agreements --accept-package-agreements --id "$Pkg" --version "$Ver" 2>$null
      if ($LASTEXITCODE -eq 0) { return $true }
      winget.exe uninstall --silent --accept-source-agreements --accept-package-agreements --name "$Pkg" --version "$Ver" 2>$null
      if ($LASTEXITCODE -eq 0) { return $true }
    } else {
      winget.exe uninstall --silent --exact --accept-source-agreements --accept-package-agreements --id "$Pkg" 2>$null
      if ($LASTEXITCODE -eq 0) { return $true }
      winget.exe uninstall --silent --accept-source-agreements --accept-package-agreements --name "$Pkg" 2>$null
      if ($LASTEXITCODE -eq 0) { return $true }
    }
  } catch {}
  return $false
}

function Try-MSI {
  param([string]$DisplayName)
  $roots = @(
    'HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',
    'HKLM:\\Software\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',
    'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*'
  )
  $apps = Get-ItemProperty $roots | Where-Object { $_.DisplayName -and $_.DisplayName -like "*$DisplayName*" }
  foreach ($a in $apps) {
    if ($a.UninstallString) {
      $cmd = $a.UninstallString
      if ($cmd -match "msiexec\\.exe" -or $cmd -match "MsiExec\\.exe") {
        # Normalize to silent MSI removal using ProductCode (PSChildName)
        $cmd = "msiexec.exe /x " + ($a.PSChildName) + " /qn /norestart"
      }
      Start-Process -FilePath "cmd.exe" -ArgumentList "/c", $cmd -Wait
      if ($LASTEXITCODE -eq 0) { return $true }
    }
  }
  return $false
}

$target = "${name.replace(/"/g, '""')}"
$wantedVersion = "${(version ?? "").replace(/"/g, '""')}"

Write-Output "Uninstalling '$target' (wanted version '$wantedVersion')"

if (Try-Winget $target $wantedVersion) { exit 0 }
if (Try-MSI $target) { exit 0 }

Write-Error "Failed to uninstall ${name}"
exit 1
`.trim();
    return { shell: "powershell", script: ps };
  }

  // ------------------------------ macOS (bash) ------------------------------
  if (os.includes("mac") || os.includes("darwin")) {
    const bash = `
set -euo pipefail
NAME="${escapeBash(name)}"
VER="${escapeBash(version || "")}"

if command -v brew >/dev/null 2>&1; then
  if brew list --formula | grep -i -F "$NAME" >/dev/null 2>&1; then
    brew uninstall --force "$NAME" || true
  fi
  if brew list --cask | grep -i -F "$NAME" >/dev/null 2>&1; then
    brew uninstall --cask --force "$NAME" || true
  fi
fi

PKGID=$(pkgutil --pkgs | grep -i -F "$NAME" || true)
if [ -n "$PKGID" ]; then
  sudo pkgutil --forget "$PKGID" || true
fi

APP="/Applications/${escapeBash(name)}.app"
if [ -d "$APP" ]; then
  rm -rf "$APP" || true
fi

exit 0
`.trim();
    return { shell: "bash", script: bash };
  }

  // ------------------------------ Linux (bash) ------------------------------
  const bash = `
set -euo pipefail
NAME="${escapeBash(name)}"

if command -v apt-get >/dev/null 2>&1; then
  sudo apt-get update -y || true
  sudo apt-get remove -y "$NAME" || sudo apt-get purge -y "$NAME" || true
  exit 0
fi

if command -v dnf >/dev/null 2>&1; then
  sudo dnf remove -y "$NAME" || true
  exit 0
fi

if command -v yum >/dev/null 2>&1; then
  sudo yum remove -y "$NAME" || true
  exit 0
fi

if command -v pacman >/dev/null 2>&1; then
  sudo pacman -R --noconfirm "$NAME" || true
  exit 0
fi

echo "No supported package manager found or uninstall failed for ${escapeBash(name)}" 1>&2
exit 1
`.trim();

  return { shell: "bash", script: bash };
}

/** tiny helpers */
function escapeBash(s: string) {
  return s.replace(/(["`$\\])/g, "\\$1");
}



----------------------------------------------------------------------------------------



========================================================================================
[28] FILE
Path       : src/types/externals.d.ts
Size       : 232 bytes
Last Write : 2025-10-18 13:42:11
SHA256     : 5A03BBE9CCB717FD35CC15B4071CB6ABD8DDB7DBEB6E4412701D11C5DBA2FDF6
========================================================================================

// backend/src/types/externals.d.ts
declare module "pg";
declare module "mysql2/promise";
declare module "mssql";
declare module "better-sqlite3";
declare module "sqlite3";
declare module "sqlite";
declare module "mongodb";



----------------------------------------------------------------------------------------



========================================================================================
[29] FILE
Path       : src/types/express.d.ts
Size       : 191 bytes
Last Write : 2025-10-21 12:18:07
SHA256     : 178D6A482E71E3B0940A805C46C23FE6DFB7EFB2FA6326B35885D4AE3076183C
========================================================================================

// src/types/express.d.ts
import 'express';

declare module 'express-serve-static-core' {
    interface Request {
        user?: { id: string };
        jti?: string | null;
    }
}



----------------------------------------------------------------------------------------



========================================================================================
[30] FILE
Path       : src/main.ts
Size       : 4,563 bytes
Last Write : 2025-10-21 16:21:12
SHA256     : 88956246DDAFF85405E1A4EB494BFC12463602BD8A34141C9E3EA059C825FF66
========================================================================================

// backend/src/main.ts
import "reflect-metadata";
import "dotenv/config";
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import cookieParser from "cookie-parser";
import { WsAdapter } from "@nestjs/platform-ws";
import { ValidationPipe, INestApplication } from "@nestjs/common";
import * as fs from "fs";
import * as path from "path";

// 👇 add this import to serve static files
import { NestExpressApplication } from "@nestjs/platform-express";

// Pg + interceptor
import { PgPoolService } from "./storage/pg-pool.service";
import { SessionHeartbeatInterceptor } from "./auth/session-heartbeat.interceptor";

/** Mount /docs only when allowed (and if @nestjs/swagger is present). */
async function maybeSetupSwagger(app: INestApplication) {
  const enableSwagger =
    (process.env.SWAGGER ?? "").toLowerCase() === "true" ||
    process.env.NODE_ENV !== "production";

  if (!enableSwagger) {
    console.log("Swagger disabled (set SWAGGER=true to enable).");
    return;
  }
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { SwaggerModule, DocumentBuilder } = require("@nestjs/swagger");
    const config = new DocumentBuilder()
      .setTitle("RemoteIQ API")
      .setDescription("OpenAPI for RemoteIQ RMM")
      .setVersion("v1")
      .addBearerAuth({ type: "http", scheme: "bearer", bearerFormat: "JWT" }, "bearer")
      .build();
    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup("/docs", app, document);
    console.log("Swagger docs mounted at /docs");
  } catch {
    console.log("Swagger not installed. Skip docs (pnpm add -D @nestjs/swagger swagger-ui-express)");
  }
}

function configureCors(app: INestApplication) {
  const isProd = process.env.NODE_ENV === "production";

  const listFromFrontends =
    (process.env.FRONTEND_ORIGINS || "")
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);

  const listFromAllowed = (process.env.ALLOWED_ORIGIN || "")
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);

  const origins = listFromFrontends.length ? listFromFrontends : listFromAllowed;

  if (isProd && origins.length > 0) {
    app.enableCors({
      origin: origins,
      credentials: true,
      methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "x-admin-api-key"],
      exposedHeaders: ["Content-Length"],
    });
    console.log("CORS restricted to:", origins);
  } else {
    app.enableCors({
      origin: (_origin, cb) => cb(null, true),
      credentials: true,
      methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "x-admin-api-key"],
      exposedHeaders: ["Content-Length"],
    });
    console.log("CORS open (dev). Set FRONTEND_ORIGINS or ALLOWED_ORIGIN for prod.");
  }
}

async function bootstrap() {
  // Ensure uploads directory exists (multer doesn't create it)
  const uploadsDir = path.join(process.cwd(), "public", "uploads");
  if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });

  // 👇 tell Nest this is an Express app so we can useStaticAssets
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  // 👇 serve /static/* from ./public/*
  app.useStaticAssets(path.join(process.cwd(), "public"), {
    prefix: "/static/",
  });

  app.use(cookieParser());
  configureCors(app);

  app.useWebSocketAdapter(new WsAdapter(app));

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    })
  );

  app.enableShutdownHooks();

  app.getHttpAdapter().getInstance().get("/healthz", (_req: any, res: any) => res.send("OK"));

  await maybeSetupSwagger(app);

  // ✅ Register SessionHeartbeatInterceptor only if PgPoolService is resolvable
  try {
    const pg = app.get(PgPoolService, { strict: false });
    if (pg) {
      app.useGlobalInterceptors(new SessionHeartbeatInterceptor(pg));
      console.log("SessionHeartbeatInterceptor enabled.");
    } else {
      console.warn(
        "PgPoolService not found in AppModule context; SessionHeartbeatInterceptor NOT enabled."
      );
    }
  } catch (err) {
    console.warn(
      "Could not enable SessionHeartbeatInterceptor (continuing without it):",
      (err as Error)?.message || err
    );
  }

  const port = Number(process.env.PORT || 3001);
  await app.listen(port);
  console.log(`API up on http://localhost:${port}`);
}
bootstrap();



----------------------------------------------------------------------------------------



========================================================================================
[31] FILE
Path       : src/main.swagger.example.ts
Size       : 2,117 bytes
Last Write : 2025-10-18 13:08:42
SHA256     : 6B74D10AD5E3177DEE92796EC76E09EA3CBFF8A52F82ADAABFC2F8D9151C3DE1
========================================================================================

// backend/src/main.ts
import "reflect-metadata"; // must be first
import "dotenv/config";
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import cookieParser from "cookie-parser";
import { WsAdapter } from "@nestjs/platform-ws";
import { ValidationPipe, INestApplication } from "@nestjs/common";

/**
 * Conditional Swagger setup:
 * - If @nestjs/swagger (+ swagger-ui-express) are installed, mounts docs at /docs
 * - If not installed, quietly no-ops (no TS errors, no runtime crash)
 */
async function maybeSetupSwagger(app: INestApplication) {
  try {
    // Runtime import so TypeScript doesn't need the types installed
    const { SwaggerModule, DocumentBuilder } = require("@nestjs/swagger");

    const config = new DocumentBuilder()
      .setTitle("RemoteIQ API")
      .setDescription("OpenAPI for RemoteIQ RMM")
      .setVersion("v1")
      .addBearerAuth(
        { type: "http", scheme: "bearer", bearerFormat: "JWT" },
        "bearer"
      )
      .build();

    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup("/docs", app, document);
    // eslint-disable-next-line no-console
    console.log("Swagger docs mounted at /docs");
  } catch {
    // eslint-disable-next-line no-console
    console.log("Swagger not installed. Skipping docs (pnpm add -D @nestjs/swagger swagger-ui-express)");
  }
}

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.use(cookieParser());
  app.enableCors();
  app.useWebSocketAdapter(new WsAdapter(app));
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    })
  );
  app.enableShutdownHooks();

  // simple health check
  app.getHttpAdapter().getInstance().get("/healthz", (_req: any, res: any) => res.send("OK"));

  // Swagger (safe no-op if deps are missing)
  await maybeSetupSwagger(app);

  const port = Number(process.env.PORT || 3001);
  await app.listen(port);
  // eslint-disable-next-line no-console
  console.log(`API up on http://localhost:${port}`);
}
bootstrap();



----------------------------------------------------------------------------------------



========================================================================================
[32] FILE
Path       : config/database.json
Size       : 502 bytes
Last Write : 2025-10-20 20:49:22
SHA256     : C404D9F0FEBE11D833F580DD03DF6ED96A624AA26DF14ED574BB6B9FB21942F2
========================================================================================

{
  "enabled": true,
  "engine": "postgresql",
  "authMode": "url",
  "url": "postgres://remoteiq:remoteiqpass@localhost:5432/remoteiq",
  "host": "",
  "port": 5432,
  "dbName": "",
  "username": "",
  "password": "",
  "ssl": false,
  "poolMin": 0,
  "poolMax": 10,
  "readReplicas": "",
  "mappings": {
    "users": "users",
    "roles": "roles",
    "sessions": "sessions",
    "audit_logs": "audit_logs",
    "devices": "devices",
    "policies": "policies",
    "email_queue": "email_queue"
  }
}


----------------------------------------------------------------------------------------



========================================================================================
SUMMARY
========================================================================================
Exported files : 32
Missing files  : 0
========================================================================================
