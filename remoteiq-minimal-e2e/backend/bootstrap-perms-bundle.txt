RemoteIQ Bootstrap & Permissions Wiring Bundle
============================================================
Generated: 2025-11-06 21:36:23 -05:00
Root: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend

# FILES INCLUDED
# --------------

# Must-see (bootstrap & wiring)
## FILE: src/main.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\main.ts
Size: 4563 bytes
SHA256: 88956246DDAFF85405E1A4EB494BFC12463602BD8A34141C9E3EA059C825FF66
----- BEGIN CONTENT -----
     1: // backend/src/main.ts
     2: import "reflect-metadata";
     3: import "dotenv/config";
     4: import { NestFactory } from "@nestjs/core";
     5: import { AppModule } from "./app.module";
     6: import cookieParser from "cookie-parser";
     7: import { WsAdapter } from "@nestjs/platform-ws";
     8: import { ValidationPipe, INestApplication } from "@nestjs/common";
     9: import * as fs from "fs";
    10: import * as path from "path";
    11: 
    12: // 👇 add this import to serve static files
    13: import { NestExpressApplication } from "@nestjs/platform-express";
    14: 
    15: // Pg + interceptor
    16: import { PgPoolService } from "./storage/pg-pool.service";
    17: import { SessionHeartbeatInterceptor } from "./auth/session-heartbeat.interceptor";
    18: 
    19: /** Mount /docs only when allowed (and if @nestjs/swagger is present). */
    20: async function maybeSetupSwagger(app: INestApplication) {
    21:   const enableSwagger =
    22:     (process.env.SWAGGER ?? "").toLowerCase() === "true" ||
    23:     process.env.NODE_ENV !== "production";
    24: 
    25:   if (!enableSwagger) {
    26:     console.log("Swagger disabled (set SWAGGER=true to enable).");
    27:     return;
    28:   }
    29:   try {
    30:     // eslint-disable-next-line @typescript-eslint/no-var-requires
    31:     const { SwaggerModule, DocumentBuilder } = require("@nestjs/swagger");
    32:     const config = new DocumentBuilder()
    33:       .setTitle("RemoteIQ API")
    34:       .setDescription("OpenAPI for RemoteIQ RMM")
    35:       .setVersion("v1")
    36:       .addBearerAuth({ type: "http", scheme: "bearer", bearerFormat: "JWT" }, "bearer")
    37:       .build();
    38:     const document = SwaggerModule.createDocument(app, config);
    39:     SwaggerModule.setup("/docs", app, document);
    40:     console.log("Swagger docs mounted at /docs");
    41:   } catch {
    42:     console.log("Swagger not installed. Skip docs (pnpm add -D @nestjs/swagger swagger-ui-express)");
    43:   }
    44: }
    45: 
    46: function configureCors(app: INestApplication) {
    47:   const isProd = process.env.NODE_ENV === "production";
    48: 
    49:   const listFromFrontends =
    50:     (process.env.FRONTEND_ORIGINS || "")
    51:       .split(",")
    52:       .map((s) => s.trim())
    53:       .filter(Boolean);
    54: 
    55:   const listFromAllowed = (process.env.ALLOWED_ORIGIN || "")
    56:     .split(",")
    57:     .map((s) => s.trim())
    58:     .filter(Boolean);
    59: 
    60:   const origins = listFromFrontends.length ? listFromFrontends : listFromAllowed;
    61: 
    62:   if (isProd && origins.length > 0) {
    63:     app.enableCors({
    64:       origin: origins,
    65:       credentials: true,
    66:       methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    67:       allowedHeaders: ["Content-Type", "Authorization", "x-admin-api-key"],
    68:       exposedHeaders: ["Content-Length"],
    69:     });
    70:     console.log("CORS restricted to:", origins);
    71:   } else {
    72:     app.enableCors({
    73:       origin: (_origin, cb) => cb(null, true),
    74:       credentials: true,
    75:       methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    76:       allowedHeaders: ["Content-Type", "Authorization", "x-admin-api-key"],
    77:       exposedHeaders: ["Content-Length"],
    78:     });
    79:     console.log("CORS open (dev). Set FRONTEND_ORIGINS or ALLOWED_ORIGIN for prod.");
    80:   }
    81: }
    82: 
    83: async function bootstrap() {
    84:   // Ensure uploads directory exists (multer doesn't create it)
    85:   const uploadsDir = path.join(process.cwd(), "public", "uploads");
    86:   if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });
    87: 
    88:   // 👇 tell Nest this is an Express app so we can useStaticAssets
    89:   const app = await NestFactory.create<NestExpressApplication>(AppModule);
    90: 
    91:   // 👇 serve /static/* from ./public/*
    92:   app.useStaticAssets(path.join(process.cwd(), "public"), {
    93:     prefix: "/static/",
    94:   });
    95: 
    96:   app.use(cookieParser());
    97:   configureCors(app);
    98: 
    99:   app.useWebSocketAdapter(new WsAdapter(app));
   100: 
   101:   app.useGlobalPipes(
   102:     new ValidationPipe({
   103:       whitelist: true,
   104:       forbidNonWhitelisted: true,
   105:       transform: true,
   106:     })
   107:   );
   108: 
   109:   app.enableShutdownHooks();
   110: 
   111:   app.getHttpAdapter().getInstance().get("/healthz", (_req: any, res: any) => res.send("OK"));
   112: 
   113:   await maybeSetupSwagger(app);
   114: 
   115:   // ✅ Register SessionHeartbeatInterceptor only if PgPoolService is resolvable
   116:   try {
   117:     const pg = app.get(PgPoolService, { strict: false });
   118:     if (pg) {
   119:       app.useGlobalInterceptors(new SessionHeartbeatInterceptor(pg));
   120:       console.log("SessionHeartbeatInterceptor enabled.");
   121:     } else {
   122:       console.warn(
   123:         "PgPoolService not found in AppModule context; SessionHeartbeatInterceptor NOT enabled."
   124:       );
   125:     }
   126:   } catch (err) {
   127:     console.warn(
   128:       "Could not enable SessionHeartbeatInterceptor (continuing without it):",
   129:       (err as Error)?.message || err
   130:     );
   131:   }
   132: 
   133:   const port = Number(process.env.PORT || 3001);
   134:   await app.listen(port);
   135:   console.log(`API up on http://localhost:${port}`);
   136: }
   137: bootstrap();
-----  END  CONTENT -----

## FILE: src/app.module.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\app.module.ts
Size: 3581 bytes
SHA256: A457C37201698CE095CC01B3D1DB2D55876DF6C7F23ADC4CB77AFBED7E2C85AB
----- BEGIN CONTENT -----
     1: // remoteiq-minimal-e2e/backend/src/app.module.ts
     2: 
     3: import { Module, MiddlewareConsumer, NestModule } from "@nestjs/common";
     4: import { ServeStaticModule } from "@nestjs/serve-static";
     5: import { join } from "path";
     6: 
     7: import { CommonModule } from "./common/common.module";
     8: import { AuthModule } from "./auth/auth.module";
     9: import { WsModule } from "./ws/ws.module";
    10: import { AgentsModule } from "./agents/agents.module";
    11: import { JobsModule } from "./jobs/jobs.module";
    12: import { DevicesModule } from "./devices/devices.module";
    13: import { HealthModule } from "./health/health.module";
    14: import { AdminModule } from "./admin/admin.module";
    15: import { CompanyModule } from "./company/company.module";
    16: import { BrandingModule } from "./branding/branding.module";
    17: import { LocalizationModule } from "./localization/localization.module";
    18: import { SupportModule } from "./support/support.module";
    19: import { SupportLegalModule } from "./support-legal/support-legal.module";
    20: import { UsersModule } from "./users/users.module";
    21: import { RolesModule } from "./roles/roles.module";
    22: import { SmtpModule } from "./smtp/smtp.module";
    23: import { ScheduleModule } from "@nestjs/schedule";
    24: import { ImapModule } from "./imap/imap.module";
    25: import { SessionCleanerService } from "./maintenance/session-cleaner.service";
    26: import { CustomersModule } from "./customers/customers.module";
    27: import { BackupsModule } from "./backups/backups.module";
    28: 
    29: import { JwtModule } from "@nestjs/jwt";
    30: 
    31: // ✅ correct path: the middleware file is under /auth, not /common
    32: import { AuthCookieMiddleware } from "./auth/auth-cookie.middleware";
    33: 
    34: // ✅ bring PgPoolService into the AppModule DI context
    35: import { StorageModule } from "./storage/storage.module";
    36: 
    37: // ✅ NEW: Tickets
    38: import { TicketsModule } from "./tickets/tickets.module";
    39: 
    40: @Module({
    41:     imports: [
    42:         // Static files mounted at /static -> maps to /public
    43:         ServeStaticModule.forRoot({
    44:             rootPath: join(__dirname, "..", "public"),
    45:             serveRoot: "/static",
    46:         }),
    47: 
    48:         // JwtService for middleware
    49:         JwtModule.register({
    50:             secret: process.env.JWT_SECRET ?? "dev-secret",
    51:         }),
    52: 
    53:         // Base/shared
    54:         CommonModule,
    55: 
    56:         // ✅ Storage (PgPoolService) must be available for main.ts interceptor registration
    57:         StorageModule,
    58: 
    59:         // Feature modules
    60:         BrandingModule,
    61:         AuthModule,
    62:         WsModule,
    63:         AgentsModule,
    64:         JobsModule,
    65:         DevicesModule,
    66:         HealthModule,
    67:         AdminModule,
    68:         CompanyModule,
    69:         LocalizationModule,
    70:         SupportModule,
    71:         SupportLegalModule,
    72:         UsersModule,
    73:         RolesModule,
    74:         CustomersModule,
    75: 
    76:         // Backups Module
    77:         BackupsModule,
    78: 
    79:         // ✅ Tickets module
    80:         TicketsModule,
    81: 
    82:         // SMTP + IMAP
    83:         SmtpModule,
    84:         ScheduleModule.forRoot(),
    85:         ImapModule,
    86:     ],
    87:     providers: [
    88:         // Daily cleanup of revoked sessions
    89:         SessionCleanerService,
    90:     ],
    91: })
    92: export class AppModule implements NestModule {
    93:     configure(consumer: MiddlewareConsumer) {
    94:         // Apply cookie->req.user middleware to everything except obvious public/static routes
    95:         consumer
    96:             .apply(AuthCookieMiddleware)
    97:             .exclude(
    98:                 "healthz",
    99:                 "docs",
   100:                 "docs/(.*)",
   101:                 "static/(.*)",      // static files
   102:                 "api/auth/login",   // login doesn’t need req.user
   103:                 "api/auth/logout"   // logout doesn’t need req.user
   104:             )
   105:             .forRoutes("*");
   106:     }
   107: }
-----  END  CONTENT -----


##############################################################################

# Storage (PgPool/Org context)
## FILE: src/storage/storage.module.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\storage.module.ts
Size: 869 bytes
SHA256: B203F89362C87A96C5549196AC5D6BFB8FEDC6C79A345B34BFCD23EC2711C8BF
----- BEGIN CONTENT -----
     1: //backend\src\storage\storage.module.ts
     2: 
     3: import { Module } from "@nestjs/common";
     4: import { Reflector } from "@nestjs/core";
     5: import { PermissionsGuard } from "../auth/permissions.guard";
     6: import { PgBootstrap } from "./pg.bootstrap";
     7: import { OrganizationContextService } from "./organization-context.service";
     8: import { PgPoolService } from "./pg-pool.service";
     9: import { StorageConnectionsService } from "./storage-connections.service";
    10: import { StorageController } from "./storage.controller";
    11: 
    12: @Module({
    13:     controllers: [StorageController],
    14:     providers: [
    15:         PgPoolService,
    16:         PgBootstrap,
    17:         OrganizationContextService,
    18:         StorageConnectionsService,
    19:         PermissionsGuard,
    20:         Reflector,
    21:     ],
    22:     exports: [PgPoolService, OrganizationContextService, StorageConnectionsService],
    23: })
    24: export class StorageModule { }
-----  END  CONTENT -----

## FILE: src/storage/pg-pool.service.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\pg-pool.service.ts
Size: 3449 bytes
SHA256: 6900004F42029BB937D18B5D06F166C5185E8CE59175AEDAEBB946781FADD030
----- BEGIN CONTENT -----
     1: //backend\src\storage\pg-pool.service.ts
     2: 
     3: import { Injectable, OnModuleDestroy } from "@nestjs/common";
     4: 
     5: // We use require() + loose typing to avoid the “Cannot use namespace … as a type” errors
     6: // that can happen in some TS configs when importing from 'pg'.
     7: const { Pool } = require("pg") as { Pool: any };
     8: 
     9: export type PgRuntimeConfig = {
    10:     connectionString?: string;
    11:     ssl?: boolean | object;
    12:     max?: number;
    13:     min?: number;
    14: };
    15: 
    16: @Injectable()
    17: export class PgPoolService implements OnModuleDestroy {
    18:     private pool: any = null;
    19:     private lastKey: string | null = null;
    20: 
    21:     /** Build a default config from env (used on first access if not configured) */
    22:     private envConfig(): PgRuntimeConfig {
    23:         const url =
    24:             process.env.DATABASE_URL ||
    25:             process.env.PG_URL ||
    26:             "postgres://remoteiq:remoteiqpass@localhost:5432/remoteiq";
    27: 
    28:         const ssl =
    29:             (process.env.DATABASE_SSL ?? "").toLowerCase() === "true" ? true : false;
    30: 
    31:         const max = Number.isFinite(+process.env.DATABASE_POOL_MAX!)
    32:             ? Number(process.env.DATABASE_POOL_MAX)
    33:             : 10;
    34:         const min = Number.isFinite(+process.env.DATABASE_POOL_MIN!)
    35:             ? Number(process.env.DATABASE_POOL_MIN)
    36:             : 0;
    37: 
    38:         return { connectionString: url, ssl, max, min };
    39:     }
    40: 
    41:     /** Create a stable key for the current config so we can know when to recreate the pool */
    42:     private keyOf(cfg: PgRuntimeConfig): string {
    43:         return JSON.stringify({
    44:             cs: cfg.connectionString ?? "",
    45:             ssl: cfg.ssl ? "1" : "0",
    46:             max: cfg.max ?? 10,
    47:             min: cfg.min ?? 0,
    48:         });
    49:     }
    50: 
    51:     private makePool(cfg: PgRuntimeConfig): any {
    52:         const base: any = {
    53:             connectionString: cfg.connectionString,
    54:             max: cfg.max ?? 10,
    55:             min: cfg.min ?? 0,
    56:         };
    57:         if (cfg.ssl) {
    58:             base.ssl = cfg.ssl === true ? { rejectUnauthorized: false } : cfg.ssl;
    59:         }
    60:         return new Pool(base);
    61:     }
    62: 
    63:     /** Ensure pool exists; create from env if needed */
    64:     private ensurePool(): any {
    65:         if (!this.pool) {
    66:             const cfg = this.envConfig();
    67:             this.lastKey = this.keyOf(cfg);
    68:             this.pool = this.makePool(cfg);
    69:         }
    70:         return this.pool!;
    71:     }
    72: 
    73:     /**
    74:      * Called by admin bootstrap when the database config changes.
    75:      * Recreates the pool if the effective config differs.
    76:      */
    77:     configure(cfg: PgRuntimeConfig) {
    78:         const nextKey = this.keyOf(cfg);
    79:         if (this.pool && this.lastKey === nextKey) return; // no-op
    80: 
    81:         // tear down previous pool
    82:         if (this.pool) {
    83:             try {
    84:                 this.pool.end().catch(() => { });
    85:             } catch { }
    86:             this.pool = null;
    87:         }
    88: 
    89:         this.pool = this.makePool(cfg);
    90:         this.lastKey = nextKey;
    91:     }
    92: 
    93:     async query<T = any>(text: string, params?: any[]): Promise<{ rows: T[]; rowCount: number }> {
    94:         const res = await this.ensurePool().query(text, params);
    95:         return { rows: res.rows as T[], rowCount: typeof res.rowCount === "number" ? res.rowCount : 0 };
    96:     }
    97: 
    98:     async onModuleDestroy() {
    99:         if (this.pool) {
   100:             try {
   101:                 await this.pool.end();
   102:             } catch { }
   103:             this.pool = null;
   104:         }
   105:     }
   106: }
-----  END  CONTENT -----

## FILE: src/storage/organization-context.service.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\organization-context.service.ts
Size: 2032 bytes
SHA256: E364B8B41917A06E4BEAB460DD6ABEED6A1540680A88ABE6C3DC59763907A2B2
----- BEGIN CONTENT -----
     1: import { Injectable, Logger } from "@nestjs/common";
     2: import { PgPoolService } from "./pg-pool.service";
     3: 
     4: function slugify(input: string): string {
     5:     return input
     6:         .toLowerCase()
     7:         .replace(/[^a-z0-9]+/g, "-")
     8:         .replace(/^-+|-+$/g, "")
     9:         .replace(/--+/g, "-");
    10: }
    11: 
    12: @Injectable()
    13: export class OrganizationContextService {
    14:     private readonly logger = new Logger(OrganizationContextService.name);
    15:     private cachedOrgId: string | null = null;
    16: 
    17:     constructor(private readonly pg: PgPoolService) { }
    18: 
    19:     async getDefaultOrganizationId(): Promise<string> {
    20:         if (this.cachedOrgId) return this.cachedOrgId;
    21: 
    22:         const configuredSlug = process.env.DEFAULT_ORGANIZATION_SLUG || "default";
    23:         const slug = slugify(configuredSlug) || "default";
    24:         const name = process.env.DEFAULT_ORGANIZATION_NAME || "Default Organization";
    25: 
    26:         try {
    27:             const existing = await this.pg.query<{ id: string }>(
    28:                 `SELECT id FROM organizations WHERE slug = $1 LIMIT 1`,
    29:                 [slug],
    30:             );
    31:             if (existing.rows[0]?.id) {
    32:                 this.cachedOrgId = existing.rows[0].id;
    33:                 return this.cachedOrgId;
    34:             }
    35:         } catch (err) {
    36:             this.logger.warn(`organizations table unavailable: ${(err as Error)?.message ?? err}`);
    37:             throw err;
    38:         }
    39: 
    40:         const insert = await this.pg.query<{ id: string }>(
    41:             `INSERT INTO organizations (name, slug)
    42:              VALUES ($1, $2)
    43:              ON CONFLICT (slug) DO UPDATE
    44:                SET name = EXCLUDED.name
    45:              RETURNING id`,
    46:             [name, slug],
    47:         );
    48: 
    49:         const orgId = insert.rows[0].id;
    50:         this.cachedOrgId = orgId;
    51: 
    52:         await this.pg.query(
    53:             `INSERT INTO organization_settings (organization_id)
    54:              VALUES ($1)
    55:              ON CONFLICT (organization_id) DO NOTHING`,
    56:             [orgId],
    57:         );
    58: 
    59:         return orgId;
    60:     }
    61: }
-----  END  CONTENT -----


##############################################################################

# Auth, Guards, Session cookie/heartbeat
## FILE: src/auth/auth.module.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\auth.module.ts
Size: 1308 bytes
SHA256: FA79AA063B6A3CA3F688F44635D3812CDAC756F039BF1F1DEB6C7782AFF03935
----- BEGIN CONTENT -----
     1: // backend/src/auth/auth.module.ts
     2: import { Module } from "@nestjs/common";
     3: import { JwtModule } from "@nestjs/jwt";
     4: import { StorageModule } from "../storage/storage.module";
     5: import { AuthService } from "./auth.service";
     6: import { AuthController } from "./auth.controller";
     7: import { UserAuthService } from "./user-auth.service";
     8: 
     9: function parseExpiresToSeconds(input: string | undefined, fallbackSeconds: number): number {
    10:   if (!input) return fallbackSeconds;
    11:   if (/^\d+$/.test(input)) return Number(input);
    12:   const m = input.trim().match(/^(\d+)\s*([smhd])$/i);
    13:   if (!m) return fallbackSeconds;
    14:   const n = Number(m[1]);
    15:   const unit = m[2].toLowerCase();
    16:   const factor = unit === "s" ? 1 : unit === "m" ? 60 : unit === "h" ? 3600 : unit === "d" ? 86400 : 1;
    17:   return n * factor;
    18: }
    19: const EXPIRES_IN_SECONDS = parseExpiresToSeconds(process.env.JWT_EXPIRES, 60 * 60 * 24 * 7);
    20: 
    21: @Module({
    22:   imports: [
    23:     StorageModule, // ✅ PgPoolService lives here; no Prisma
    24:     JwtModule.register({
    25:       secret: process.env.JWT_SECRET ?? "dev-secret",
    26:       signOptions: { expiresIn: EXPIRES_IN_SECONDS },
    27:     }),
    28:   ],
    29:   controllers: [AuthController],
    30:   providers: [AuthService, UserAuthService],
    31:   exports: [AuthService, UserAuthService, JwtModule],
    32: })
    33: export class AuthModule { }
-----  END  CONTENT -----

## FILE: src/auth/auth.service.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\auth.service.ts
Size: 3971 bytes
SHA256: 40CBF01FEF9A260E7328A8F7ABCADB95F9EDF29203AD910C8EB20674BC8CDD82
----- BEGIN CONTENT -----
     1: // backend/src/auth/auth.service.ts
     2: import {
     3:   Injectable,
     4:   UnauthorizedException,
     5:   InternalServerErrorException,
     6:   Logger,
     7: } from "@nestjs/common";
     8: import { createHash, randomBytes } from "node:crypto";
     9: import { PgPoolService } from "../storage/pg-pool.service";
    10: 
    11: function newOpaqueToken(): string {
    12:   return randomBytes(18).toString("base64url");
    13: }
    14: function hashToken(token: string): string {
    15:   return createHash("sha256").update(token, "utf8").digest("hex");
    16: }
    17: 
    18: type EnrollInput = {
    19:   enrollmentSecret: string;
    20:   deviceId: string;
    21:   hostname: string;
    22:   os: string;
    23:   arch: string;
    24:   version: string;
    25: };
    26: 
    27: @Injectable()
    28: export class AuthService {
    29:   private readonly logger = new Logger(AuthService.name);
    30: 
    31:   constructor(private readonly pg: PgPoolService) { }
    32: 
    33:   /**
    34:    * Enroll (or re-enroll) an agent.
    35:    * - Validates the shared enrollment secret
    36:    * - If deviceId exists, rotates token & updates metadata
    37:    * - Otherwise creates a new agent
    38:    * - Returns { agentId, agentToken }
    39:    *
    40:    * Tables/columns expected:
    41:    *   agents(id uuid pk, device_id text unique, hostname text, os text, arch text,
    42:    *          version text, token_hash text, created_at timestamptz, updated_at timestamptz)
    43:    */
    44:   async enrollAgent(input: EnrollInput) {
    45:     const expected = process.env.ENROLLMENT_SECRET || "";
    46:     if (!expected || input.enrollmentSecret !== expected) {
    47:       throw new UnauthorizedException("Invalid enrollment secret");
    48:     }
    49: 
    50:     try {
    51:       const token = newOpaqueToken();
    52:       const tokenHash = hashToken(token);
    53: 
    54:       // Look up existing agent by deviceId to avoid duplicates
    55:       const existing = await this.pg.query<{ id: string }>(
    56:         `SELECT id FROM agents WHERE device_id = $1 LIMIT 1`,
    57:         [input.deviceId],
    58:       );
    59: 
    60:       let agentId: string;
    61: 
    62:       if (existing.rows[0]) {
    63:         const { rows } = await this.pg.query<{ id: string }>(
    64:           `UPDATE agents
    65:               SET hostname   = $2,
    66:                   os         = $3,
    67:                   arch       = $4,
    68:                   version    = $5,
    69:                   token_hash = $6,
    70:                   updated_at = now()
    71:             WHERE id = $1
    72:           RETURNING id`,
    73:           [
    74:             existing.rows[0].id,
    75:             input.hostname,
    76:             input.os,
    77:             input.arch,
    78:             input.version,
    79:             tokenHash,
    80:           ],
    81:         );
    82:         agentId = rows[0].id;
    83:         this.logger.log(`Re-enrolled agent ${agentId} (deviceId=${input.deviceId}).`);
    84:       } else {
    85:         const { rows } = await this.pg.query<{ id: string }>(
    86:           `INSERT INTO agents (device_id, hostname, os, arch, version, token_hash, created_at, updated_at)
    87:            VALUES ($1, $2, $3, $4, $5, $6, now(), now())
    88:            RETURNING id`,
    89:           [
    90:             input.deviceId,
    91:             input.hostname,
    92:             input.os,
    93:             input.arch,
    94:             input.version,
    95:             tokenHash,
    96:           ],
    97:         );
    98:         agentId = rows[0].id;
    99:         this.logger.log(`Enrolled new agent ${agentId} (deviceId=${input.deviceId}).`);
   100:       }
   101: 
   102:       return { agentId, agentToken: token };
   103:     } catch (e: any) {
   104:       const msg = e?.message ?? String(e);
   105:       this.logger.error(`Enroll failed: ${msg}`, e?.stack ?? undefined);
   106:       const dev = (process.env.NODE_ENV || "").toLowerCase() === "development";
   107:       throw new InternalServerErrorException(dev ? `Enroll failed: ${msg}` : "Enroll failed");
   108:     }
   109:   }
   110: 
   111:   /**
   112:    * Validate an agent’s bearer token (opaque string).
   113:    * Returns the agentId on success, or null on failure.
   114:    */
   115:   async validateAgentToken(rawToken: string): Promise<string | null> {
   116:     const tokenHash = hashToken(rawToken);
   117:     const { rows } = await this.pg.query<{ id: string }>(
   118:       `SELECT id FROM agents WHERE token_hash = $1 LIMIT 1`,
   119:       [tokenHash],
   120:     );
   121:     return rows[0]?.id ?? null;
   122:   }
   123: }
-----  END  CONTENT -----

## FILE: src/auth/auth.controller.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\auth.controller.ts
Size: 5198 bytes
SHA256: BBB2B1B76AC099AD57898F0078E0427FD03313E1B0001D4FCDC1AE39EAFEEFC9
----- BEGIN CONTENT -----
     1: //remoteiq-minimal-e2e\backend\src\auth\auth.controller.ts
     2: 
     3: import { Body, Controller, Get, Post, Req, Res, BadRequestException } from "@nestjs/common";
     4: import { ApiOkResponse, ApiTags } from "@nestjs/swagger";
     5: import type { Request, Response } from "express";
     6: import { LoginDto } from "./dto/login.dto";
     7: import { Verify2FADto } from "./dto/verify-2fa.dto";
     8: import { UserAuthService } from "./user-auth.service";
     9: 
    10: @ApiTags("auth")
    11: @Controller("api/auth")
    12: export class AuthController {
    13:     constructor(private readonly users: UserAuthService) { }
    14: 
    15:     @Post("login")
    16:     @ApiOkResponse({ description: "Sets auth cookie on success or returns 2FA challenge when required" })
    17:     async login(
    18:         @Body() dto: LoginDto & { deviceFingerprint?: string },
    19:         @Req() req: Request,
    20:         @Res({ passthrough: true }) res: Response,
    21:     ) {
    22:         // 1) Validate user
    23:         const user = await this.users.validateUser(dto.email, dto.password);
    24: 
    25:         // 2) 2FA gate
    26:         const is2FAEnabled = await this.users.isTwoFactorEnabled(user.id);
    27:         const deviceTrusted = await this.users.isDeviceTrusted(user.id, dto.deviceFingerprint ?? null);
    28:         if (is2FAEnabled && !deviceTrusted) {
    29:             const { token: challengeToken, jti } = await this.users.createChallengeToken(user.id);
    30:             return { status: "2fa_required" as const, challengeToken, jti };
    31:         }
    32: 
    33:         // 3) Issue JWT with JTI
    34:         const { token, jti } = await this.users.signWithJti(user);
    35: 
    36:         // 4) Record session
    37:         const ua = req.headers["user-agent"] || "";
    38:         const ip =
    39:             (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
    40:             (req.socket as any)?.remoteAddress ||
    41:             "";
    42:         await this.users.recordSessionOnLogin(user.id, jti, String(ua), String(ip));
    43: 
    44:         // 5) Set cookie
    45:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
    46:         const maxAgeMs = Number(process.env.AUTH_COOKIE_MAX_AGE_MS || 7 * 24 * 60 * 60 * 1000); // 7d
    47:         res.cookie(cookieName, token, {
    48:             httpOnly: true,
    49:             sameSite: "lax",
    50:             secure: process.env.NODE_ENV === "production",
    51:             path: "/",
    52:             maxAge: maxAgeMs,
    53:         });
    54: 
    55:         return { user };
    56:     }
    57: 
    58:     @Post("2fa/verify")
    59:     @ApiOkResponse({ description: "Verifies TOTP or recovery code and sets auth cookie" })
    60:     async verify2FA(@Body() dto: Verify2FADto, @Req() req: Request, @Res({ passthrough: true }) res: Response) {
    61:         // Normalize incoming values
    62:         if (dto.code) dto.code = dto.code.trim();
    63:         if (dto.recoveryCode) dto.recoveryCode = dto.recoveryCode.trim();
    64: 
    65:         if (!dto.code && !dto.recoveryCode) {
    66:             throw new BadRequestException("Provide either 'code' or 'recoveryCode'.");
    67:         }
    68: 
    69:         // 1) Validate challenge and extract userId + jti
    70:         const { userId, jti } = await this.users.verifyChallengeToken(dto.challengeToken);
    71: 
    72:         // 2) Verify TOTP or recovery
    73:         let ok = false;
    74:         if (dto.code) ok = await this.users.verifyTOTP(userId, dto.code);
    75:         else if (dto.recoveryCode) ok = await this.users.consumeRecoveryCode(userId, dto.recoveryCode);
    76: 
    77:         if (!ok) throw new BadRequestException("Invalid code");
    78: 
    79:         // 3) Sign normal auth token with JTI and set cookie
    80:         const user = await this.users.findUserById(userId);
    81:         const { token, jti: newJti } = await this.users.signWithJti(user);
    82: 
    83:         const ua = req.headers["user-agent"] || "";
    84:         const ip =
    85:             (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
    86:             (req.socket as any)?.remoteAddress ||
    87:             "";
    88:         await this.users.recordSessionOnLogin(userId, newJti, String(ua), String(ip));
    89: 
    90:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
    91:         const maxAgeMs = Number(process.env.AUTH_COOKIE_MAX_AGE_MS || 7 * 24 * 60 * 60 * 1000);
    92:         res.cookie(cookieName, token, {
    93:             httpOnly: true,
    94:             sameSite: "lax",
    95:             secure: process.env.NODE_ENV === "production",
    96:             path: "/",
    97:             maxAge: maxAgeMs,
    98:         });
    99: 
   100:         // 4) Trust device if requested
   101:         if (dto.rememberDevice) {
   102:             const fp = dto.deviceFingerprint ?? jti;
   103:             await this.users.trustCurrentDevice(userId, fp);
   104:         }
   105: 
   106:         return { ok: true };
   107:     }
   108: 
   109:     @Post("logout")
   110:     @ApiOkResponse({ description: "Clears auth cookie" })
   111:     async logout(@Res({ passthrough: true }) res: Response) {
   112:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
   113:         res.clearCookie(cookieName, { path: "/" });
   114:         return { ok: true };
   115:     }
   116: 
   117:     @Get("me")
   118:     @ApiOkResponse({ description: "Current user (if authenticated)" })
   119:     async me(@Req() req: Request) {
   120:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
   121:         const token = (req as any).cookies?.[cookieName];
   122:         if (!token) return { user: null };
   123:         const user = await this.users.verify(token);
   124:         return { user };
   125:     }
   126: }
-----  END  CONTENT -----

## FILE: src/auth/user-auth.controller.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\user-auth.controller.ts
Size: 5136 bytes
SHA256: 84ED10881FD02FACB2CF20BDBACB7757F6378445BEF06B37ECF3970DF44FE723
----- BEGIN CONTENT -----
     1: import { Body, Controller, Get, Post, Req, Res, BadRequestException } from "@nestjs/common";
     2: import { ApiOkResponse, ApiTags } from "@nestjs/swagger";
     3: import type { Request, Response } from "express";
     4: import { LoginDto } from "./dto/login.dto";
     5: import { Verify2FADto } from "./dto/verify-2fa.dto";
     6: import { UserAuthService } from "./user-auth.service";
     7: 
     8: @ApiTags("auth")
     9: @Controller("api/auth")
    10: export class AuthController {
    11:     constructor(private readonly users: UserAuthService) { }
    12: 
    13:     @Post("login")
    14:     @ApiOkResponse({ description: "Sets auth cookie on success or returns 2FA challenge when required" })
    15:     async login(
    16:         @Body() dto: LoginDto & { deviceFingerprint?: string },
    17:         @Req() req: Request,
    18:         @Res({ passthrough: true }) res: Response,
    19:     ) {
    20:         // 1) Validate user
    21:         const user = await this.users.validateUser(dto.email, dto.password);
    22: 
    23:         // 2) 2FA gate
    24:         const is2FAEnabled = await this.users.isTwoFactorEnabled(user.id);
    25:         const deviceTrusted = await this.users.isDeviceTrusted(user.id, dto.deviceFingerprint ?? null);
    26:         if (is2FAEnabled && !deviceTrusted) {
    27:             const { token: challengeToken, jti } = await this.users.createChallengeToken(user.id);
    28:             return { status: "2fa_required" as const, challengeToken, jti };
    29:         }
    30: 
    31:         // 3) Issue JWT with JTI
    32:         const { token, jti } = await this.users.signWithJti(user);
    33: 
    34:         // 4) Record session
    35:         const ua = req.headers["user-agent"] || "";
    36:         const ip =
    37:             (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
    38:             (req.socket as any)?.remoteAddress ||
    39:             "";
    40:         await this.users.recordSessionOnLogin(user.id, jti, String(ua), String(ip));
    41: 
    42:         // 5) Set cookie
    43:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
    44:         const maxAgeMs = Number(process.env.AUTH_COOKIE_MAX_AGE_MS || 7 * 24 * 60 * 60 * 1000); // 7d
    45:         res.cookie(cookieName, token, {
    46:             httpOnly: true,
    47:             sameSite: "lax",
    48:             secure: process.env.NODE_ENV === "production",
    49:             path: "/",
    50:             maxAge: maxAgeMs,
    51:         });
    52: 
    53:         return { user };
    54:     }
    55: 
    56:     @Post("2fa/verify")
    57:     @ApiOkResponse({ description: "Verifies TOTP or recovery code and sets auth cookie" })
    58:     async verify2FA(@Body() dto: Verify2FADto, @Req() req: Request, @Res({ passthrough: true }) res: Response) {
    59:         // Normalize incoming values
    60:         if (dto.code) dto.code = dto.code.trim();
    61:         if (dto.recoveryCode) dto.recoveryCode = dto.recoveryCode.trim();
    62: 
    63:         if (!dto.code && !dto.recoveryCode) {
    64:             throw new BadRequestException("Provide either 'code' or 'recoveryCode'.");
    65:         }
    66: 
    67:         // 1) Validate challenge and extract userId + jti
    68:         const { userId, jti } = await this.users.verifyChallengeToken(dto.challengeToken);
    69: 
    70:         // 2) Verify TOTP or recovery
    71:         let ok = false;
    72:         if (dto.code) ok = await this.users.verifyTOTP(userId, dto.code);
    73:         else if (dto.recoveryCode) ok = await this.users.consumeRecoveryCode(userId, dto.recoveryCode);
    74: 
    75:         if (!ok) throw new BadRequestException("Invalid code");
    76: 
    77:         // 3) Sign normal auth token with JTI and set cookie
    78:         const user = await this.users.findUserById(userId);
    79:         const { token, jti: newJti } = await this.users.signWithJti(user);
    80: 
    81:         const ua = req.headers["user-agent"] || "";
    82:         const ip =
    83:             (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
    84:             (req.socket as any)?.remoteAddress ||
    85:             "";
    86:         await this.users.recordSessionOnLogin(userId, newJti, String(ua), String(ip));
    87: 
    88:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
    89:         const maxAgeMs = Number(process.env.AUTH_COOKIE_MAX_AGE_MS || 7 * 24 * 60 * 60 * 1000);
    90:         res.cookie(cookieName, token, {
    91:             httpOnly: true,
    92:             sameSite: "lax",
    93:             secure: process.env.NODE_ENV === "production",
    94:             path: "/",
    95:             maxAge: maxAgeMs,
    96:         });
    97: 
    98:         // 4) Trust device if requested
    99:         if (dto.rememberDevice) {
   100:             const fp = dto.deviceFingerprint ?? jti;
   101:             await this.users.trustCurrentDevice(userId, fp);
   102:         }
   103: 
   104:         return { ok: true };
   105:     }
   106: 
   107:     @Post("logout")
   108:     @ApiOkResponse({ description: "Clears auth cookie" })
   109:     async logout(@Res({ passthrough: true }) res: Response) {
   110:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
   111:         res.clearCookie(cookieName, { path: "/" });
   112:         return { ok: true };
   113:     }
   114: 
   115:     @Get("me")
   116:     @ApiOkResponse({ description: "Current user (if authenticated)" })
   117:     async me(@Req() req: Request) {
   118:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
   119:         const token = (req as any).cookies?.[cookieName];
   120:         if (!token) return { user: null };
   121:         const user = await this.users.verify(token);
   122:         return { user };
   123:     }
   124: }
-----  END  CONTENT -----

## FILE: src/auth/user-auth.service.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\user-auth.service.ts
Size: 16833 bytes
SHA256: 1FD6DE307CAEADA4E262862CFF8B487C760886BF55628D691376E088A4F69AD4
----- BEGIN CONTENT -----
     1: //remoteiq-minimal-e2e\backend\src\auth\user-auth.service.ts
     2: 
     3: import { Injectable, UnauthorizedException } from "@nestjs/common";
     4: import { JwtService } from "@nestjs/jwt";
     5: import * as bcrypt from "bcryptjs";
     6: import { PgPoolService } from "../storage/pg-pool.service";
     7: import { OrganizationContextService } from "../storage/organization-context.service";
     8: import { randomUUID, createHash, createHmac } from "crypto";
     9: 
    10: export type RoleSummary = { id: string; name: string };
    11: 
    12: type WebUser = {
    13:     id: string;
    14:     organizationId: string;
    15:     email: string;
    16:     name: string | null;
    17:     role: string;
    18:     roles: RoleSummary[];
    19:     permissions: string[];
    20: };
    21: 
    22: type DbUserRow = {
    23:     id: string;
    24:     email: string;
    25:     first_name: string | null;
    26:     last_name: string | null;
    27:     password_hash: string | null;
    28:     status: string;
    29:     organization_id: string;
    30:     roles: any;
    31:     permissions: string[] | null;
    32: };
    33: 
    34: type UserSecurityRow = {
    35:     user_id: string;
    36:     two_factor_enabled: boolean | null;
    37:     totp_secret: string | null;
    38:     recovery_codes: string[] | null;
    39: };
    40: 
    41: @Injectable()
    42: export class UserAuthService {
    43:     constructor(
    44:         private readonly jwt: JwtService,
    45:         private readonly pg: PgPoolService,
    46:         private readonly orgs: OrganizationContextService,
    47:     ) { }
    48: 
    49:     /** Validate against Postgres users table */
    50:     async validateUser(email: string, password: string): Promise<WebUser> {
    51:         const orgId = await this.orgs.getDefaultOrganizationId();
    52:         const row = await this.loadUserByEmail(orgId, email);
    53:         if (!row || row.status !== "active") {
    54:             throw new UnauthorizedException("Invalid email or password");
    55:         }
    56:         if (!row.password_hash) {
    57:             throw new UnauthorizedException("Invalid email or password");
    58:         }
    59: 
    60:         const ok = await bcrypt.compare(password, row.password_hash);
    61:         if (!ok) throw new UnauthorizedException("Invalid email or password");
    62: 
    63:         return this.mapDbRowToWebUser(row);
    64:     }
    65: 
    66:     /** Issue a JWT **with JTI** (uses JwtModule config). */
    67:     async signWithJti(user: WebUser): Promise<{ token: string; jti: string }> {
    68:         const jti = randomUUID();
    69:         const token = await this.jwt.signAsync({
    70:             sub: user.id,
    71:             email: user.email,
    72:             name: user.name,
    73:             role: user.role,
    74:             org: user.organizationId,
    75:             perms: user.permissions,
    76:             roles: user.roles.map((r) => r.name),
    77:             jti,
    78:         });
    79:         return { token, jti };
    80:     }
    81: 
    82:     /** Back-compat signer without JTI (not used by login anymore) */
    83:     async sign(user: WebUser): Promise<string> {
    84:         return this.jwt.signAsync({
    85:             sub: user.id,
    86:             email: user.email,
    87:             name: user.name,
    88:             role: user.role,
    89:             org: user.organizationId,
    90:             perms: user.permissions,
    91:             roles: user.roles.map((r) => r.name),
    92:         });
    93:     }
    94: 
    95:     /** Verify cookie token and re-hydrate a minimal user */
    96:     async verify(token: string): Promise<WebUser | null> {
    97:         try {
    98:             const payload = await this.jwt.verifyAsync<{
    99:                 sub: string;
   100:                 email: string;
   101:                 name?: string;
   102:                 role: string;
   103:             }>(token, { secret: process.env.JWT_SECRET ?? "dev-secret" });
   104:             const row = await this.loadUserById(payload.sub);
   105:             if (!row || row.status !== "active") return null;
   106:             return this.mapDbRowToWebUser(row);
   107:         } catch {
   108:             return null;
   109:         }
   110:     }
   111: 
   112:     /** Record a session row keyed by JTI (upsert on jti). */
   113:     async recordSessionOnLogin(userId: string, jti: string, ua?: string, ip?: string) {
   114:         await this.pg.query(
   115:             `
   116:       INSERT INTO sessions (id, user_id, refresh_token, user_agent, ip_address)
   117:       VALUES ($2, $1, $3, $4, $5)
   118:       ON CONFLICT (id) DO UPDATE
   119:          SET last_seen_at = now(),
   120:              user_agent   = COALESCE(EXCLUDED.user_agent, sessions.user_agent),
   121:              ip_address   = COALESCE(EXCLUDED.ip_address, sessions.ip_address),
   122:              refresh_token = EXCLUDED.refresh_token
   123:       `,
   124:             [userId, jti, jti, ua || null, ip || null],
   125:         );
   126:     }
   127: 
   128:     // =============== 2FA: feature toggles & device trust =================
   129: 
   130:     async isTwoFactorEnabled(userId: string): Promise<boolean> {
   131:         try {
   132:             const { rows } = await this.pg.query<{ enabled: boolean }>(
   133:                 `
   134:       SELECT
   135:         COALESCE(two_factor_enabled, false)
   136:         AND (totp_secret IS NOT NULL AND length(trim(totp_secret)) > 0)
   137:         AS enabled
   138:       FROM user_security
   139:       WHERE user_id = $1
   140:       LIMIT 1
   141:       `,
   142:                 [userId],
   143:             );
   144:             return !!rows[0]?.enabled;
   145:         } catch (e: any) {
   146:             if (e?.code === "42P01" || e?.code === "42703") return false;
   147:             throw e;
   148:         }
   149:     }
   150: 
   151:     async isDeviceTrusted(userId: string, deviceFingerprint: string | null): Promise<boolean> {
   152:         if (!deviceFingerprint) return false;
   153:         try {
   154:             const { rows } = await this.pg.query(
   155:                 `SELECT 1
   156:            FROM trusted_devices
   157:           WHERE user_id = $1
   158:             AND device_fingerprint = $2
   159:             AND last_seen_at > now() - interval '90 days'
   160:           LIMIT 1`,
   161:                 [userId, deviceFingerprint],
   162:             );
   163:             return !!rows[0];
   164:         } catch {
   165:             return false;
   166:         }
   167:     }
   168: 
   169:     async trustCurrentDevice(userId: string, deviceFingerprint: string) {
   170:         try {
   171:             await this.pg.query(`DELETE FROM trusted_devices WHERE user_id = $1 AND device_fingerprint = $2`, [
   172:                 userId,
   173:                 deviceFingerprint,
   174:             ]);
   175:             await this.pg.query(
   176:                 `INSERT INTO trusted_devices (user_id, device_fingerprint)
   177:          VALUES ($1, $2)`,
   178:                 [userId, deviceFingerprint],
   179:             );
   180:         } catch {
   181:             // ignore if table not present
   182:         }
   183:     }
   184: 
   185:     // =============== 2FA: challenge token (short-lived) ==================
   186: 
   187:     async createChallengeToken(userId: string): Promise<{ token: string; jti: string }> {
   188:         const jti = randomUUID();
   189:         const token = await this.jwt.signAsync(
   190:             { sub: userId, typ: "2fa_challenge", jti },
   191:             { expiresIn: "10m" },
   192:         );
   193:         try {
   194:             const hash = this.sha256Hex(token);
   195:             await this.pg.query(
   196:                 `INSERT INTO login_challenges (id, user_id, challenge, expires_at)
   197:          VALUES ($1, $2, $3, now() + interval '10 minutes')
   198:          ON CONFLICT (id) DO UPDATE
   199:            SET challenge = EXCLUDED.challenge,
   200:                expires_at = EXCLUDED.expires_at,
   201:                consumed_at = NULL`,
   202:                 [jti, userId, hash],
   203:             );
   204:         } catch {
   205:             // ignore if table not present
   206:         }
   207:         return { token, jti };
   208:     }
   209: 
   210:     async verifyChallengeToken(challengeToken: string): Promise<{ userId: string; jti: string }> {
   211:         let decoded: any;
   212:         try {
   213:             decoded = await this.jwt.verifyAsync(challengeToken);
   214:         } catch {
   215:             throw new UnauthorizedException("Invalid or expired challenge");
   216:         }
   217:         if (!decoded?.sub || decoded?.typ !== "2fa_challenge" || !decoded?.jti) {
   218:             throw new UnauthorizedException("Invalid challenge");
   219:         }
   220: 
   221:         try {
   222:             const tokenHash = this.sha256Hex(challengeToken);
   223:             const { rows } = await this.pg.query<{
   224:                 challenge: string;
   225:                 expires_at: string;
   226:                 consumed_at: string | null;
   227:             }>(
   228:                 `SELECT challenge, expires_at, consumed_at
   229:            FROM login_challenges
   230:           WHERE id = $1 AND user_id = $2
   231:           LIMIT 1`,
   232:                 [decoded.jti, decoded.sub],
   233:             );
   234:             const challengeRow = rows[0];
   235:             if (!challengeRow) throw new UnauthorizedException("Invalid challenge");
   236:             if (challengeRow.consumed_at) throw new UnauthorizedException("Challenge already used");
   237:             if (challengeRow.challenge !== tokenHash) throw new UnauthorizedException("Invalid challenge");
   238:             if (new Date(challengeRow.expires_at).getTime() < Date.now()) {
   239:                 throw new UnauthorizedException("Challenge expired");
   240:             }
   241:             await this.pg.query(`UPDATE login_challenges SET consumed_at = now() WHERE id = $1`, [decoded.jti]);
   242:         } catch (err) {
   243:             if (err instanceof UnauthorizedException) throw err;
   244:             throw new UnauthorizedException("Invalid challenge");
   245:         }
   246: 
   247:         return { userId: decoded.sub as string, jti: decoded.jti as string };
   248:     }
   249: 
   250:     // =============== 2FA: verification (TOTP or recovery) =================
   251: 
   252:     async verifyTOTP(userId: string, code: string): Promise<boolean> {
   253:         const u = await this.findUserTwoFactor(userId);
   254:         if (!u?.two_factor_enabled || !u.totp_secret) return false;
   255: 
   256:         const normalized = this.normalizeTotpSecret(u.totp_secret);
   257:         return this.verifyTotpBasic(normalized, code.trim());
   258:     }
   259: 
   260:     async consumeRecoveryCode(userId: string, recoveryCode: string): Promise<boolean> {
   261:         const u = await this.findUserTwoFactor(userId);
   262:         if (!u) return false;
   263:         const codes = u.recovery_codes || [];
   264:         if (codes.length === 0) return false;
   265: 
   266:         const candidateHash = this.sha256Hex(recoveryCode.trim().toLowerCase());
   267:         const idx = codes.findIndex((h) => h === candidateHash);
   268:         if (idx === -1) return false;
   269: 
   270:         const next = [...codes.slice(0, idx), ...codes.slice(idx + 1)];
   271:         await this.pg.query(
   272:             `UPDATE user_security SET recovery_codes = $1 WHERE user_id = $2`,
   273:             [next, userId],
   274:         );
   275:         return true;
   276:     }
   277: 
   278:     // =============== Lookups =================
   279: 
   280:     async findUserById(userId: string): Promise<WebUser> {
   281:         const row = await this.loadUserById(userId);
   282:         if (!row || row.status !== "active") {
   283:             throw new UnauthorizedException("User not found");
   284:         }
   285:         return this.mapDbRowToWebUser(row);
   286:     }
   287: 
   288:     async findUserTwoFactor(userId: string): Promise<UserSecurityRow | null> {
   289:         try {
   290:             const { rows } = await this.pg.query<UserSecurityRow>(
   291:                 `SELECT user_id, two_factor_enabled, totp_secret, recovery_codes
   292:            FROM user_security
   293:           WHERE user_id = $1
   294:           LIMIT 1`,
   295:                 [userId],
   296:             );
   297:             return rows[0] ?? null;
   298:         } catch (e: any) {
   299:             if (e?.code === "42P01" || e?.code === "42703") return null;
   300:             throw e;
   301:         }
   302:     }
   303: 
   304:     // =============== Minimal TOTP (robust parsing) =================
   305: 
   306:     /** Accepts raw base32 or full otpauth:// URI; strips spaces and uppercases */
   307:     private normalizeTotpSecret(input: string): string {
   308:         try {
   309:             if (input.toLowerCase().startsWith("otpauth://")) {
   310:                 const u = new URL(input);
   311:                 const secret = u.searchParams.get("secret") || "";
   312:                 return secret.replace(/\s+/g, "").toUpperCase();
   313:             }
   314:         } catch {
   315:             // not a valid URL; fall through
   316:         }
   317:         return input.replace(/\s+/g, "").toUpperCase();
   318:     }
   319: 
   320:     private sha256Hex(s: string) {
   321:         return createHash("sha256").update(s).digest("hex");
   322:     }
   323: 
   324:     private verifyTotpBasic(base32Secret: string, code: string): boolean {
   325:         try {
   326:             const secret = this.base32Decode(base32Secret);
   327:             const step = 30;
   328:             const t = Math.floor(Date.now() / 1000 / step);
   329: 
   330:             for (const off of [-2, -1, 0, 1, 2]) {
   331:                 const counter = Buffer.alloc(8);
   332:                 counter.writeBigUInt64BE(BigInt(t + off));
   333:                 const hmac = createHmac("sha1", secret).update(counter).digest();
   334:                 const offset = hmac[hmac.length - 1] & 0xf;
   335:                 const bin =
   336:                     ((hmac[offset] & 0x7f) << 24) |
   337:                     ((hmac[offset + 1] & 0xff) << 16) |
   338:                     ((hmac[offset + 2] & 0xff) << 8) |
   339:                     (hmac[offset + 3] & 0xff);
   340:                 const otp = (bin % 1_000_000).toString().padStart(6, "0");
   341:                 if (otp === code) return true;
   342:             }
   343:             return false;
   344:         } catch {
   345:             return false;
   346:         }
   347:     }
   348: 
   349:     private base32Decode(b32: string): Buffer {
   350:         const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
   351:         const clean = b32.replace(/=+$/, "").toUpperCase().replace(/[^A-Z2-7]/g, "");
   352:         let bits = "";
   353:         for (const c of clean) {
   354:             const v = alphabet.indexOf(c);
   355:             if (v < 0) continue;
   356:             bits += v.toString(2).padStart(5, "0");
   357:         }
   358:         const bytes: number[] = [];
   359:         for (let i = 0; i + 8 <= bits.length; i += 8) {
   360:             bytes.push(parseInt(bits.substring(i, i + 8), 2));
   361:         }
   362:         return Buffer.from(bytes);
   363:     }
   364: 
   365:     private async loadUserByEmail(orgId: string, email: string): Promise<DbUserRow | null> {
   366:         const { rows } = await this.pg.query<DbUserRow>(
   367:             `SELECT
   368:                 u.id,
   369:                 u.email,
   370:                 u.first_name,
   371:                 u.last_name,
   372:                 u.password_hash,
   373:                 u.status,
   374:                 u.organization_id,
   375:                 COALESCE(jsonb_agg(DISTINCT jsonb_build_object('id', r.id, 'name', r.name))
   376:                          FILTER (WHERE r.id IS NOT NULL), '[]'::jsonb) AS roles,
   377:                 COALESCE(array_agg(DISTINCT rp.permission_key)
   378:                          FILTER (WHERE rp.permission_key IS NOT NULL), '{}'::text[]) AS permissions
   379:              FROM public.users u
   380:              LEFT JOIN public.user_roles ur ON ur.user_id = u.id
   381:              LEFT JOIN public.roles r ON r.id = ur.role_id
   382:              LEFT JOIN public.role_permissions rp ON rp.role_id = r.id
   383:              WHERE u.organization_id = $1 AND LOWER(u.email) = LOWER($2)
   384:              GROUP BY u.id
   385:              LIMIT 1`,
   386:             [orgId, email],
   387:         );
   388:         return rows[0] ?? null;
   389:     }
   390: 
   391:     private async loadUserById(userId: string): Promise<DbUserRow | null> {
   392:         const { rows } = await this.pg.query<DbUserRow>(
   393:             `SELECT
   394:                 u.id,
   395:                 u.email,
   396:                 u.first_name,
   397:                 u.last_name,
   398:                 u.password_hash,
   399:                 u.status,
   400:                 u.organization_id,
   401:                 COALESCE(jsonb_agg(DISTINCT jsonb_build_object('id', r.id, 'name', r.name))
   402:                          FILTER (WHERE r.id IS NOT NULL), '[]'::jsonb) AS roles,
   403:                 COALESCE(array_agg(DISTINCT rp.permission_key)
   404:                          FILTER (WHERE rp.permission_key IS NOT NULL), '{}'::text[]) AS permissions
   405:              FROM public.users u
   406:              LEFT JOIN public.user_roles ur ON ur.user_id = u.id
   407:              LEFT JOIN public.roles r ON r.id = ur.role_id
   408:              LEFT JOIN public.role_permissions rp ON rp.role_id = r.id
   409:              WHERE u.id = $1
   410:              GROUP BY u.id
   411:              LIMIT 1`,
   412:             [userId],
   413:         );
   414:         return rows[0] ?? null;
   415:     }
   416: 
   417:     private mapDbRowToWebUser(row: DbUserRow): WebUser {
   418:         const roles: RoleSummary[] = Array.isArray(row.roles)
   419:             ? row.roles
   420:                   .map((r: any) => ({
   421:                       id: String(r.id ?? ""),
   422:                       name: String(r.name ?? "").trim(),
   423:                   }))
   424:                   .filter((r) => r.name.length > 0)
   425:             : [];
   426:         const primaryRole = roles[0]?.name || "user";
   427:         const permissions = Array.isArray(row.permissions)
   428:             ? row.permissions.map((p) => String(p).toLowerCase())
   429:             : [];
   430:         const displayName = this.buildDisplayName(row.first_name, row.last_name);
   431: 
   432:         return {
   433:             id: row.id,
   434:             organizationId: row.organization_id,
   435:             email: row.email,
   436:             name: displayName,
   437:             role: primaryRole,
   438:             roles,
   439:             permissions,
   440:         };
   441:     }
   442: 
   443:     private buildDisplayName(first: string | null, last: string | null): string | null {
   444:         const parts = [first?.trim(), last?.trim()].filter(Boolean) as string[];
   445:         if (parts.length === 0) return null;
   446:         return parts.join(" ");
   447:     }
   448: }
-----  END  CONTENT -----

## FILE: src/auth/auth-cookie.guard.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\auth-cookie.guard.ts
Size: 7212 bytes
SHA256: 7AD9A07524B3DB26DF5E12E3C43C34AB6D666E20A0D60DBDE5C8D8086A4C6C58
----- BEGIN CONTENT -----
     1: import {
     2:     CanActivate,
     3:     ExecutionContext,
     4:     Injectable,
     5:     UnauthorizedException,
     6: } from "@nestjs/common";
     7: import type { Request, Response } from "express";
     8: import { JwtService } from "@nestjs/jwt";
     9: import { PgPoolService } from "../storage/pg-pool.service";
    10: import { randomUUID, createHash } from "crypto";
    11: 
    12: function parseCookieMaxAge(): number {
    13:     const v = process.env.AUTH_COOKIE_MAX_AGE_MS;
    14:     const n = Number(v);
    15:     return Number.isFinite(n) && n > 0 ? n : 7 * 24 * 60 * 60 * 1000;
    16: }
    17: 
    18: function hashToken(token: string): string {
    19:     return createHash("sha256").update(token, "utf8").digest("hex");
    20: }
    21: 
    22: type DbUserRow = {
    23:     id: string;
    24:     email: string;
    25:     first_name: string | null;
    26:     last_name: string | null;
    27:     status: string;
    28:     organization_id: string;
    29:     roles: any;
    30:     permissions: string[] | null;
    31: };
    32: 
    33: function buildDisplayName(first: string | null, last: string | null, fallback?: string | null): string | null {
    34:     const parts = [first?.trim(), last?.trim()].filter(Boolean) as string[];
    35:     if (parts.length > 0) return parts.join(" ");
    36:     return fallback ?? null;
    37: }
    38: 
    39: @Injectable()
    40: export class AuthCookieGuard implements CanActivate {
    41:     constructor(
    42:         private readonly jwt: JwtService,
    43:         private readonly pg: PgPoolService,
    44:     ) { }
    45: 
    46:     async canActivate(context: ExecutionContext): Promise<boolean> {
    47:         const req = context.switchToHttp().getRequest<Request>();
    48:         const res = context.switchToHttp().getResponse<Response>();
    49: 
    50:         const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
    51:         const tokenFromCookie =
    52:             (req as any).cookies?.[cookieName] ||
    53:             (req as any).cookies?.["auth_token"];
    54:         const tokenFromHeader =
    55:             req.headers.authorization?.replace(/^Bearer\s+/i, "") || null;
    56: 
    57:         const token = tokenFromCookie || tokenFromHeader;
    58:         if (!token) throw new UnauthorizedException("No auth token provided");
    59: 
    60:         let payload: any;
    61:         try {
    62:             payload = await this.jwt.verifyAsync(token, {
    63:                 secret: process.env.JWT_SECRET ?? "dev-secret",
    64:             });
    65:         } catch {
    66:             throw new UnauthorizedException("Invalid token");
    67:         }
    68:         if (!payload?.sub) throw new UnauthorizedException("Invalid token payload");
    69: 
    70:         const userRow = await this.loadUserById(String(payload.sub));
    71:         if (!userRow || userRow.status !== "active") {
    72:             throw new UnauthorizedException("Account disabled");
    73:         }
    74: 
    75:         const roles: string[] = Array.isArray(userRow.roles)
    76:             ? userRow.roles.map((r: any) => String(r.name ?? r).trim()).filter(Boolean)
    77:             : [];
    78:         const permissions = Array.isArray(userRow.permissions)
    79:             ? userRow.permissions.map((p) => String(p).toLowerCase())
    80:             : [];
    81:         const displayName = buildDisplayName(userRow.first_name, userRow.last_name, payload.name);
    82:         const primaryRole = roles[0] || payload.role || "user";
    83: 
    84:         (req as any).user = {
    85:             id: userRow.id,
    86:             email: userRow.email,
    87:             name: displayName,
    88:             organizationId: userRow.organization_id,
    89:             roles,
    90:             role: primaryRole,
    91:             permissions,
    92:         };
    93: 
    94:         let jti: string | null = payload?.jti != null ? String(payload.jti) : null;
    95:         if (!jti) {
    96:             jti = randomUUID();
    97:             const newToken = await this.jwt.signAsync({
    98:                 sub: payload.sub,
    99:                 email: payload.email,
   100:                 name: displayName,
   101:                 role: primaryRole,
   102:                 org: userRow.organization_id,
   103:             perms: permissions,
   104:                 jti,
   105:             });
   106: 
   107:             res.cookie(cookieName, newToken, {
   108:                 httpOnly: true,
   109:                 sameSite: "lax",
   110:                 secure: process.env.NODE_ENV === "production",
   111:                 path: "/",
   112:                 maxAge: parseCookieMaxAge(),
   113:             });
   114: 
   115:             const ipHdr = (req.headers["x-forwarded-for"] as string) || "";
   116:             const ip = (ipHdr.split(",")[0] || req.ip || "").trim() || null;
   117:             const ua = req.get("user-agent") || null;
   118: 
   119:             await this.upsertSession(userRow.id, jti, ua, ip, hashToken(newToken));
   120:         }
   121: 
   122:         (req as any).jti = jti;
   123: 
   124:         if (jti) {
   125:             const ipHdr = (req.headers["x-forwarded-for"] as string) || "";
   126:             const ip = (ipHdr.split(",")[0] || req.ip || "").trim() || null;
   127:             const ua = req.get("user-agent") || null;
   128:             this.pg
   129:                 .query(
   130:                     `UPDATE sessions
   131:              SET last_seen_at = now(),
   132:                  ip_address = COALESCE($2, ip_address),
   133:                  user_agent = COALESCE($3, user_agent)
   134:            WHERE id = $1 AND revoked_at IS NULL`,
   135:                     [jti, ip, ua],
   136:                 )
   137:                 .catch(() => { });
   138:         }
   139: 
   140:         return true;
   141:     }
   142: 
   143:     private async upsertSession(userId: string, sessionId: string, ua: string | null, ip: string | null, tokenHash: string) {
   144:         await this.pg.query(
   145:             `
   146:         INSERT INTO sessions (id, user_id, refresh_token, user_agent, ip_address)
   147:         VALUES ($2, $1, $3, $4, $5)
   148:         ON CONFLICT (id) DO UPDATE
   149:            SET last_seen_at = now(),
   150:                user_agent   = COALESCE(EXCLUDED.user_agent, sessions.user_agent),
   151:                ip_address   = COALESCE(EXCLUDED.ip_address, sessions.ip_address),
   152:                refresh_token = EXCLUDED.refresh_token
   153:         `,
   154:             [userId, sessionId, tokenHash, ua || null, ip || null],
   155:         );
   156:     }
   157: 
   158:     private async loadUserById(userId: string): Promise<DbUserRow | null> {
   159:         try {
   160:             const { rows } = await this.pg.query<DbUserRow>(
   161:                 `SELECT
   162:                     u.id,
   163:                     u.email,
   164:                     u.first_name,
   165:                     u.last_name,
   166:                     u.status,
   167:                     u.organization_id,
   168:                     COALESCE(jsonb_agg(DISTINCT jsonb_build_object('id', r.id, 'name', r.name))
   169:                              FILTER (WHERE r.id IS NOT NULL), '[]'::jsonb) AS roles,
   170:                     COALESCE(array_agg(DISTINCT rp.permission_key)
   171:                              FILTER (WHERE rp.permission_key IS NOT NULL), '{}'::text[]) AS permissions
   172:                  FROM public.users u
   173:                  LEFT JOIN public.user_roles ur ON ur.user_id = u.id
   174:                  LEFT JOIN public.roles r ON r.id = ur.role_id
   175:                  LEFT JOIN public.role_permissions rp ON rp.role_id = r.id
   176:                  WHERE u.id = $1
   177:                  GROUP BY u.id`,
   178:                 [userId],
   179:             );
   180:             if (!rows.length) return null;
   181:             const row = rows[0];
   182:             return {
   183:                 ...row,
   184:                 roles: Array.isArray(row.roles) ? row.roles : [],
   185:                 permissions: Array.isArray(row.permissions) ? row.permissions : [],
   186:             };
   187:         } catch {
   188:             return null;
   189:         }
   190:     }
   191: }
-----  END  CONTENT -----

## FILE: src/auth/auth-cookie.middleware.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\auth-cookie.middleware.ts
Size: 5239 bytes
SHA256: 34141557F3D7E03F5DA7CBBF9DF094783F10521A6BD7D6E92274F4635A838437
----- BEGIN CONTENT -----
     1: import { Injectable, NestMiddleware } from "@nestjs/common";
     2: import type { Request, Response, NextFunction } from "express";
     3: import { JwtService } from "@nestjs/jwt";
     4: import { PgPoolService } from "../storage/pg-pool.service";
     5: 
     6: const SESSION_IDLE_UPDATE_SECS =
     7:     parseInt(process.env.SESSION_IDLE_UPDATE_SECS || "300", 10) || 300;
     8: 
     9: type DbSessionRow = { revoked_at: string | null; last_seen_at: string };
    10: type DbUserRow = {
    11:     id: string;
    12:     email: string;
    13:     first_name: string | null;
    14:     last_name: string | null;
    15:     status: string;
    16:     organization_id: string;
    17:     roles: any;
    18:     permissions: string[] | null;
    19: };
    20: 
    21: function buildDisplayName(first: string | null, last: string | null): string | null {
    22:     const parts = [first?.trim(), last?.trim()].filter(Boolean) as string[];
    23:     if (parts.length === 0) return null;
    24:     return parts.join(" ");
    25: }
    26: 
    27: @Injectable()
    28: export class AuthCookieMiddleware implements NestMiddleware {
    29:     private readonly cookieName: string;
    30: 
    31:     constructor(
    32:         private readonly jwt: JwtService,
    33:         private readonly pg: PgPoolService,
    34:     ) {
    35:         this.cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
    36:     }
    37: 
    38:     async use(req: Request & { user?: any; jti?: string }, res: Response, next: NextFunction) {
    39:         try {
    40:             const token = (req as any).cookies?.[this.cookieName];
    41:             if (!token) return next();
    42: 
    43:             const payload = await this.jwt.verifyAsync<any>(token, {
    44:                 secret: process.env.JWT_SECRET ?? "dev-secret",
    45:             });
    46: 
    47:             const userRow = await this.loadUserById(payload.sub);
    48:             if (!userRow || userRow.status !== "active") {
    49:                 return next();
    50:             }
    51: 
    52:             const displayName = buildDisplayName(userRow.first_name, userRow.last_name) || payload.name || null;
    53:             const roles: string[] = Array.isArray(userRow.roles)
    54:                 ? userRow.roles.map((r: any) => String(r.name ?? r).trim()).filter(Boolean)
    55:                 : [];
    56:             const permissions = Array.isArray(userRow.permissions)
    57:                 ? userRow.permissions.map((p) => String(p).toLowerCase())
    58:                 : [];
    59:             const primaryRole = roles[0] || payload.role || "user";
    60: 
    61:             req.user = {
    62:                 id: userRow.id,
    63:                 email: userRow.email,
    64:                 name: displayName,
    65:                 organizationId: userRow.organization_id,
    66:                 roles,
    67:                 role: primaryRole,
    68:                 permissions,
    69:             };
    70:             req.jti = payload.jti;
    71: 
    72:             if (req.jti) {
    73:                 const session = await this.loadSession(req.jti);
    74:                 if (session?.revoked_at) {
    75:                     return res.status(401).json({ message: "Session revoked." });
    76:                 }
    77:                 if (session) {
    78:                     const lastSeen = new Date(session.last_seen_at).getTime();
    79:                     const now = Date.now();
    80:                     if ((now - lastSeen) / 1000 > SESSION_IDLE_UPDATE_SECS) {
    81:                         await this.pg.query(`UPDATE sessions SET last_seen_at = now() WHERE id = $1`, [req.jti]);
    82:                     }
    83:                 }
    84:             }
    85:         } catch {
    86:             // ignore broken/expired token; route can still choose to 401
    87:         }
    88:         next();
    89:     }
    90: 
    91:     private async loadSession(id: string): Promise<DbSessionRow | null> {
    92:         try {
    93:             const { rows } = await this.pg.query<DbSessionRow>(
    94:                 `SELECT revoked_at, last_seen_at FROM sessions WHERE id = $1 LIMIT 1`,
    95:                 [id],
    96:             );
    97:             return rows[0] ?? null;
    98:         } catch {
    99:             return null;
   100:         }
   101:     }
   102: 
   103:     private async loadUserById(userId: string): Promise<DbUserRow | null> {
   104:         try {
   105:             const { rows } = await this.pg.query<DbUserRow>(
   106:                 `SELECT
   107:                     u.id,
   108:                     u.email,
   109:                     u.first_name,
   110:                     u.last_name,
   111:                     u.status,
   112:                     u.organization_id,
   113:                     COALESCE(jsonb_agg(DISTINCT jsonb_build_object('id', r.id, 'name', r.name))
   114:                              FILTER (WHERE r.id IS NOT NULL), '[]'::jsonb) AS roles,
   115:                     COALESCE(array_agg(DISTINCT rp.permission_key)
   116:                              FILTER (WHERE rp.permission_key IS NOT NULL), '{}'::text[]) AS permissions
   117:                  FROM public.users u
   118:                  LEFT JOIN public.user_roles ur ON ur.user_id = u.id
   119:                  LEFT JOIN public.roles r ON r.id = ur.role_id
   120:                  LEFT JOIN public.role_permissions rp ON rp.role_id = r.id
   121:                  WHERE u.id = $1
   122:                  GROUP BY u.id`,
   123:                 [userId],
   124:             );
   125:             if (!rows.length) return null;
   126:             const row = rows[0];
   127:             return {
   128:                 ...row,
   129:                 roles: Array.isArray(row.roles) ? row.roles : [],
   130:                 permissions: Array.isArray(row.permissions) ? row.permissions : [],
   131:             };
   132:         } catch {
   133:             return null;
   134:         }
   135:     }
   136: }
-----  END  CONTENT -----

## FILE: src/auth/permissions.guard.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\permissions.guard.ts
Size: 3691 bytes
SHA256: 13CEFF362E6D9269D907254C3D397721049256FEE4A60ED549FD46C237BF5A0C
----- BEGIN CONTENT -----
     1: import {
     2:     CanActivate,
     3:     ExecutionContext,
     4:     ForbiddenException,
     5:     Injectable,
     6: } from "@nestjs/common";
     7: import { Reflector } from "@nestjs/core";
     8: import { REQUIRE_PERM_KEY, RequirePermMetadata } from "./require-perm.decorator";
     9: import { PgPoolService } from "../storage/pg-pool.service";
    10: import { permsForRoles } from "./policy";
    11: 
    12: @Injectable()
    13: export class PermissionsGuard implements CanActivate {
    14:     constructor(
    15:         private readonly reflector: Reflector,
    16:         private readonly db: PgPoolService
    17:     ) { }
    18: 
    19:     async canActivate(ctx: ExecutionContext): Promise<boolean> {
    20:         const req = ctx.switchToHttp().getRequest<any>();
    21: 
    22:         const required: RequirePermMetadata | undefined =
    23:             this.reflector.getAllAndOverride<RequirePermMetadata>(REQUIRE_PERM_KEY, [
    24:                 ctx.getHandler(),
    25:                 ctx.getClass(),
    26:             ]);
    27: 
    28:         const apiKey = req.header?.("x-admin-api-key") ?? req.headers?.["x-admin-api-key"];
    29:         if (apiKey && process.env.ADMIN_API_KEY && apiKey === process.env.ADMIN_API_KEY) {
    30:             return true;
    31:         }
    32: 
    33:         const user = req.user;
    34:         if (!user) throw new ForbiddenException("Not authenticated");
    35: 
    36:         if (!required || required.length === 0) return true;
    37: 
    38:         let userPerms = this.normalizePerms(user.permissions);
    39: 
    40:         if (userPerms.length === 0) {
    41:             const roleHints = this.extractRoleNames(user);
    42:             if (roleHints.length) {
    43:                 const defaults = permsForRoles(roleHints);
    44:                 if (defaults.size) {
    45:                     userPerms = Array.from(defaults);
    46:                 }
    47:             }
    48:         }
    49: 
    50:         if (userPerms.length === 0 && user.id) {
    51:             userPerms = await this.loadPermsFromRoles(user.id);
    52:         }
    53: 
    54:         const userSet = new Set(userPerms.map((p) => p.toLowerCase()));
    55: 
    56:         for (const r of required) {
    57:             const key = String(r).toLowerCase();
    58:             if (!userSet.has(key)) {
    59:                 throw new ForbiddenException("Insufficient permissions");
    60:             }
    61:         }
    62: 
    63:         return true;
    64:     }
    65: 
    66:     private normalizePerms(val: any): string[] {
    67:         if (!val) return [];
    68:         if (Array.isArray(val)) return val.map((x) => String(x).toLowerCase());
    69:         if (typeof val === "object") return Object.keys(val).map((k) => k.toLowerCase());
    70:         const s = String(val);
    71:         if (s.includes(",")) {
    72:             return s.split(",").map((x) => x.trim().toLowerCase()).filter(Boolean);
    73:         }
    74:         return [s.toLowerCase()];
    75:     }
    76: 
    77:     private async loadPermsFromRoles(userId: string): Promise<string[]> {
    78:         try {
    79:             const { rows } = await this.db.query<{ permission_key: string }>(
    80:                 `SELECT DISTINCT rp.permission_key
    81:            FROM public.user_roles ur
    82:            JOIN public.role_permissions rp ON rp.role_id = ur.role_id
    83:           WHERE ur.user_id = $1`,
    84:                 [userId],
    85:             );
    86:             return rows.map((r) => r.permission_key.toLowerCase());
    87:         } catch {
    88:             return [];
    89:         }
    90:     }
    91: 
    92:     private extractRoleNames(user: any): string[] {
    93:         const out = new Set<string>();
    94:         const push = (val: unknown) => {
    95:             if (!val) return;
    96:             const name = String(val).trim();
    97:             if (name) out.add(name.toLowerCase());
    98:         };
    99: 
   100:         if (Array.isArray(user?.roles)) user.roles.forEach(push);
   101:         push(user?.role);
   102:         push(user?.roleName);
   103:         push(user?.role_name);
   104:         if (user?.role?.name) push(user.role.name);
   105: 
   106:         return Array.from(out);
   107:     }
   108: }
-----  END  CONTENT -----

## FILE: src/auth/require-perm.decorator.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\require-perm.decorator.ts
Size: 641 bytes
SHA256: 1397018D81682B2C3559E30E3FCDE928814DC55D19E9A430120AE1D3E0CDA2C3
----- BEGIN CONTENT -----
     1: import { SetMetadata } from "@nestjs/common";
     2: import type { Permission } from "./policy";
     3: 
     4: /**
     5:  * Metadata key consumed by the PermissionsGuard.
     6:  * Always normalized to an array of Permission strings.
     7:  */
     8: export const REQUIRE_PERM_KEY = "require_perm";
     9: 
    10: /**
    11:  * Attach one or more required permissions to a route or controller.
    12:  *
    13:  * Usage:
    14:  *   @RequirePerm("backups.manage")
    15:  *   @RequirePerm(["backups.read", "backups.download"])
    16:  */
    17: export const RequirePerm = (perm: Permission | Permission[]) =>
    18:     SetMetadata(REQUIRE_PERM_KEY, Array.isArray(perm) ? perm : [perm]);
    19: 
    20: export type RequirePermMetadata = Permission[];
-----  END  CONTENT -----

## FILE: src/auth/policy.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\policy.ts
Size: 3956 bytes
SHA256: 6DF0ADC85356539F3C636B7B6E90BE655E8E0E91CDD25ECAEE1227BB642611CF
----- BEGIN CONTENT -----
     1: export type PermissionGroup = {
     2:     key: string;
     3:     label: string;
     4:     items: readonly {
     5:         key: string;
     6:         label: string;
     7:         description?: string;
     8:     }[];
     9: };
    10: 
    11: export const PERMISSION_GROUPS = [
    12:     {
    13:         key: "users",
    14:         label: "Users",
    15:         items: [
    16:             { key: "users.read", label: "View users" },
    17:             { key: "users.write", label: "Create/edit users" },
    18:             { key: "users.delete", label: "Remove users" },
    19:             { key: "users.2fa.reset", label: "Reset 2FA" },
    20:         ] as const,
    21:     },
    22:     {
    23:         key: "roles",
    24:         label: "Roles",
    25:         items: [
    26:             { key: "roles.read", label: "View roles" },
    27:             { key: "roles.write", label: "Create/edit roles" },
    28:             { key: "roles.delete", label: "Delete roles" },
    29:         ] as const,
    30:     },
    31:     {
    32:         key: "teams",
    33:         label: "Teams",
    34:         items: [
    35:             { key: "teams.read", label: "View teams" },
    36:             { key: "teams.write", label: "Create/edit teams" },
    37:             { key: "teams.delete", label: "Delete teams" },
    38:         ] as const,
    39:     },
    40:     {
    41:         key: "billing",
    42:         label: "Billing",
    43:         items: [
    44:             { key: "billing.read", label: "View billing" },
    45:             { key: "billing.write", label: "Manage billing" },
    46:         ] as const,
    47:     },
    48:     {
    49:         key: "settings",
    50:         label: "Settings",
    51:         items: [
    52:             { key: "settings.read", label: "View settings" },
    53:             { key: "settings.write", label: "Manage settings" },
    54:         ] as const,
    55:     },
    56:     {
    57:         key: "backups",
    58:         label: "Backups",
    59:         items: [
    60:             { key: "backups.read", label: "View config and history" },
    61:             { key: "backups.run", label: "Start, retry or cancel backups" },
    62:             { key: "backups.prune", label: "Prune artifacts" },
    63:             { key: "backups.manage", label: "Configure/test destinations" },
    64:             { key: "backups.restore", label: "Initiate restores" },
    65:             { key: "backups.download", label: "Download artifacts" },
    66:         ] as const,
    67:     },
    68: ] as const satisfies readonly PermissionGroup[];
    69: 
    70: type PermissionItem = (typeof PERMISSION_GROUPS)[number]["items"][number];
    71: 
    72: export type Permission = PermissionItem["key"];
    73: 
    74: export type PermissionDefinition = PermissionItem & {
    75:     groupKey: string;
    76:     groupLabel: string;
    77: };
    78: 
    79: export const PERMISSION_DEFINITIONS: PermissionDefinition[] = PERMISSION_GROUPS.flatMap(
    80:     (group) =>
    81:         group.items.map((item) => ({
    82:             ...item,
    83:             groupKey: group.key,
    84:             groupLabel: group.label,
    85:         }))
    86: );
    87: 
    88: export const ALL_PERMISSIONS: Permission[] = PERMISSION_DEFINITIONS.map((d) => d.key);
    89: 
    90: // Optional role names if you still use a role -> default-permissions map somewhere
    91: export type Role = "owner" | "admin" | "operator" | "viewer";
    92: 
    93: // Advisory defaults for built-in roles (guards still check req.user permissions).
    94: export const rolePermissions: Record<Role, Permission[]> = {
    95:     owner: [...ALL_PERMISSIONS],
    96:     admin: [...ALL_PERMISSIONS],
    97:     operator: [
    98:         "users.read",
    99:         "roles.read",
   100:         "teams.read",
   101:         "billing.read",
   102:         "settings.read",
   103:         "backups.read",
   104:         "backups.run",
   105:         "backups.download",
   106:     ],
   107:     viewer: [
   108:         "users.read",
   109:         "roles.read",
   110:         "teams.read",
   111:         "billing.read",
   112:         "settings.read",
   113:         "backups.read",
   114:     ],
   115: };
   116: 
   117: // ---- Helpers (optional, used by some older code paths) ----
   118: export function permsForRoles(roles: string[] | undefined | null): Set<Permission> {
   119:     const out = new Set<Permission>();
   120:     if (!roles) return out;
   121:     for (const r of roles) {
   122:         const key = r as Role;
   123:         const list = rolePermissions[key];
   124:         if (list) list.forEach((p) => out.add(p));
   125:     }
   126:     return out;
   127: }
   128: 
   129: export function hasPerm(roles: string[] | undefined | null, perm: Permission): boolean {
   130:     return permsForRoles(roles).has(perm);
   131: }
-----  END  CONTENT -----

## FILE: src/auth/session-heartbeat.middleware.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\session-heartbeat.middleware.ts
Size: 2079 bytes
SHA256: AFB24E6380733E3BE18D4B69134C5B8DA901D7D42EFEDB88EE5E00931FB38A19
----- BEGIN CONTENT -----
     1: // backend/src/auth/session-heartbeat.middleware.ts
     2: import { Injectable, NestMiddleware } from "@nestjs/common";
     3: import type { Request, Response, NextFunction } from "express";
     4: import { PgPoolService } from "../storage/pg-pool.service";
     5: 
     6: /**
     7:  * SessionHeartbeatMiddleware
     8:  * - Runs only where you register it (we’ll scope it to /api/users/me/* in AppModule)
     9:  * - Requires req.user.id and req.jti (populated by your AuthCookieMiddleware)
    10:  * - Updates sessions.last_seen_at AFTER the response to avoid blocking requests
    11:  * - Never throws; errors are swallowed (optional debug log in dev)
    12:  */
    13: @Injectable()
    14: export class SessionHeartbeatMiddleware implements NestMiddleware {
    15:     constructor(private readonly pg: PgPoolService) { }
    16: 
    17:     use(req: Request, res: Response, next: NextFunction) {
    18:         const user: any = (req as any).user;
    19:         const jti: any = (req as any).jti;
    20: 
    21:         if (!user?.id || !jti) {
    22:             return next();
    23:         }
    24: 
    25:         const userId = String(user.id);
    26:         const jtiText = String(jti);
    27:         const ua = String(req.headers["user-agent"] || "");
    28:         const ip =
    29:             (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
    30:             (req.socket as any)?.remoteAddress ||
    31:             null;
    32: 
    33:         // Fire-and-forget after response completes
    34:         res.on("finish", () => {
    35:             this.pg
    36:                 .query(
    37:                     `
    38:           UPDATE sessions
    39:              SET last_seen_at = now(),
    40:                  user_agent   = COALESCE($3, user_agent),
    41:                  ip_address   = COALESCE($4, ip_address)
    42:            WHERE user_id = $1
    43:              AND revoked_at IS NULL
    44:              AND id::text = $2
    45:           `,
    46:                     [userId, jtiText, ua || null, ip || null],
    47:                 )
    48:                 .catch(() => {
    49:                     // Optional dev log:
    50:                     // if (process.env.NODE_ENV !== "production") console.debug("session heartbeat update failed");
    51:                 });
    52:         });
    53: 
    54:         next();
    55:     }
    56: }
-----  END  CONTENT -----

## FILE: src/auth/session-heartbeat.interceptor.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\auth\session-heartbeat.interceptor.ts
Size: 2953 bytes
SHA256: C555D7775DE4214410AF56FA4A2F192E27CE178DF1654BC2700C988BF6A3236C
----- BEGIN CONTENT -----
     1: // backend/src/auth/session-heartbeat.interceptor.ts
     2: import {
     3:     Injectable,
     4:     NestInterceptor,
     5:     ExecutionContext,
     6:     CallHandler,
     7: } from "@nestjs/common";
     8: import type { Request } from "express";
     9: import { Observable } from "rxjs";
    10: import { finalize } from "rxjs/operators";
    11: import { PgPoolService } from "../storage/pg-pool.service";
    12: 
    13: /**
    14:  * Updates sessions.last_seen_at for authenticated web users.
    15:  * - NO-OP when req.user or req.jti are missing
    16:  * - NO-OP for non-API paths and obvious public routes
    17:  * - Never throws; DB errors are swallowed
    18:  */
    19: @Injectable()
    20: export class SessionHeartbeatInterceptor implements NestInterceptor {
    21:     constructor(private readonly pg: PgPoolService) { }
    22: 
    23:     intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    24:         const http = context.switchToHttp();
    25:         const req = http.getRequest<Request>();
    26: 
    27:         // Only touch HTTP requests
    28:         if (!req || !req.url) return next.handle();
    29: 
    30:         const url = req.url;
    31: 
    32:         // Skip non-API requests and public/docs/static routes
    33:         // (adjust if your app has different mounts)
    34:         const skip =
    35:             !url.startsWith("/api") ||
    36:             url.startsWith("/docs") ||
    37:             url.startsWith("/static") ||
    38:             url === "/healthz";
    39: 
    40:         if (skip) return next.handle();
    41: 
    42:         const user: any = (req as any).user;
    43:         const jti: any = (req as any).jti;
    44: 
    45:         // If not authenticated or no JTI, do nothing
    46:         if (!user?.id || !jti) {
    47:             return next.handle();
    48:         }
    49: 
    50:         // Capture request metadata before the stream completes
    51:         const userId = String(user.id);
    52:         const jtiText = String(jti);
    53:         const ua = String(req.headers["user-agent"] || "");
    54:         const ip =
    55:             (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() ||
    56:             (req.socket as any)?.remoteAddress ||
    57:             null;
    58: 
    59:         return next.handle().pipe(
    60:             finalize(() => {
    61:                 // Fire-and-forget: never block response, never throw
    62:                 this.pg
    63:                     .query(
    64:                         `
    65:             UPDATE sessions
    66:                SET last_seen_at = now(),
    67:                    user_agent   = COALESCE($3, user_agent),
    68:                    ip_address   = COALESCE($4, ip_address)
    69:              WHERE user_id = $1
    70:                AND revoked_at IS NULL
    71:                AND id::text = $2
    72:             `,
    73:                         [userId, jtiText, ua || null, ip || null],
    74:                     )
    75:                     .catch(() => {
    76:                         // swallow errors; optionally add dev-only log:
    77:                         if (process.env.NODE_ENV !== "production") {
    78:                             // console.debug("Session heartbeat failed:", err?.message);
    79:                         }
    80:                     });
    81:             }),
    82:         );
    83:     }
    84: }
-----  END  CONTENT -----


##############################################################################

# Users & Roles modules/controllers/services/dtos
## FILE: src/users/users.module.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\users\users.module.ts
Size: 1340 bytes
SHA256: 11A0B14DC7BB84A882C29F09FD960D66F8DB6CFDDF26790EFCDF598612E2107F
----- BEGIN CONTENT -----
     1: //backend\src\users\users.module.ts
     2: 
     3: import { Module, MiddlewareConsumer } from "@nestjs/common";
     4: import { StorageModule } from "../storage/storage.module";
     5: import { AuthModule } from "../auth/auth.module";
     6: import { UsersController } from "./users.controller";
     7: import { UsersService } from "./users.service";
     8: import { MeController } from "./me.controller";
     9: import { MeService } from "./me.service";
    10: import { AuthCookieGuard } from "../auth/auth-cookie.guard";
    11: 
    12: // NEW: Security endpoints
    13: import { SecurityController } from "./security.controller";
    14: import { SecurityService } from "./security.service";
    15: 
    16: // If you want middleware-level cookie decode, you can also import it:
    17: // import { AuthCookieMiddleware } from "../auth/auth-cookie.middleware";
    18: 
    19: @Module({
    20:     imports: [StorageModule, AuthModule],
    21:     controllers: [UsersController, MeController, SecurityController],
    22:     providers: [UsersService, MeService, SecurityService, AuthCookieGuard],
    23:     exports: [UsersService, MeService, SecurityService],
    24: })
    25: export class UsersModule {
    26:     // If you prefer middleware for /api/users/me/*, uncomment below and add AuthCookieMiddleware to providers in AuthModule
    27:     // configure(consumer: MiddlewareConsumer) {
    28:     //   consumer.apply(AuthCookieMiddleware).forRoutes(SecurityController, MeController);
    29:     // }
    30: }
-----  END  CONTENT -----

## FILE: src/users/users.controller.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\users\users.controller.ts
Size: 2501 bytes
SHA256: 6A3405A16C702C2F9865E3F3755B2442863A5E5F75455FBDEBCFC4AEE59464A4
----- BEGIN CONTENT -----
     1: //backend\src\users\users.controller.ts
     2: 
     3: import {
     4:     Body,
     5:     Controller,
     6:     Delete,
     7:     Get,
     8:     HttpCode,
     9:     Param,
    10:     Patch,
    11:     Post,
    12:     Query,
    13:     UsePipes,
    14:     ValidationPipe,
    15: } from "@nestjs/common";
    16: import {
    17:     BulkInviteDto,
    18:     CreateUserDto,
    19:     IdParam,
    20:     InviteUserDto,
    21:     ListUsersQuery,
    22:     ResetPasswordDto,
    23:     SuspendDto,
    24:     UpdateRoleDto,
    25:     UpdateUserDto,
    26: } from "./users.dto";
    27: import { UsersService } from "./users.service";
    28: 
    29: 
    30: @UsePipes(new ValidationPipe({ whitelist: true, transform: true }))
    31: @Controller("/api/admin/users")
    32: export class UsersController {
    33:     constructor(private readonly svc: UsersService) { }
    34: 
    35:     @Get()
    36:     async list(@Query() q: ListUsersQuery) {
    37:         return this.svc.list(q);
    38:     }
    39: 
    40:     @Get("roles")
    41:     async roles() {
    42:         return this.svc.roles();
    43:     }
    44: 
    45:     @Post("invite")
    46:     async invite(@Body() body: InviteUserDto) {
    47:         return this.svc.inviteOne(body);
    48:     }
    49: 
    50:     @Post("invite/bulk")
    51:     async inviteBulk(@Body() body: BulkInviteDto) {
    52:         return this.svc.inviteBulk(body);
    53:     }
    54: 
    55:     @Post("create")
    56:     async create(@Body() body: CreateUserDto) {
    57:         return this.svc.createOne(body);
    58:     }
    59: 
    60:     @Patch(":id/role")
    61:     @HttpCode(204)
    62:     async updateRole(@Param() p: IdParam, @Body() body: UpdateRoleDto) {
    63:         await this.svc.updateRole(p.id, body);
    64:     }
    65: 
    66:     @Patch(":id")
    67:     @HttpCode(204)
    68:     async updateUser(@Param() p: IdParam, @Body() body: UpdateUserDto) {
    69:         await this.svc.updateUser(p.id, body);
    70:     }
    71: 
    72:     // Preferred method
    73:     @Patch(":id/password")
    74:     @HttpCode(204)
    75:     async resetPasswordPatch(@Param() p: IdParam, @Body() body: ResetPasswordDto) {
    76:         await this.svc.setPassword(p.id, body);
    77:     }
    78: 
    79:     // Alias to support UIs that POST to the same endpoint
    80:     @Post(":id/password")
    81:     @HttpCode(204)
    82:     async resetPasswordPost(@Param() p: IdParam, @Body() body: ResetPasswordDto) {
    83:         await this.svc.setPassword(p.id, body);
    84:     }
    85: 
    86:     @Post(":id/reset-2fa")
    87:     @HttpCode(204)
    88:     async reset2fa(@Param() p: IdParam) {
    89:         await this.svc.reset2fa(p.id);
    90:     }
    91: 
    92:     @Post(":id/suspend")
    93:     @HttpCode(204)
    94:     async suspend(@Param() p: IdParam, @Body() body: SuspendDto) {
    95:         await this.svc.setSuspended(p.id, body.suspended);
    96:     }
    97: 
    98:     @Delete(":id")
    99:     @HttpCode(204)
   100:     async remove(@Param() p: IdParam) {
   101:         await this.svc.remove(p.id);
   102:     }
   103: }
-----  END  CONTENT -----

## FILE: src/users/users.service.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\users\users.service.ts
Size: 20151 bytes
SHA256: 837F88EF04C2888883B219BB69CC58DDD84F49AC5B9D512ED0AE495E84C524DA
----- BEGIN CONTENT -----
     1: // backend/src/users/users.service.ts
     2: import {
     3:     BadRequestException,
     4:     ConflictException,
     5:     Injectable,
     6:     NotFoundException,
     7: } from "@nestjs/common";
     8: import * as bcrypt from "bcryptjs";
     9: import { randomUUID } from "crypto";
    10: import { PgPoolService } from "../storage/pg-pool.service";
    11: import { OrganizationContextService } from "../storage/organization-context.service";
    12: import {
    13:     BulkInviteDto,
    14:     CreateUserDto,
    15:     InviteUserDto,
    16:     ListUsersQuery,
    17:     ResetPasswordDto,
    18:     UpdateRoleDto,
    19:     UpdateUserDto,
    20:     UserRow,
    21: } from "./users.dto";
    22: 
    23: const SALT_ROUNDS = 12;
    24: const NAME_SPLIT_REGEX = /\s+/;
    25: const DEFAULT_ROLE_CANDIDATES = ["user", "technician", "admin"];
    26: 
    27: function isUuid(value: string): boolean {
    28:     return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
    29: }
    30: 
    31: function coalesceString(v: unknown): string | null {
    32:     if (typeof v !== "string") return null;
    33:     const trimmed = v.trim();
    34:     return trimmed.length ? trimmed : null;
    35: }
    36: 
    37: function splitDisplayName(name: string | undefined | null): { first: string | null; last: string | null } {
    38:     if (!name) return { first: null, last: null };
    39:     const trimmed = name.trim();
    40:     if (!trimmed) return { first: null, last: null };
    41:     const parts = trimmed.split(NAME_SPLIT_REGEX).filter(Boolean);
    42:     if (parts.length === 0) return { first: null, last: null };
    43:     if (parts.length === 1) return { first: parts[0], last: null };
    44:     const last = parts.pop() as string;
    45:     return { first: parts.join(" "), last };
    46: }
    47: 
    48: type DbUserRow = {
    49:     id: string;
    50:     email: string;
    51:     first_name: string | null;
    52:     last_name: string | null;
    53:     status: string;
    54:     last_seen_at: string | null;
    55:     created_at: string;
    56:     updated_at: string;
    57:     two_factor_enabled: boolean;
    58:     primary_role_id: string | null;
    59:     primary_role_name: string | null;
    60:     roles: any;
    61: };
    62: 
    63: @Injectable()
    64: export class UsersService {
    65:     constructor(
    66:         private readonly pg: PgPoolService,
    67:         private readonly orgs: OrganizationContextService,
    68:     ) { }
    69: 
    70:     private mapUserRow(row: DbUserRow): UserRow {
    71:         const roles = Array.isArray(row.roles)
    72:             ? row.roles
    73:                   .map((r: any) => ({
    74:                       id: String(r.id ?? ""),
    75:                       name: String(r.name ?? "").trim(),
    76:                   }))
    77:                   .filter((r) => r.id && r.name)
    78:             : [];
    79: 
    80:         const primaryRoleName = row.primary_role_name || roles[0]?.name || "";
    81:         const displayNameParts = [row.first_name, row.last_name].map((v) => v?.trim()).filter(Boolean) as string[];
    82:         const displayName = displayNameParts.length
    83:             ? displayNameParts.join(" ")
    84:             : row.email.split("@")[0];
    85: 
    86:         return {
    87:             id: row.id,
    88:             name: displayName,
    89:             email: row.email,
    90:             role: primaryRoleName,
    91:             status: (row.status as UserRow["status"]) ?? "active",
    92:             twoFactorEnabled: !!row.two_factor_enabled,
    93:             suspended: row.status === "suspended",
    94:             lastSeen: row.last_seen_at ? new Date(row.last_seen_at).toISOString() : null,
    95:             createdAt: new Date(row.created_at).toISOString(),
    96:             updatedAt: new Date(row.updated_at).toISOString(),
    97:             roleId: row.primary_role_id,
    98:             roles,
    99:         };
   100:     }
   101: 
   102:     private async ensureUserExists(userId: string): Promise<{ organization_id: string }> {
   103:         const { rows } = await this.pg.query<{ organization_id: string }>(
   104:             `SELECT organization_id FROM public.users WHERE id = $1 LIMIT 1`,
   105:             [userId],
   106:         );
   107:         if (!rows[0]) {
   108:             throw new NotFoundException("User not found");
   109:         }
   110:         return rows[0];
   111:     }
   112: 
   113:     private async ensureUserSecurityRow(userId: string): Promise<void> {
   114:         await this.pg.query(
   115:             `INSERT INTO public.user_security (user_id)
   116:              VALUES ($1)
   117:              ON CONFLICT (user_id) DO NOTHING`,
   118:             [userId],
   119:         );
   120:     }
   121: 
   122:     private async replaceUserRoles(userId: string, roleIds: string[]): Promise<void> {
   123:         await this.pg.query(`DELETE FROM public.user_roles WHERE user_id = $1`, [userId]);
   124:         if (!roleIds.length) return;
   125:         const values = roleIds.map((_, idx) => `($1, $${idx + 2})`).join(", ");
   126:         await this.pg.query(
   127:             `INSERT INTO public.user_roles (user_id, role_id)
   128:              VALUES ${values}`,
   129:             [userId, ...roleIds],
   130:         );
   131:     }
   132: 
   133:     private async findDefaultRoleId(orgId: string): Promise<string | null> {
   134:         const { rows } = await this.pg.query<{ id: string }>(
   135:             `SELECT id
   136:              FROM public.roles
   137:              WHERE (scope = 'organization' AND organization_id = $1)
   138:                 OR scope = 'system'
   139:              ORDER BY
   140:                 CASE LOWER(name)
   141:                     WHEN 'owner' THEN 0
   142:                     WHEN 'admin' THEN 1
   143:                     WHEN 'administrator' THEN 2
   144:                     WHEN 'technician' THEN 3
   145:                     WHEN 'user' THEN 4
   146:                     ELSE 10
   147:                 END,
   148:                 scope DESC,
   149:                 LOWER(name)
   150:              LIMIT 1`,
   151:             [orgId],
   152:         );
   153:         return rows[0]?.id ?? null;
   154:     }
   155: 
   156:     private async resolveRoleId(orgId: string, input?: string | null): Promise<string | null> {
   157:         const trimmed = input?.trim();
   158:         if (trimmed) {
   159:             if (isUuid(trimmed)) {
   160:                 const { rows } = await this.pg.query<{ id: string }>(
   161:                     `SELECT id
   162:                      FROM public.roles
   163:                      WHERE id = $1 AND ((scope = 'organization' AND organization_id = $2) OR scope = 'system')
   164:                      LIMIT 1`,
   165:                     [trimmed, orgId],
   166:                 );
   167:                 if (rows[0]?.id) return rows[0].id;
   168:             } else {
   169:                 const { rows } = await this.pg.query<{ id: string }>(
   170:                     `SELECT id
   171:                      FROM public.roles
   172:                      WHERE LOWER(name) = LOWER($2)
   173:                        AND ((scope = 'organization' AND organization_id = $1) OR scope = 'system')
   174:                      ORDER BY scope DESC
   175:                      LIMIT 1`,
   176:                     [orgId, trimmed],
   177:                 );
   178:                 if (rows[0]?.id) return rows[0].id;
   179:             }
   180:         }
   181: 
   182:         // Attempt to fall back to a sensible default ("User" etc.)
   183:         for (const candidate of DEFAULT_ROLE_CANDIDATES) {
   184:             const { rows } = await this.pg.query<{ id: string }>(
   185:                 `SELECT id
   186:                  FROM public.roles
   187:                  WHERE LOWER(name) = $2
   188:                    AND ((scope = 'organization' AND organization_id = $1) OR scope = 'system')
   189:                  ORDER BY scope DESC
   190:                  LIMIT 1`,
   191:                 [orgId, candidate],
   192:             );
   193:             if (rows[0]?.id) return rows[0].id;
   194:         }
   195: 
   196:         return null;
   197:     }
   198: 
   199:     private buildSearchClause(params: any[], value?: string | null): string | null {
   200:         const term = value?.trim();
   201:         if (!term) return null;
   202:         params.push(`%${term.toLowerCase()}%`);
   203:         const idx = params.length;
   204:         return `(
   205:             LOWER(u.email) LIKE $${idx}
   206:             OR LOWER(COALESCE(u.first_name, '') || ' ' || COALESCE(u.last_name, '')) LIKE $${idx}
   207:         )`;
   208:     }
   209: 
   210:     async list(q: ListUsersQuery): Promise<{ items: UserRow[]; total: number }> {
   211:         const orgId = await this.orgs.getDefaultOrganizationId();
   212:         const params: any[] = [orgId];
   213:         const where: string[] = [`u.organization_id = $1`];
   214: 
   215:         const search = this.buildSearchClause(params, q.q);
   216:         if (search) where.push(search);
   217: 
   218:         if (q.status && q.status !== "all") {
   219:             params.push(q.status);
   220:             where.push(`u.status = $${params.length}`);
   221:         }
   222: 
   223:         if (q.role && q.role !== "all") {
   224:             params.push(q.role);
   225:             const idx = params.length;
   226:             const clause = isUuid(q.role)
   227:                 ? `EXISTS (
   228:                         SELECT 1
   229:                         FROM public.user_roles urf
   230:                         WHERE urf.user_id = u.id AND urf.role_id = $${idx}
   231:                     )`
   232:                 : `EXISTS (
   233:                         SELECT 1
   234:                         FROM public.user_roles urf
   235:                         JOIN public.roles rf ON rf.id = urf.role_id
   236:                         WHERE urf.user_id = u.id AND LOWER(rf.name) = LOWER($${idx})
   237:                     )`;
   238:             where.push(clause);
   239:         }
   240: 
   241:         const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";
   242: 
   243:         const countSql = `SELECT COUNT(*)::int AS c FROM public.users u ${whereSql}`;
   244:         const { rows: countRows } = await this.pg.query<{ c: number }>(countSql, params);
   245:         const total = countRows[0]?.c ?? 0;
   246: 
   247:         const sortKeyMap: Record<string, string> = {
   248:             name: "display_name",
   249:             email: "LOWER(u.email)",
   250:             role: "LOWER(COALESCE(pr.name, ''))",
   251:             lastSeen: "u.last_seen_at",
   252:         };
   253:         const sortKey = sortKeyMap[q.sortKey ?? "name"] || sortKeyMap.name;
   254:         const sortDir = q.sortDir?.toUpperCase() === "DESC" ? "DESC" : "ASC";
   255: 
   256:         const page = Math.max(1, q.page ?? 1);
   257:         const pageSize = Math.max(1, q.pageSize ?? 25);
   258:         const offset = (page - 1) * pageSize;
   259: 
   260:         const dataSql = `
   261:             SELECT
   262:                 u.id,
   263:                 u.email,
   264:                 u.first_name,
   265:                 u.last_name,
   266:                 u.status,
   267:                 u.last_seen_at,
   268:                 u.created_at,
   269:                 u.updated_at,
   270:                 COALESCE(us.two_factor_enabled, false) AS two_factor_enabled,
   271:                 pr.id AS primary_role_id,
   272:                 pr.name AS primary_role_name,
   273:                 COALESCE(
   274:                     jsonb_agg(DISTINCT jsonb_build_object('id', r.id, 'name', r.name))
   275:                     FILTER (WHERE r.id IS NOT NULL),
   276:                     '[]'::jsonb
   277:                 ) AS roles,
   278:                 COALESCE(NULLIF(CONCAT_WS(' ', NULLIF(u.first_name, ''), NULLIF(u.last_name, '')), ''), u.email) AS display_name
   279:             FROM public.users u
   280:             LEFT JOIN public.user_security us ON us.user_id = u.id
   281:             LEFT JOIN public.user_roles ur ON ur.user_id = u.id
   282:             LEFT JOIN public.roles r ON r.id = ur.role_id
   283:             LEFT JOIN LATERAL (
   284:                 SELECT r2.id, r2.name
   285:                 FROM public.user_roles ur2
   286:                 JOIN public.roles r2 ON r2.id = ur2.role_id
   287:                 WHERE ur2.user_id = u.id
   288:                 ORDER BY r2.scope DESC, LOWER(r2.name) ASC
   289:                 LIMIT 1
   290:             ) pr ON TRUE
   291:             ${whereSql}
   292:             GROUP BY u.id, us.two_factor_enabled, pr.id, pr.name
   293:             ORDER BY ${sortKey} ${sortDir}, display_name ASC
   294:             LIMIT $${params.length + 1}
   295:             OFFSET $${params.length + 2}
   296:         `;
   297: 
   298:         const { rows } = await this.pg.query<DbUserRow>(dataSql, [...params, pageSize, offset]);
   299:         return {
   300:             items: rows.map((row) => this.mapUserRow(row)),
   301:             total,
   302:         };
   303:     }
   304: 
   305:     async roles(): Promise<{ id: string; name: string }[]> {
   306:         const orgId = await this.orgs.getDefaultOrganizationId();
   307:         const { rows } = await this.pg.query(
   308:             `SELECT id, name
   309:              FROM public.roles
   310:              WHERE scope = 'system' OR organization_id = $1
   311:              ORDER BY scope DESC, LOWER(name) ASC`,
   312:             [orgId],
   313:         );
   314:         return rows.map((r: any) => ({ id: r.id, name: r.name }));
   315:     }
   316: 
   317:     async inviteOne(dto: InviteUserDto): Promise<{ id: string }> {
   318:         const orgId = await this.orgs.getDefaultOrganizationId();
   319:         const email = dto.email.toLowerCase().trim();
   320:         const fallbackName = email.split("@")[0];
   321:         const displayName = coalesceString(dto.name) || fallbackName;
   322:         const { first, last } = splitDisplayName(displayName);
   323:         const passwordHash = await bcrypt.hash(randomUUID(), SALT_ROUNDS);
   324:         const roleId = await this.resolveRoleId(orgId, dto.role);
   325: 
   326:         const { rows } = await this.pg.query<{ id: string }>(
   327:             `INSERT INTO public.users (organization_id, email, password_hash, first_name, last_name, status)
   328:              VALUES ($1, $2, $3, $4, $5, 'invited')
   329:              ON CONFLICT (organization_id, email) DO UPDATE
   330:                SET first_name = EXCLUDED.first_name,
   331:                    last_name = EXCLUDED.last_name,
   332:                    status = 'invited'
   333:              RETURNING id`,
   334:             [orgId, email, passwordHash, first, last],
   335:         );
   336: 
   337:         const id = rows[0]?.id;
   338:         if (!id) return { id: "" };
   339: 
   340:         await this.ensureUserSecurityRow(id);
   341:         if (roleId) await this.replaceUserRoles(id, [roleId]);
   342: 
   343:         return { id };
   344:     }
   345: 
   346:     async inviteBulk(dto: BulkInviteDto): Promise<{ created: number }> {
   347:         let created = 0;
   348:         for (const inv of dto.invites || []) {
   349:             const res = await this.inviteOne(inv);
   350:             if (res.id) created++;
   351:         }
   352:         return { created };
   353:     }
   354: 
   355:     async updateRole(id: string, dto: UpdateRoleDto): Promise<void> {
   356:         const user = await this.ensureUserExists(id);
   357:         const roleId = await this.resolveRoleId(user.organization_id, dto.role);
   358:         if (!roleId) {
   359:             await this.replaceUserRoles(id, []);
   360:             return;
   361:         }
   362:         await this.replaceUserRoles(id, [roleId]);
   363:     }
   364: 
   365:     async setSuspended(id: string, suspended: boolean): Promise<void> {
   366:         await this.ensureUserExists(id);
   367:         const status = suspended ? "suspended" : "active";
   368:         const { rowCount } = await this.pg.query(
   369:             `UPDATE public.users
   370:              SET status = $2,
   371:                  updated_at = NOW()
   372:              WHERE id = $1`,
   373:             [id, status],
   374:         );
   375:         if (rowCount === 0) throw new NotFoundException("User not found");
   376:     }
   377: 
   378:     async reset2fa(id: string): Promise<void> {
   379:         await this.ensureUserExists(id);
   380:         const { rowCount } = await this.pg.query(
   381:             `INSERT INTO public.user_security (user_id, two_factor_enabled, totp_secret, recovery_codes)
   382:              VALUES ($1, false, NULL, '{}'::text[])
   383:              ON CONFLICT (user_id) DO UPDATE
   384:                SET two_factor_enabled = false,
   385:                    totp_secret = NULL,
   386:                    recovery_codes = '{}'::text[]`,
   387:             [id],
   388:         );
   389:         if (rowCount === 0) throw new NotFoundException("User not found");
   390:     }
   391: 
   392:     async remove(id: string): Promise<void> {
   393:         const { rowCount } = await this.pg.query(`DELETE FROM public.users WHERE id = $1`, [id]);
   394:         if (rowCount === 0) throw new NotFoundException("User not found");
   395:     }
   396: 
   397:     async createOne(dto: CreateUserDto): Promise<{ id: string }> {
   398:         const orgId = await this.orgs.getDefaultOrganizationId();
   399:         const email = dto.email.toLowerCase().trim();
   400:         const status = dto.status ?? "active";
   401:         if (!["active", "invited", "suspended"].includes(status)) {
   402:             throw new BadRequestException("Invalid status");
   403:         }
   404: 
   405:         const displayName = coalesceString(dto.name) || email.split("@")[0];
   406:         const { first, last } = splitDisplayName(displayName);
   407:         const passwordHash = await bcrypt.hash(dto.password, SALT_ROUNDS);
   408:         const roleId = await this.resolveRoleId(orgId, dto.role);
   409: 
   410:         const { rows } = await this.pg.query<{ id: string }>(
   411:             `INSERT INTO public.users (organization_id, email, password_hash, first_name, last_name, status)
   412:              VALUES ($1, $2, $3, $4, $5, $6)
   413:              ON CONFLICT (organization_id, email) DO UPDATE
   414:                SET first_name = EXCLUDED.first_name,
   415:                    last_name = EXCLUDED.last_name,
   416:                    status = EXCLUDED.status,
   417:                    password_hash = EXCLUDED.password_hash,
   418:                    updated_at = NOW()
   419:              RETURNING id`,
   420:             [orgId, email, passwordHash, first, last, status],
   421:         );
   422: 
   423:         const id = rows[0]?.id;
   424:         if (!id) {
   425:             throw new ConflictException("Unable to create user");
   426:         }
   427: 
   428:         await this.ensureUserSecurityRow(id);
   429:         await this.pg.query(
   430:             `UPDATE public.user_security
   431:              SET password_changed_at = NOW()
   432:              WHERE user_id = $1`,
   433:             [id],
   434:         );
   435: 
   436:         if (roleId) await this.replaceUserRoles(id, [roleId]);
   437: 
   438:         return { id };
   439:     }
   440: 
   441:     async setPassword(id: string, body: ResetPasswordDto): Promise<void> {
   442:         await this.ensureUserExists(id);
   443:         const hash = await bcrypt.hash(body.password, SALT_ROUNDS);
   444:         const { rowCount } = await this.pg.query(
   445:             `UPDATE public.users
   446:              SET password_hash = $2,
   447:                  updated_at = NOW()
   448:              WHERE id = $1`,
   449:             [id, hash],
   450:         );
   451:         if (rowCount === 0) throw new NotFoundException("User not found");
   452: 
   453:         await this.pg.query(
   454:             `INSERT INTO public.user_security (user_id, password_changed_at)
   455:              VALUES ($1, NOW())
   456:              ON CONFLICT (user_id) DO UPDATE
   457:                SET password_changed_at = EXCLUDED.password_changed_at`,
   458:             [id],
   459:         );
   460:     }
   461: 
   462:     private async getUserColumns(): Promise<Set<string>> {
   463:         const { rows } = await this.pg.query(
   464:             `SELECT column_name
   465:              FROM information_schema.columns
   466:              WHERE table_schema = 'public' AND table_name = 'users'`,
   467:         );
   468:         return new Set(rows.map((r: any) => r.column_name));
   469:     }
   470: 
   471:     async updateUser(id: string, dto: UpdateUserDto): Promise<void> {
   472:         await this.ensureUserExists(id);
   473:         const cols = await this.getUserColumns();
   474:         const params: any[] = [id];
   475:         const sets: string[] = [];
   476: 
   477:         if (dto.role !== undefined) {
   478:             await this.updateRole(id, { role: dto.role });
   479:         }
   480: 
   481:         if (dto.name !== undefined) {
   482:             const { first, last } = splitDisplayName(dto.name);
   483:             if (cols.has("first_name")) {
   484:                 params.push(first);
   485:                 sets.push(`first_name = $${params.length}`);
   486:             }
   487:             if (cols.has("last_name")) {
   488:                 params.push(last);
   489:                 sets.push(`last_name = $${params.length}`);
   490:             }
   491:         }
   492: 
   493:         if (dto.email !== undefined) {
   494:             params.push(dto.email.trim().toLowerCase());
   495:             sets.push(`email = $${params.length}`);
   496:         }
   497: 
   498:         const optionalMap: Record<string, string> = {
   499:             phone: "phone",
   500:             address1: "address1",
   501:             address2: "address2",
   502:             city: "city",
   503:             state: "state",
   504:             postal: "postal",
   505:             country: "country",
   506:             avatarUrl: "avatar_url",
   507:             avatarThumbUrl: "avatar_thumb_url",
   508:         };
   509: 
   510:         for (const [key, column] of Object.entries(optionalMap)) {
   511:             const value = (dto as any)[key];
   512:             if (value !== undefined && cols.has(column)) {
   513:                 params.push(value);
   514:                 sets.push(`${column} = $${params.length}`);
   515:             }
   516:         }
   517: 
   518:         if (sets.length === 0) {
   519:             return;
   520:         }
   521: 
   522:         params.push(new Date());
   523:         sets.push(`updated_at = $${params.length}`);
   524: 
   525:         const sql = `
   526:             UPDATE public.users
   527:             SET ${sets.join(", ")}
   528:             WHERE id = $1
   529:             RETURNING id
   530:         `;
   531:         const { rows } = await this.pg.query(sql, params);
   532:         if (!rows[0]) throw new NotFoundException("User not found");
   533:     }
   534: }
-----  END  CONTENT -----

## FILE: src/users/users.dto.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\users\users.dto.ts
Size: 5248 bytes
SHA256: 2A7D419050C599CCA63AF7EA384EBFDE6598F3D6E3FDA3D9A86BE412B72F2463
----- BEGIN CONTENT -----
     1: // backend/src/users/users.dto.ts
     2: import {
     3:     IsBoolean,
     4:     IsEmail,
     5:     IsIn,
     6:     IsInt,
     7:     IsOptional,
     8:     IsString,
     9:     IsUUID,
    10:     Min,
    11:     MinLength,
    12: } from "class-validator";
    13: import { Type } from "class-transformer";
    14: 
    15: export type UserRoleSummary = { id: string; name: string };
    16: 
    17: export type UserRow = {
    18:     id: string;
    19:     name: string;
    20:     email: string;
    21:     role: string;
    22:     roleId?: string | null;
    23:     roles?: UserRoleSummary[];
    24:     status: "active" | "suspended" | "invited";
    25:     twoFactorEnabled: boolean;
    26:     suspended?: boolean;
    27:     lastSeen: string | null;
    28:     createdAt: string;
    29:     updatedAt: string;
    30: 
    31:     // Optional profile fields if present in DB (we don't require them)
    32:     phone?: string | null;
    33:     address1?: string | null;
    34:     address2?: string | null;
    35:     city?: string | null;
    36:     state?: string | null;
    37:     postal?: string | null;
    38:     country?: string | null;
    39: 
    40:     // Avatars (nullable; map from avatar_url / avatar_thumb_url)
    41:     avatarUrl?: string | null;
    42:     avatarThumbUrl?: string | null;
    43: };
    44: 
    45: export class ListUsersQuery {
    46:     @IsOptional() @IsString() q?: string;
    47:     @IsOptional() @IsString() role?: string;
    48: 
    49:     @IsOptional() @IsIn(["all", "active", "suspended", "invited"])
    50:     status: "all" | "active" | "suspended" | "invited" = "all";
    51: 
    52:     @IsOptional() @IsIn(["name", "email", "role", "lastSeen"])
    53:     sortKey: "name" | "email" | "role" | "lastSeen" = "name";
    54: 
    55:     @IsOptional() @IsIn(["asc", "desc"])
    56:     sortDir: "asc" | "desc" = "asc";
    57: 
    58:     @IsOptional() @Type(() => Number) @IsInt() @Min(1)
    59:     page: number = 1;
    60: 
    61:     @IsOptional() @Type(() => Number) @IsInt() @Min(1)
    62:     pageSize: number = 25;
    63: }
    64: 
    65: export class InviteUserDto {
    66:     @IsOptional() @IsString() name?: string;
    67:     @IsEmail() email!: string;
    68:     @IsOptional() @IsString() role?: string;
    69:     @IsOptional() @IsString() message?: string;
    70: }
    71: 
    72: export class BulkInviteDto {
    73:     invites!: InviteUserDto[];
    74: }
    75: 
    76: export class UpdateRoleDto {
    77:     @IsString() role!: string;
    78: }
    79: 
    80: export class IdParam {
    81:     @IsUUID() id!: string;
    82: }
    83: 
    84: export class SuspendDto {
    85:     @IsBoolean() suspended!: boolean;
    86: }
    87: 
    88: /* -------- Admin create + reset password -------- */
    89: export class CreateUserDto {
    90:     @IsString() @MinLength(1) name!: string;
    91:     @IsEmail() email!: string;
    92:     @IsOptional() @IsString() role?: string; // default "User"
    93:     @IsString() @MinLength(8) password!: string;
    94:     @IsOptional() @IsIn(["active", "invited", "suspended"])
    95:     status?: "active" | "invited" | "suspended"; // default "active"
    96: }
    97: 
    98: export class ResetPasswordDto {
    99:     @IsString() @MinLength(8) password!: string;
   100: }
   101: 
   102: /* -------- Update user details (only updates provided fields) -------- */
   103: export class UpdateUserDto {
   104:     @IsOptional() @IsString() name?: string;
   105:     @IsOptional() @IsEmail() email?: string;
   106:     @IsOptional() @IsString() role?: string;
   107: 
   108:     // Optional profile fields — updated only if present in DB
   109:     @IsOptional() @IsString() phone?: string;
   110:     @IsOptional() @IsString() address1?: string;
   111:     @IsOptional() @IsString() address2?: string;
   112:     @IsOptional() @IsString() city?: string;
   113:     @IsOptional() @IsString() state?: string;
   114:     @IsOptional() @IsString() postal?: string;
   115:     @IsOptional() @IsString() country?: string;
   116: 
   117:     // If you decide to allow admin to set avatars here, keep these optional.
   118:     @IsOptional() @IsString() avatarUrl?: string | null;
   119:     @IsOptional() @IsString() avatarThumbUrl?: string | null;
   120: }
   121: 
   122: /* ============================
   123:    SELF PROFILE (current user)
   124:    ============================ */
   125: 
   126: export class MeProfileDto {
   127:     id!: string;
   128:     name!: string;
   129:     email!: string;
   130: 
   131:     @IsOptional() @IsString() phone?: string | null;
   132:     @IsOptional() @IsString() timezone?: string | null;
   133:     @IsOptional() @IsString() locale?: string | null;
   134: 
   135:     // Full-size avatar URL
   136:     @IsOptional() @IsString() avatarUrl?: string | null;
   137: 
   138:     // Optional thumbnail URL if you generate/store one
   139:     @IsOptional() @IsString() avatarThumbUrl?: string | null;
   140: 
   141:     // Address fields (kept optional for back-compat)
   142:     @IsOptional() @IsString() address1?: string | null;
   143:     @IsOptional() @IsString() address2?: string | null;
   144:     @IsOptional() @IsString() city?: string | null;
   145:     @IsOptional() @IsString() state?: string | null;
   146:     @IsOptional() @IsString() postal?: string | null;
   147:     @IsOptional() @IsString() country?: string | null;
   148: }
   149: 
   150: export class UpdateMeDto {
   151:     @IsOptional() @IsString() name?: string;
   152:     @IsOptional() @IsEmail() email?: string;
   153:     @IsOptional() @IsString() phone?: string | null;
   154:     @IsOptional() @IsString() timezone?: string | null;
   155:     @IsOptional() @IsString() locale?: string | null;
   156: 
   157:     @IsOptional() @IsString() avatarUrl?: string | null;
   158:     @IsOptional() @IsString() avatarThumbUrl?: string | null;
   159: 
   160:     @IsOptional() @IsString() address1?: string | null;
   161:     @IsOptional() @IsString() address2?: string | null;
   162:     @IsOptional() @IsString() city?: string | null;
   163:     @IsOptional() @IsString() state?: string | null;
   164:     @IsOptional() @IsString() postal?: string | null;
   165:     @IsOptional() @IsString() country?: string | null;
   166: }
-----  END  CONTENT -----

## FILE: src/roles/roles.module.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\roles\roles.module.ts
Size: 661 bytes
SHA256: 00D42C7055976C37013C0C37BE14683F207FA31DC1BD5DAABB2111995891448D
----- BEGIN CONTENT -----
     1: import { Module } from '@nestjs/common';
     2: import { StorageModule } from '../storage/storage.module';
     3: import { RolesService } from './roles.service';
     4: import { RolesController } from './roles.controller';
     5: import { PermissionsIntrospectService } from './permissions-introspect.service';
     6: import { RolesPermissionsController } from './permissions.controller';
     7: import { PermissionsGuard } from '../auth/permissions.guard';
     8: 
     9: @Module({
    10:     imports: [StorageModule],
    11:     providers: [RolesService, PermissionsIntrospectService, PermissionsGuard],
    12:     controllers: [RolesController, RolesPermissionsController],
    13:     exports: [RolesService],
    14: })
    15: export class RolesModule { }
-----  END  CONTENT -----

## FILE: src/roles/roles.controller.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\roles\roles.controller.ts
Size: 1206 bytes
SHA256: E6F5EEC16D8F30FDABA4FC743BF7D834CDACB994C8393E98CFF9958231A4C2F8
----- BEGIN CONTENT -----
     1: import {
     2:     Body,
     3:     Controller,
     4:     Delete,
     5:     Get,
     6:     Param,
     7:     ParseUUIDPipe,
     8:     Patch,
     9:     Post,
    10:     UseGuards,
    11: } from '@nestjs/common';
    12: import { RolesService } from './roles.service';
    13: import { CreateRoleDto, UpdateRoleDto } from './dto';
    14: import { PermissionsGuard } from '../auth/permissions.guard';
    15: import { RequirePerm } from '../auth/require-perm.decorator';
    16: 
    17: @UseGuards(PermissionsGuard)
    18: @Controller('api/roles')
    19: export class RolesController {
    20:     constructor(private readonly svc: RolesService) { }
    21: 
    22:     @Get()
    23:     @RequirePerm('roles.read')
    24:     list() {
    25:         return this.svc.list();
    26:     }
    27: 
    28:     @Post()
    29:     @RequirePerm('roles.write')
    30:     create(@Body() body: CreateRoleDto) {
    31:         return this.svc.create(body);
    32:     }
    33: 
    34:     @Patch(':id')
    35:     @RequirePerm('roles.write')
    36:     async update(
    37:         @Param('id', new ParseUUIDPipe({ version: '4' })) id: string,
    38:         @Body() body: UpdateRoleDto,
    39:     ) {
    40:         await this.svc.update(id, body);
    41:         return { ok: true };
    42:     }
    43: 
    44:     @Delete(':id')
    45:     @RequirePerm('roles.delete')
    46:     async remove(@Param('id', new ParseUUIDPipe({ version: '4' })) id: string) {
    47:         await this.svc.remove(id);
    48:         return { ok: true };
    49:     }
    50: }
-----  END  CONTENT -----

## FILE: src/roles/roles.service.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\roles\roles.service.ts
Size: 8597 bytes
SHA256: 91F327A4FACECE291187DAA523FB1736F62A17110AC52D760A8FE19D8CB37485
----- BEGIN CONTENT -----
     1: import {
     2:     Injectable,
     3:     BadRequestException,
     4:     NotFoundException,
     5:     ConflictException,
     6: } from '@nestjs/common';
     7: import { PgPoolService } from '../storage/pg-pool.service';
     8: import { OrganizationContextService } from '../storage/organization-context.service';
     9: import { ALL_PERMISSIONS, Permission } from '../auth/policy';
    10: 
    11: export type RoleDto = {
    12:     id: string;
    13:     name: string;
    14:     description?: string;
    15:     permissions: string[];
    16:     usersCount: number;
    17:     createdAt: string;
    18:     updatedAt: string;
    19: };
    20: 
    21: export type CreateRoleDto = {
    22:     name: string;
    23:     description?: string;
    24:     permissions?: string[];
    25: };
    26: 
    27: export type UpdateRoleDto = Partial<{
    28:     name: string;
    29:     description: string | null;
    30:     permissions: string[]; // full replace
    31: }>;
    32: 
    33: const PROTECTED_NAMES = new Set(['owner', 'admin']);
    34: const FULL_LOCK_NAME = 'owner';
    35: const VALID_PERMISSIONS = new Set<Permission>(ALL_PERMISSIONS);
    36: 
    37: type RoleRecord = {
    38:     id: string;
    39:     name: string;
    40:     scope: 'system' | 'organization';
    41:     organization_id: string | null;
    42:     description: string | null;
    43: };
    44: 
    45: function isUuid(v: string) {
    46:     return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);
    47: }
    48: 
    49: function normalizePermissions(perms?: string[]): Permission[] {
    50:     if (!perms || !perms.length) return [];
    51:     const invalid: string[] = [];
    52:     const out = new Set<Permission>();
    53: 
    54:     for (const raw of perms) {
    55:         if (!raw) continue;
    56:         const key = raw.trim().toLowerCase() as Permission;
    57:         if (!VALID_PERMISSIONS.has(key)) {
    58:             invalid.push(raw);
    59:             continue;
    60:         }
    61:         out.add(key);
    62:     }
    63: 
    64:     if (invalid.length) {
    65:         throw new BadRequestException(`Unknown permission(s): ${invalid.join(', ')}`);
    66:     }
    67: 
    68:     return Array.from(out);
    69: }
    70: 
    71: @Injectable()
    72: export class RolesService {
    73:     constructor(
    74:         private readonly db: PgPoolService,
    75:         private readonly orgs: OrganizationContextService,
    76:     ) { }
    77: 
    78:     async list(): Promise<RoleDto[]> {
    79:         const orgId = await this.orgs.getDefaultOrganizationId();
    80:         const sql = `
    81:       SELECT
    82:         r.id,
    83:         r.name,
    84:         COALESCE(r.description, '') AS description,
    85:         COALESCE(array_agg(DISTINCT rp.permission_key)
    86:                  FILTER (WHERE rp.permission_key IS NOT NULL),
    87:                  '{}'::text[]) AS permissions,
    88:         (
    89:           SELECT COUNT(*)::int
    90:           FROM public.user_roles ur
    91:           WHERE ur.role_id = r.id
    92:         ) AS "usersCount",
    93:         r.created_at AS "createdAt",
    94:         r.updated_at AS "updatedAt"
    95:       FROM public.roles r
    96:       LEFT JOIN public.role_permissions rp
    97:         ON rp.role_id = r.id
    98:       WHERE
    99:         (r.scope = 'system')
   100:         OR (r.organization_id = $1)
   101:       GROUP BY r.id
   102:       ORDER BY lower(r.name) ASC;
   103:     `;
   104:         const { rows } = await this.db.query(sql, [orgId]);
   105:         return rows.map((r: any) => ({
   106:             id: r.id,
   107:             name: r.name,
   108:             description: r.description ?? undefined,
   109:             permissions: Array.isArray(r.permissions) ? r.permissions : [],
   110:             usersCount: Number(r.usersCount ?? 0),
   111:             createdAt: r.createdAt,
   112:             updatedAt: r.updatedAt,
   113:         }));
   114:     }
   115: 
   116:     async create(payload: CreateRoleDto): Promise<{ id: string }> {
   117:         const name = (payload.name ?? '').trim();
   118:         if (name.length < 2 || name.length > 64) {
   119:             throw new BadRequestException('Name must be 2–64 characters.');
   120:         }
   121: 
   122:         const orgId = await this.orgs.getDefaultOrganizationId();
   123:         const exists = await this.db.query(
   124:             `SELECT 1
   125:          FROM public.roles
   126:         WHERE lower(name) = lower($2)
   127:           AND ((scope = 'organization' AND organization_id = $1) OR scope = 'system')
   128:         LIMIT 1;`,
   129:             [orgId, name],
   130:         );
   131:         if ((exists.rows?.length ?? 0) > 0) {
   132:             throw new ConflictException('Role name must be unique (case-insensitive).');
   133:         }
   134: 
   135:         const desc = payload.description?.trim() || null;
   136:         const perms = normalizePermissions(payload.permissions);
   137: 
   138:         const insRole = await this.db.query(
   139:             `INSERT INTO public.roles (organization_id, scope, name, description)
   140:              VALUES ($1, 'organization', $2, $3)
   141:              RETURNING id;`,
   142:             [orgId, name, desc],
   143:         );
   144:         const id = insRole.rows[0].id as string;
   145: 
   146:         await this.replaceRolePermissions(id, perms);
   147: 
   148:         return { id };
   149:     }
   150: 
   151:     async getById(id: string): Promise<{ id: string; name: string }> {
   152:         if (!isUuid(id)) throw new BadRequestException('Invalid role id.');
   153:         const role = await this.fetchRoleById(id);
   154:         return { id: role.id, name: role.name };
   155:     }
   156: 
   157:     async update(id: string, patch: UpdateRoleDto): Promise<void> {
   158:         const { name: newNameRaw, description, permissions } = patch;
   159:         const role = await this.fetchRoleById(id);
   160: 
   161:         const oldLower = role.name.trim().toLowerCase();
   162:         const normalizedPerms = permissions === undefined ? null : normalizePermissions(permissions ?? []);
   163: 
   164:         if (newNameRaw !== undefined) {
   165:             const newName = newNameRaw.trim();
   166:             if (newName.length < 2 || newName.length > 64) {
   167:                 throw new BadRequestException('Name must be 2–64 characters.');
   168:             }
   169:             if (role.scope === 'system' || oldLower === FULL_LOCK_NAME) {
   170:                 throw new BadRequestException('The "Owner" role cannot be renamed.');
   171:             }
   172:             if (newName.toLowerCase() !== oldLower) {
   173:                 const exists = await this.db.query(
   174:                     `SELECT 1
   175:              FROM public.roles
   176:             WHERE id <> $1
   177:               AND lower(name)=lower($2)
   178:               AND ((scope='organization' AND organization_id = $3) OR scope='system')
   179:             LIMIT 1;`,
   180:                     [id, newName, role.organization_id],
   181:                 );
   182:                 if ((exists.rows?.length ?? 0) > 0) {
   183:                     throw new ConflictException('Role name must be unique (case-insensitive).');
   184:                 }
   185: 
   186:                 await this.db.query(`UPDATE public.roles SET name=$1 WHERE id=$2;`, [newName, id]);
   187:                 role.name = newName;
   188:             }
   189:         }
   190: 
   191:         if (description !== undefined) {
   192:             await this.db.query(
   193:                 `UPDATE public.roles SET description = $1 WHERE id = $2`,
   194:                 [description ?? null, id],
   195:             );
   196:         }
   197: 
   198:         if (normalizedPerms !== null) {
   199:             await this.replaceRolePermissions(id, normalizedPerms);
   200:         }
   201:     }
   202: 
   203:     // Fixed: implement remove(...) and remove the stray duplicate method signature.
   204:     async remove(roleId: string): Promise<void> {
   205:         if (!isUuid(roleId)) throw new BadRequestException('Invalid role id.');
   206: 
   207:         const role = await this.fetchRoleById(roleId);
   208:         const lower = role.name.trim().toLowerCase();
   209:         if (role.scope === 'system' || PROTECTED_NAMES.has(lower)) {
   210:             throw new BadRequestException('This role is protected and cannot be deleted.');
   211:         }
   212: 
   213:         const assigned = await this.db.query(
   214:             `SELECT 1 FROM public.user_roles WHERE role_id = $1 LIMIT 1;`,
   215:             [roleId],
   216:         );
   217:         if (assigned.rows.length > 0) {
   218:             throw new BadRequestException('Cannot delete a role that still has users assigned.');
   219:         }
   220: 
   221:         await this.db.query(`DELETE FROM public.roles WHERE id=$1;`, [roleId]);
   222:     }
   223: 
   224:     private async replaceRolePermissions(roleId: string, permissions: Permission[]): Promise<void> {
   225:         await this.db.query(`DELETE FROM public.role_permissions WHERE role_id=$1;`, [roleId]);
   226:         if (!permissions.length) return;
   227:         await this.db.query(
   228:             `INSERT INTO public.role_permissions (role_id, permission_key)
   229:              SELECT $1, perm
   230:              FROM unnest($2::text[]) AS perm`,
   231:             [roleId, permissions],
   232:         );
   233:     }
   234: 
   235:     private async fetchRoleById(id: string): Promise<RoleRecord> {
   236:         const { rows } = await this.db.query<RoleRecord>(
   237:             `SELECT id, name, scope, organization_id, description
   238:              FROM public.roles
   239:              WHERE id = $1
   240:              LIMIT 1`,
   241:             [id],
   242:         );
   243:         if (!rows.length) throw new NotFoundException('Role not found.');
   244:         return rows[0];
   245:     }
   246: }
-----  END  CONTENT -----

## FILE: src/roles/roles.dto.ts

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\roles\roles.dto.ts
Size: 601 bytes
SHA256: 875F370E9BEEDF7BCD383BBAA20B4EADBDA67210FEC21316D338FCFECE25EA9D
----- BEGIN CONTENT -----
     1: import { IsArray, IsOptional, IsString, Length, ArrayNotEmpty } from 'class-validator';
     2: 
     3: export class CreateRoleDto {
     4:     @IsString()
     5:     @Length(2, 64)
     6:     name!: string;
     7: 
     8:     @IsOptional()
     9:     @IsString()
    10:     description?: string;
    11: 
    12:     @IsArray()
    13:     @IsString({ each: true })
    14:     permissions: string[] = [];
    15: }
    16: 
    17: export class UpdateRoleDto {
    18:     @IsOptional()
    19:     @IsString()
    20:     @Length(2, 64)
    21:     name?: string;
    22: 
    23:     @IsOptional()
    24:     @IsString()
    25:     description?: string;
    26: 
    27:     @IsOptional()
    28:     @IsArray()
    29:     @IsString({ each: true })
    30:     permissions?: string[];
    31: }
-----  END  CONTENT -----


##############################################################################

# Project metadata (.env, package.json…)
## FILE: .env

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\.env
Size: 7138 bytes
SHA256: 249068F824BC55D757E346DD32ED53ACF26231497860A897196FEB150BECDF24
----- BEGIN CONTENT -----
     1: # ──────────────────────────────────────────────────────────────────────────────
     2: # Runtime / Server
     3: # ──────────────────────────────────────────────────────────────────────────────
     4: NODE_ENV=development
     5: PORT=3001
     6: # SECURE_COOKIES=true
     7: 
     8: # ──────────────────────────────────────────────────────────────────────────────
     9: # CORS / Frontend Origins
    10: # ──────────────────────────────────────────────────────────────────────────────
    11: FRONTEND_ORIGINS=http://localhost:3000
    12: ALLOWED_ORIGIN=http://localhost:3000
    13: 
    14: # ──────────────────────────────────────────────────────────────────────────────
    15: # Public URLs (static files, websocket, API base for the frontend)
    16: # ──────────────────────────────────────────────────────────────────────────────
    17: NEXT_PUBLIC_API_BASE=http://localhost:3001
    18: NEXT_PUBLIC_WS_BASE=ws://localhost:3001/ws
    19: PUBLIC_BASE_URL=http://localhost:3001/static
    20: 
    21: # ──────────────────────────────────────────────────────────────────────────────
    22: # Auth (JWT + cookie)
    23: # ──────────────────────────────────────────────────────────────────────────────
    24: AUTH_COOKIE_NAME=auth_token
    25: JWT_SECRET=NDLAxKYPkkGjiQkMMx0vYo0s9jnwj1/8ib0diln79qkZ13+G913C3IWXcwDRmc2Uiy+KBgIblmlfnmpJ4TUfXg==
    26: JWT_EXPIRES=7d
    27: ADMIN_API_KEY=LS@dm1n!
    28: 
    29: # ──────────────────────────────────────────────────────────────────────────────
    30: # Enrollment / Agents
    31: # ──────────────────────────────────────────────────────────────────────────────
    32: ENROLLMENT_SECRET=N0x1sbo55!
    33: 
    34: # ──────────────────────────────────────────────────────────────────────────────
    35: # Database (PostgreSQL)
    36: # ──────────────────────────────────────────────────────────────────────────────
    37: DATABASE_URL=postgres://remoteiq:remoteiqpass@localhost:5432/remoteiq
    38: # DATABASE_SSL=false
    39: # DATABASE_POOL_MAX=10
    40: # DATABASE_POOL_MIN=0
    41: 
    42: # ──────────────────────────────────────────────────────────────────────────────
    43: # Uploads / Avatar
    44: # ──────────────────────────────────────────────────────────────────────────────
    45: AVATAR_MAX_MB=5
    46: 
    47: # ──────────────────────────────────────────────────────────────────────────────
    48: # SMTP (outbound mail) -- existing app-wide mail settings
    49: # ──────────────────────────────────────────────────────────────────────────────
    50: SMTP_RATE_TOKENS=5
    51: SMTP_RATE_REFILL=1
    52: SMTP_POOL=true
    53: SMTP_POOL_MAX_CONN=2
    54: SMTP_POOL_MAX_MSG=50
    55: SMTP_TEST_DOMAIN=
    56: 
    57: # ──────────────────────────────────────────────────────────────────────────────
    58: # DKIM (optional; signs outgoing mail if set)
    59: # ──────────────────────────────────────────────────────────────────────────────
    60: DKIM_DOMAIN=remoteiqrmm.com
    61: DKIM_KEY_SELECTOR=default
    62: DKIM_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----
    63: MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBK...
    64: -----END PRIVATE KEY-----"
    65: 
    66: # ──────────────────────────────────────────────────────────────────────────────
    67: # IMAP Poller (optional intake)
    68: # ──────────────────────────────────────────────────────────────────────────────
    69: IMAP_POLL_ENABLED=true
    70: IMAP_POLL_PURPOSE=alerts
    71: IMAP_POLL_EVERY_MS=120000
    72: IMAP_POLL_MAX_PER_TICK=50
    73: IMAP_MOVE_TO=Processed/Alerts
    74: 
    75: # ──────────────────────────────────────────────────────────────────────────────
    76: # Backups notifier (used by Backups -> notifications + test-notification)
    77: # Leave blank to disable each channel; fill to enable.
    78: # ──────────────────────────────────────────────────────────────────────────────
    79: # SMTP transport specifically used by the Backups notifier (falls back to app SMTP if same)
    80: SMTP_HOST=localhost
    81: SMTP_PORT=587
    82: SMTP_SECURE=false
    83: SMTP_USER=
    84: SMTP_PASS=
    85: # From and default recipient for backup notifications
    86: SMTP_FROM="RemoteIQ Backups <backups@remoteiqrmm.com>"
    87: SMTP_TO=alerts@remoteiqrmm.com
    88: 
    89: # Slack incoming webhook URL (optional)
    90: SLACK_WEBHOOK_URL=
    91: 
    92: # Generic webhook for backup events (optional)
    93: BACKUPS_WEBHOOK_URL=
-----  END  CONTENT -----

## FILE: package.json

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\package.json
Size: 2295 bytes
SHA256: 6AB16C1BACCA0AA2330892D0F3BD242FB1C64BED44BF27AB04FDE69EF9726923
----- BEGIN CONTENT -----
     1: {
     2:   "name": "remoteiq-backend",
     3:   "version": "0.1.0",
     4:   "private": true,
     5:   "scripts": {
     6:     "dev": "tsx watch src/main.ts",
     7:     "clean": "rimraf dist",
     8:     "start": "node dist/main.js",
     9:     "build": "tsc -p tsconfig.json",
    10:     "prisma:generate": "prisma generate",
    11:     "prisma:migrate:dev": "prisma migrate dev --name init",
    12:     "prisma:studio": "prisma studio",
    13:     "health": "curl -sf http://localhost:${PORT:-3001}/healthz && echo OK || (echo FAIL; exit 1)",
    14:     "start:dev": "nest start --watch",
    15:     "start:prod": "node dist/main.js"
    16:   },
    17:   "dependencies": {
    18:     "@aws-sdk/client-s3": "^3.925.0",
    19:     "@aws-sdk/s3-request-presigner": "^3.925.0",
    20:     "@nestjs/common": "^10.3.6",
    21:     "@nestjs/core": "^10.3.6",
    22:     "@nestjs/jwt": "^11.0.1",
    23:     "@nestjs/mapped-types": "^2.1.0",
    24:     "@nestjs/platform-express": "^10.3.6",
    25:     "@nestjs/platform-ws": "^10.4.20",
    26:     "@nestjs/schedule": "^6.0.1",
    27:     "@nestjs/serve-static": "^5.0.4",
    28:     "@nestjs/swagger": "^7.4.2",
    29:     "@nestjs/websockets": "^10.3.6",
    30:     "@prisma/client": "^5.19.0",
    31:     "@types/bcryptjs": "^3.0.0",
    32:     "archiver": "^7.0.1",
    33:     "axios": "^1.13.2",
    34:     "bcryptjs": "^3.0.2",
    35:     "class-transformer": "^0.5.1",
    36:     "class-validator": "^0.14.2",
    37:     "cookie": "^1.0.2",
    38:     "cookie-parser": "^1.4.6",
    39:     "cron-parser": "^5.4.0",
    40:     "dotenv": "^17.2.3",
    41:     "express": "^4.19.2",
    42:     "file-type": "^21.0.0",
    43:     "googleapis": "^164.1.0",
    44:     "imapflow": "^1.0.200",
    45:     "jsonwebtoken": "^9.0.2",
    46:     "multer": "^2.0.2",
    47:     "nodemailer": "^7.0.9",
    48:     "otplib": "^12.0.1",
    49:     "pg": "^8.16.3",
    50:     "qrcode": "^1.5.4",
    51:     "reflect-metadata": "^0.2.2",
    52:     "rxjs": "^7.8.1",
    53:     "sharp": "^0.34.4",
    54:     "ssh2-sftp-client": "^12.0.1",
    55:     "swagger-ui-express": "^5.0.1",
    56:     "webdav": "^5.8.0",
    57:     "ws": "^8.18.0",
    58:     "zod": "^3.23.8"
    59:   },
    60:   "devDependencies": {
    61:     "@nestjs/cli": "^11.0.10",
    62:     "@types/cookie": "^1.0.0",
    63:     "@types/cookie-parser": "^1.4.9",
    64:     "@types/express": "^4.17.21",
    65:     "@types/jsonwebtoken": "^9.0.6",
    66:     "@types/multer": "^2.0.0",
    67:     "@types/node": "^20.11.30",
    68:     "@types/nodemailer": "^7.0.2",
    69:     "@types/pg": "^8.15.5",
    70:     "@types/qrcode": "^1.5.5",
    71:     "@types/ws": "^8.18.1",
    72:     "prisma": "^5.19.0",
    73:     "rimraf": "^6.0.1",
    74:     "tsx": "^4.19.1",
    75:     "typescript": "^5.6.3"
    76:   }
    77: }
-----  END  CONTENT -----

## FILE: tsconfig.json

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\tsconfig.json
Size: 524 bytes
SHA256: 30DE5B3DB27694AF14F352124AD9928E588FA0A6DC2A58494774C5C36E204A80
----- BEGIN CONTENT -----
     1: {
     2:   "compilerOptions": {
     3:     "target": "ES2021",
     4:     "module": "commonjs",
     5:     "moduleResolution": "node",
     6:     "lib": ["ES2021"],
     7:     "strict": true,
     8:     "noImplicitAny": false,
     9:     "sourceMap": true,
    10:     "outDir": "./dist",
    11:     "rootDir": "./src",
    12:     "esModuleInterop": true,
    13:     "emitDecoratorMetadata": true,
    14:     "experimentalDecorators": true,
    15:     "skipLibCheck": true,
    16:     "types": ["node", "express"]
    17:   },
    18:   "include": ["src/**/*"],
    19:   "exclude": ["node_modules", "dist", "test", "**/*.spec.ts"]
    20: }
-----  END  CONTENT -----

## FILE: nest-cli.json

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\nest-cli.json
Size: 59 bytes
SHA256: 8F108806C128B0FAA356A63F759C306A6BF1E6FE014B5B3FA0F11E752C83DA45
----- BEGIN CONTENT -----
     1: { "collection": "@nestjs/schematics", "sourceRoot": "src" }
-----  END  CONTENT -----


##############################################################################


End of bundle.
