RemoteIQ Storage/Backups Debug Bundle
Generated: 2025-11-07 14:22:29
Working dir: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing
Machine: LSITS-OFFICE-PC


====================================================================================================
=  BACKEND (must-have)
====================================================================================================


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/backups/storage-clients.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\storage-clients.ts
Size: 8.14 KB
LastWriteTime: 2025-11-07 13:58:28

----- BEGIN CONTENT -----
import {
    S3Client,
    PutObjectCommand,
    HeadObjectCommand,
    DeleteObjectCommand,
    GetObjectCommand,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import SftpClient from "ssh2-sftp-client";
import { createClient as createWebdavClient } from "webdav";
import { google } from "googleapis";
import * as fs from "fs";
import * as fsp from "fs/promises";
import * as path from "path";
import * as crypto from "crypto";
import type { Readable as NodeReadable } from "stream";

export type LocalLoc = { kind: "local"; path: string };
export type S3Loc = { kind: "s3"; bucket: string; key: string; region?: string; endpoint?: string };
export type ArtifactLoc = LocalLoc | S3Loc;

export type S3Secret = {
    region?: string;
    bucket?: string;
    endpoint?: string; // optional for compatible S3 (e.g., MinIO, Wasabi)
    accessKeyId?: string;
    secretAccessKey?: string;
    sessionToken?: string;
    forcePathStyle?: boolean;
    kmsKeyId?: string; // (not used here, but reserved)
};

export async function ensureDir(p: string) {
    await fsp.mkdir(p, { recursive: true });
}

/* ---------------- Local ---------------- */
export async function localWriteStream(absDir: string, filename: string) {
    await ensureDir(absDir);
    const full = path.join(absDir, filename);
    return { stream: fs.createWriteStream(full), fullPath: full };
}

export function localArtifactLoc(fullPath: string): LocalLoc {
    return { kind: "local", path: fullPath };
}

/* ---------------- S3 ---------------- */
function makeS3Client(secret: S3Secret) {
    const cfg: any = { region: secret.region ?? "us-east-1" };
    if (secret.endpoint) cfg.endpoint = secret.endpoint;
    if (secret.accessKeyId && secret.secretAccessKey) {
        cfg.credentials = {
            accessKeyId: secret.accessKeyId,
            secretAccessKey: secret.secretAccessKey,
            sessionToken: secret.sessionToken,
        };
    }
    if (secret.forcePathStyle != null) cfg.forcePathStyle = secret.forcePathStyle;
    return new S3Client(cfg);
}

// ✅ Body type: Buffer | Uint8Array | Node Readable
export async function s3PutObject(
    secret: S3Secret,
    bucket: string,
    key: string,
    body: Buffer | Uint8Array | NodeReadable
) {
    const s3 = makeS3Client(secret);
    await s3.send(new PutObjectCommand({ Bucket: bucket, Key: key, Body: body as any }));
}

export async function s3Head(secret: S3Secret, bucket: string, key: string) {
    const s3 = makeS3Client(secret);
    return s3.send(new HeadObjectCommand({ Bucket: bucket, Key: key }));
}

export async function s3Delete(secret: S3Secret, bucket: string, key: string) {
    const s3 = makeS3Client(secret);
    await s3.send(new DeleteObjectCommand({ Bucket: bucket, Key: key }));
}

export async function s3PresignGet(
    secret: S3Secret,
    bucket: string,
    key: string,
    expiresSec = 60 * 10
) {
    const s3 = makeS3Client(secret);
    return getSignedUrl(
        s3,
        new GetObjectCommand({ Bucket: bucket, Key: key }),
        { expiresIn: expiresSec }
    );
}

/* ---------------- SFTP (probe only) ---------------- */
export async function sftpProbe(opts: {
    host: string;
    port?: number;
    username: string;
    password?: string;
    privateKey?: string;
    passphrase?: string;
    hostHash?: string;
    testPath: string;
}) {
    const client = new SftpClient();
    try {
        await client.connect({
            host: opts.host,
            port: opts.port ?? 22,
            username: opts.username,
            password: opts.password,
            privateKey: opts.privateKey,
            passphrase: opts.passphrase,
        });
        const file =
            opts.testPath.replace(/\/+$/, "") +
            "/remoteiq_probe_" +
            crypto.randomBytes(8).toString("hex") +
            ".txt";
        const data = Buffer.from("probe");
        await client.put(data, file);
        const read = (await client.get(file)) as Buffer;
        const okRead = read && read.length === data.length;
        await client.delete(file);
        return { write: true, read: okRead, delete: true };
    } finally {
        try {
            await client.end();
        } catch { }
    }
}

/* ---------------- WebDAV (probe + upload + list) ---------------- */
export async function webdavProbe(opts: {
    url: string;
    username: string;
    password: string;
    path: string;
}) {
    const client = createWebdavClient(opts.url, {
        username: opts.username,
        password: opts.password,
    });
    const base = opts.path.replace(/\/+$/, "");
    const name = "remoteiq_probe_" + crypto.randomBytes(8).toString("hex") + ".txt";
    const p = base + "/" + name;
    const data = "probe";
    await client.putFileContents(p, data, { overwrite: true });
    const read = await client.getFileContents(p, { format: "text" });
    const okRead = read === data;
    await client.deleteFile(p);
    return { write: true, read: okRead, delete: true };
}

export async function webdavUpload(opts: {
    url: string;
    username: string;
    password: string;
    directory: string;   // e.g. "/Backups/RemoteIQ"
    filename: string;    // e.g. "backup_2025-11-07-18-00.tar.gz"
    body: Buffer | NodeReadable;
}) {
    const client = createWebdavClient(opts.url, {
        username: opts.username,
        password: opts.password,
    });
    const base = opts.directory.replace(/\/+$/, "");
    const full = `${base}/${opts.filename}`;
    await client.putFileContents(full, opts.body as any, { overwrite: true });
    return full; // return full remote path
}

export async function webdavDownloadAsBuffer(opts: {
    url: string;
    username: string;
    password: string;
    remotePath: string; // full path like "/Backups/RemoteIQ/backup_xxx.tar.gz"
}): Promise<Buffer> {
    const client = createWebdavClient(opts.url, {
        username: opts.username,
        password: opts.password,
    });
    const buf = await client.getFileContents(opts.remotePath, { format: "binary" }) as Buffer;
    return Buffer.isBuffer(buf) ? buf : Buffer.from(buf as any);
}

export async function webdavListDirs(opts: {
    url: string;
    username: string;
    password: string;
    basePath: string; // list immediate children
}): Promise<string[]> {
    const client = createWebdavClient(opts.url, {
        username: opts.username,
        password: opts.password,
    });
    const base = opts.basePath || "/";
    const items = await client.getDirectoryContents(base, { deep: false }) as any[];
    // Return folder paths (hrefs) normalized to start with "/"
    return (items || [])
        .filter((x) => x.type === "directory")
        .map((x) => {
            const href = String(x.filename || x.href || "");
            // filename is usually already absolute; ensure it starts with "/"
            return href.startsWith("/") ? href : "/" + href.replace(/^https?:\/\/[^/]+/i, "").replace(/^\/+/, "");
        });
}

/* ---------------- Google Drive (probe only) ---------------- */
export async function gdriveProbe(opts: { credentialsJson: any; folderId?: string }) {
    // ✅ Modern constructor signature with options object
    const auth = new google.auth.JWT({
        email: opts.credentialsJson.client_email,
        key: opts.credentialsJson.private_key,
        scopes: ["https://www.googleapis.com/auth/drive.file"],
    });
    const drive = google.drive({ version: "v3", auth });
    const name = "remoteiq_probe_" + crypto.randomBytes(8).toString("hex") + ".txt";

    const createRes = await drive.files.create({
        requestBody: { name, parents: opts.folderId ? [opts.folderId] : undefined },
        media: { mimeType: "text/plain", body: "probe" as any },
        fields: "id",
    });
    const id = createRes.data.id!;
    const get = await drive.files.get({ fileId: id, alt: "media" }, { responseType: "arraybuffer" });
    const okRead = Buffer.from(get.data as any).toString("utf8") === "probe";
    await drive.files.delete({ fileId: id });
    return { write: true, read: okRead, delete: true };
}

----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/backups/worker.service.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\worker.service.ts
Size: 14.79 KB
LastWriteTime: 2025-11-07 13:59:12

----- BEGIN CONTENT -----
import { Injectable, Logger } from "@nestjs/common";
import * as fs from "fs";
import * as fsp from "fs/promises";
import * as os from "os";
import * as path from "path";
import archiver from "archiver";
import { PgPoolService } from "../storage/pg-pool.service";
import { s3PutObject, s3Head, ensureDir, webdavUpload } from "./storage-clients";
import { NotifierService } from "./notifier.service";

type Job = { id: string; status: string; cancelled: boolean };

type JobConfig = {
    targets: string[];
    destination:
    | { kind: "local"; path: string }
    | { kind: "s3"; connectionId: string; bucket?: string; prefix?: string }
    | { kind: "nextcloud"; connectionId: string; path: string }
    | { kind: "gdrive"; connectionId: string; subfolder?: string }
    | { kind: "remote"; connectionId: string; path: string };
    notifications: { email?: boolean; slack?: boolean; webhook?: boolean };
};

@Injectable()
export class WorkerService {
    private log = new Logger("BackupsWorker");
    private running = false;

    constructor(
        private readonly db: PgPoolService,
        private readonly notifier: NotifierService
    ) { }

    /**
     * Picks the oldest running job (inserted as 'running' by BackupsService.startBackupNow)
     * and processes it. Re-entrant safe; returns immediately if a run is in progress.
     */
    async runOneIfAny() {
        if (this.running) return;
        const job = await this.pickJob();
        if (!job) return;

        this.running = true;
        try {
            await this.process(job.id);
        } finally {
            this.running = false;
        }
    }

    private async pickJob(): Promise<Job | null> {
        // Select oldest running job (already set to 'running' by the service)
        const { rows } = await this.db.query(
            `SELECT id, status, cancelled
         FROM backup_jobs
        WHERE status='running' AND cancelled=false
        ORDER BY started_at ASC
        LIMIT 1`
        );
        return rows[0] ?? null;
    }

    private async appendLog(jobId: string, chunk: string) {
        await this.db.query(
            `INSERT INTO backup_job_logs (job_id, log_text)
       VALUES ($1, $2)
       ON CONFLICT (job_id) DO UPDATE SET log_text = backup_job_logs.log_text || $2`,
            [jobId, chunk]
        );
    }

    /**
     * Process a single job:
     *  - export selected targets to NDJSON (skip missing)
     *  - tar.gz into an archive
     *  - write to local path or upload to remote destination(s)
     *  - persist manifest/log
     *  - mark success
     */
    async process(jobId: string) {
        const started = Date.now();

        const cfg = await this.loadJobConfig(jobId);
        if (!cfg) {
            await this.fail(jobId, "Backup configuration missing");
            return;
        }

        const tmpRoot = await fsp.mkdtemp(path.join(os.tmpdir(), "remoteiq-bkp-"));
        const exportDir = path.join(tmpRoot, "export");
        await ensureDir(exportDir);

        try {
            // Export targets -> NDJSON files
            const targets: string[] = cfg.targets.length ? cfg.targets : ["users", "devices", "settings"];

            const manifest: any = {
                id: jobId,
                targets,
                files: [],
                counts: {},
                createdAt: new Date().toISOString(),
            };

            await this.appendLog(jobId, `Exporting targets: ${targets.join(", ")}\n`);

            for (const t of targets) {
                // Resolve an existing table/view for this logical target (or skip)
                const table = await this.resolveExistingTableForTarget(jobId, t);
                if (!table) {
                    await this.appendLog(
                        jobId,
                        `  - ${t}: skipped (no mapped table/view exists)\n`
                    );
                    manifest.counts[t] = 0;
                    continue;
                }

                // Export rows to NDJSON
                const file = path.join(exportDir, `${t}.ndjson`);
                const ws = fs.createWriteStream(file, { flags: "w" });

                try {
                    const { rows } = await this.db.query(`SELECT * FROM ${table}`);
                    let count = 0;
                    for (const row of rows) {
                        ws.write(JSON.stringify(row) + "\n");
                        count++;
                    }
                    await new Promise((r) => ws.end(r));
                    manifest.files.push(path.basename(file));
                    manifest.counts[t] = count;
                    await this.appendLog(jobId, `  - ${t}: ${count} rows (from ${table})\n`);
                } catch (e: any) {
                    // If the table disappeared between resolve and select, log and skip
                    await new Promise((r) => ws.end(r));
                    await this.appendLog(
                        jobId,
                        `  - ${t}: error reading ${table} → ${e?.message || e}; skipped\n`
                    );
                    manifest.counts[t] = 0;
                }
            }

            // Create archive (.tar.gz)
            const archiveName = `backup_${new Date()
                .toISOString()
                .replace(/[:]/g, "-")
                .replace(/\..+/, "")}.tar.gz`;
            const archivePath = path.join(tmpRoot, archiveName);
            await this.createTarGz(exportDir, archivePath);

            const stat = await fsp.stat(archivePath);
            await this.appendLog(
                jobId,
                `Archive created: ${archiveName} (${stat.size} bytes)\n`
            );

            // Upload per destination
            const dest = cfg.destination as any;
            let artifactLoc: any = null;

            if (dest.kind === "local") {
                const full = path.join(dest.path, path.basename(archivePath));
                await ensureDir(dest.path);
                await fsp.copyFile(archivePath, full);
                artifactLoc = { kind: "local", path: full };
                await this.appendLog(jobId, `Saved to local path: ${full}\n`);
            } else if (dest.kind === "s3") {
                // Pull secrets from storage_connections
                const cid = dest.connectionId;
                const conn = (
                    await this.db.query(
                        `SELECT config, secrets
               FROM storage_connections
              WHERE id=$1 AND kind='s3'`,
                        [cid]
                    )
                ).rows[0];
                if (!conn) throw new Error("S3 connection not found");
                const cfgS3 = { ...(conn.config || {}), ...(conn.secrets || {}) };
                const bucket = dest.bucket || cfgS3.bucket;
                if (!bucket) throw new Error("S3 bucket not specified");
                const prefix = (dest.prefix || cfgS3.prefix || "").replace(/^\/+|\/+$/g, "");
                const key = (prefix ? `${prefix}/` : "") + path.basename(archivePath);
                await s3PutObject(cfgS3, bucket, key, fs.createReadStream(archivePath));
                await s3Head(cfgS3, bucket, key);
                artifactLoc = {
                    kind: "s3",
                    bucket,
                    key,
                    connectionId: cid,
                    region: cfgS3.region,
                    endpoint: cfgS3.endpoint,
                };
                await this.appendLog(jobId, `Uploaded to s3://${bucket}/${key}\n`);
            } else if (dest.kind === "nextcloud") {
                // Pull WebDAV config from storage_connections
                const cid = dest.connectionId;
                const conn = (
                    await this.db.query(
                        `SELECT config, secrets
               FROM storage_connections
              WHERE id=$1 AND kind='nextcloud'`,
                        [cid]
                    )
                ).rows[0];
                if (!conn) throw new Error("Nextcloud connection not found");
                const webdavUrl = conn.config?.webdavUrl;
                const username = conn.config?.username;
                const password = conn.secrets?.password;
                const directory = String(dest.path || conn.config?.path || "/").trim();
                if (!webdavUrl || !username || !password) {
                    throw new Error("Nextcloud connection incomplete (need webdavUrl, username, password)");
                }
                const remotePath = await webdavUpload({
                    url: webdavUrl,
                    username,
                    password,
                    directory,
                    filename: path.basename(archivePath),
                    body: fs.createReadStream(archivePath),
                });
                artifactLoc = {
                    kind: "nextcloud",
                    connectionId: cid,
                    path: remotePath,
                };
                await this.appendLog(jobId, `Uploaded to Nextcloud ${remotePath}\n`);
            } else {
                throw new Error(
                    `Destination kind '${dest.kind}' not supported for upload yet`
                );
            }

            // Save manifest & finalize
            await this.db.query(
                `INSERT INTO backup_job_manifests (job_id, manifest) VALUES ($1, $2)
         ON CONFLICT (job_id) DO UPDATE SET manifest=$2`,
                [jobId, JSON.stringify(manifest)]
            );

            const durationSec = Math.max(1, Math.round((Date.now() - started) / 1000));
            await this.db.query(
                `UPDATE backup_jobs
           SET finished_at=NOW(),
               status='completed',
               size_bytes=$2,
               duration_sec=$3,
               verified=true,
               artifact_location=$4
         WHERE id=$1`,
                [jobId, stat.size, durationSec, JSON.stringify(artifactLoc)]
            );

            await this.appendLog(jobId, `Done in ${durationSec}s\n`);

            // Notify (best-effort)
            await this.notify(
                cfg.notifications,
                `Backup ${jobId} success`,
                `Size=${stat.size} Duration=${durationSec}s`
            );
        } catch (e: any) {
            this.log.error(`Backup job ${jobId} failed: ${e?.message || e}`);
            await this.fail(jobId, e?.message || "Worker error");
            // try to notify failure, best-effort
            try {
                await this.notify(
                    cfg?.notifications ?? {},
                    `Backup ${jobId} failed`,
                    e?.message || "Worker error"
                );
            } catch { }
        } finally {
            // cleanup temp
            try {
                await fsp.rm(tmpRoot, { recursive: true, force: true });
            } catch { }
        }
    }

    private async fail(jobId: string, note: string) {
        await this.db.query(
            `UPDATE backup_jobs
          SET status='failed',
              finished_at=NOW(),
              note=$2
        WHERE id=$1`,
            [jobId, note]
        );
    }

    private async createTarGz(srcDir: string, outFile: string) {
        await new Promise<void>((resolve, reject) => {
            const output = fs.createWriteStream(outFile);
            const archive = archiver("tar", { gzip: true, gzipOptions: { level: 9 } });
            output.on("close", () => resolve());
            archive.on("error", (err) => reject(err));
            archive.pipe(output);
            archive.directory(srcDir, false);
            archive.finalize().catch(reject);
        });
    }

    /**
     * Map a logical target to candidate DB objects and return the first that exists.
     * Uses to_regclass to test existence safely (prevents injection via fixed mapping).
     */
    private async resolveExistingTableForTarget(jobId: string, target: string): Promise<string | null> {
        // Strict, explicit mapping only (no user input becomes SQL identifiers).
        // Add/adjust candidates here to match your schema names.
        const candidatesByTarget: Record<string, string[]> = {
            users: ["public.users", "users"],
            roles: ["public.roles", "roles"],
            devices: ["public.devices", "devices"],
            policies: ["public.policies", "policies"],
            audit_logs: ["public.audit_logs", "audit_logs", "public.auditlog", "auditlog"],
            settings: ["public.settings", "settings", "public.app_settings", "app_settings", "public.system_settings", "system_settings"],
            templates: ["public.templates", "templates"],
        };

        const candidates = candidatesByTarget[target] || [];
        for (const ident of candidates) {
            const reg = await this.db.query(`SELECT to_regclass($1) AS oid`, [ident]);
            const exists = !!reg.rows?.[0]?.oid;
            if (exists) return ident;
        }
        // log a one-liner for visibility
        await this.appendLog(jobId, `    (no table/view found for target "${target}")\n`);
        return null;
    }

    private async loadJobConfig(jobId: string): Promise<JobConfig | null> {
        const { rows } = await this.db.query(
            `SELECT j.id,
                    p.options,
                    d.configuration AS destination_configuration
               FROM backup_jobs j
          LEFT JOIN backup_policies p ON j.policy_id = p.id
          LEFT JOIN backup_destinations d ON d.id = p.destination_id
              WHERE j.id=$1`,
            [jobId]
        );
        if (!rows.length) {
            return null;
        }

        const options = rows[0].options && typeof rows[0].options === "object" ? rows[0].options : {};
        if (options.enabled === false) {
            return null;
        }

        const destination = rows[0].destination_configuration || {};
        if (!destination.kind) {
            return null;
        }

        const targets = Array.isArray(options.targets) ? options.targets.filter(Boolean) : [];
        const notifications =
            options.notifications && typeof options.notifications === "object"
                ? options.notifications
                : {};

        return {
            targets,
            destination,
            notifications,
        };
    }

    private async notify(
        channels: { email?: boolean; slack?: boolean; webhook?: boolean },
        subject: string,
        body: string
    ) {
        try {
            await this.notifier.send(channels || {}, subject, body);
        } catch (e) {
            this.log.warn(`Notify failed: ${e}`);
        }
    }
}

----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/backups/backups.service.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\backups.service.ts
Size: 27.82 KB
LastWriteTime: 2025-11-07 14:00:08

----- BEGIN CONTENT -----
import {
    BadRequestException,
    Injectable,
    NotFoundException,
} from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";
import { OrganizationContextService } from "../storage/organization-context.service";
import { BackupConfigDto, HistoryQueryDto } from "./dto";
import { Readable } from "stream";
import * as crypto from "crypto";
import { WorkerService } from "./worker.service";
import { NotifierService } from "./notifier.service";
import { s3PresignGet, webdavDownloadAsBuffer } from "./storage-clients";

type JobRow = {
    id: string;
    started_at: Date;
    finished_at: Date | null;
    status: "running" | "completed" | "failed" | "cancelled";
    note: string | null;
    size_bytes: number | null;
    duration_sec: number | null;
    verified: boolean | null;
};

type HistoryStatus = "success" | "failed" | "running";

function mapFilterStatus(status: HistoryStatus | undefined): string | undefined {
    if (!status) return undefined;
    if (status === "success") return "completed";
    return status;
}

function projectStatus(status: string): HistoryStatus {
    switch (status) {
        case "completed":
            return "success";
        case "failed":
        case "cancelled":
            return "failed";
        default:
            return "running";
    }
}

function isAbsolutePath(p: string) {
    return p.startsWith("/") || /^[A-Za-z]:\\/.test(p);
}
function sanitizeLocalPath(p: string) {
    if (!isAbsolutePath(p)) throw new BadRequestException("Path must be absolute");
    if (p.includes("..") || p.includes("\0")) throw new BadRequestException("Invalid path");
    return p;
}
function parseCursor(cur?: string | null): number {
    if (!cur) return 0;
    try {
        const { page } = JSON.parse(Buffer.from(cur, "base64").toString("utf8"));
        return Number(page) || 0;
    } catch {
        return 0;
    }
}
function makeCursor(page: number) {
    return Buffer.from(JSON.stringify({ page }), "utf8").toString("base64");
}

type PolicyRow = {
    id: string;
    schedule: string;
    retention: any;
    options: any;
    destination_id: string | null;
    destination_provider: string | null;
    destination_configuration: any | null;
};

type PolicyConfig = {
    policyId: string;
    enabled: boolean;
    targets: string[];
    schedule: string;
    cronExpr?: string;
    retentionDays: number;
    encrypt: boolean;
    destination: any | null;
    notifications: Record<string, any>;
    lastScheduledAt?: string | null;
};

@Injectable()
export class BackupsService {
    constructor(
        private readonly db: PgPoolService,
        private readonly notifier: NotifierService,
        private readonly worker: WorkerService,
        private readonly orgContext: OrganizationContextService,
    ) { }

    private async orgId(): Promise<string> {
        return this.orgContext.getDefaultOrganizationId();
    }

    private retentionDays(retention: any): number {
        if (!retention) return 30;
        if (typeof retention.days === "number") return retention.days;
        if (typeof retention.value === "number" && retention.unit === "days") {
            return retention.value;
        }
        return 30;
    }

    private parsePolicy(row: PolicyRow | null): PolicyConfig | null {
        if (!row) return null;
        const options = row.options && typeof row.options === "object" ? row.options : {};
        const destination =
            row.destination_configuration && typeof row.destination_configuration === "object"
                ? row.destination_configuration
                : null;

        const cronExpr = options.cronExpr ?? options.cron_expr ?? undefined;
        const notifications =
            options.notifications && typeof options.notifications === "object"
                ? options.notifications
                : {};

        const enabled = options.enabled ?? false;
        const rawTargets = Array.isArray(options.targets)
            ? options.targets.filter((t: any) => typeof t === "string" && t.trim().length)
            : [];
        const targets = rawTargets.length ? rawTargets : ["users", "roles", "devices", "settings"];
        const encrypt = options.encrypt ?? true;
        const lastScheduledAt = options.lastScheduledAt ?? options.last_scheduled_at ?? null;

        return {
            policyId: row.id,
            enabled,
            targets,
            schedule: row.schedule,
            cronExpr: cronExpr ?? undefined,
            retentionDays: this.retentionDays(row.retention),
            encrypt,
            destination,
            notifications,
            lastScheduledAt,
        };
    }

    private normalizeDestinationInput(dest: any): { provider: string; configuration: any } {
        if (!dest || typeof dest !== "object") {
            throw new BadRequestException("Destination required");
        }
        const provider = dest.kind === "remote" ? "sftp" : dest.kind;
        return {
            provider,
            configuration: { ...dest },
        };
    }

    private async fetchDefaultPolicyRow(): Promise<PolicyRow | null> {
        const orgId = await this.orgId();
        const { rows } = await this.db.query<PolicyRow>(
            `SELECT p.id,
                    p.schedule,
                    p.retention,
                    p.options,
                    p.destination_id,
                    d.provider AS destination_provider,
                    d.configuration AS destination_configuration
               FROM backup_policies p
          LEFT JOIN backup_destinations d ON d.id = p.destination_id
              WHERE p.organization_id = $1
           ORDER BY p.is_default DESC, p.created_at ASC
              LIMIT 1`,
            [orgId]
        );
        return rows[0] ?? null;
    }

    private async fetchDefaultPolicy(): Promise<PolicyConfig | null> {
        const row = await this.fetchDefaultPolicyRow();
        return this.parsePolicy(row);
    }

    private async upsertDestination(
        orgId: string,
        dest: any,
    ): Promise<{ id: string; provider: string; configuration: any }> {
        const { provider, configuration } = this.normalizeDestinationInput(dest);
        const { rows } = await this.db.query<{ id: string; provider: string; configuration: any }>(
            `INSERT INTO backup_destinations (organization_id, name, provider, configuration)
             VALUES ($1, $2, $3, $4::jsonb)
             ON CONFLICT (organization_id, name)
             DO UPDATE SET provider = EXCLUDED.provider,
                           configuration = EXCLUDED.configuration,
                           updated_at = NOW()
             RETURNING id, provider, configuration`,
            [orgId, "Default Backup Destination", provider, JSON.stringify(configuration)]
        );
        return rows[0];
    }

    private async upsertPolicy(
        orgId: string,
        destinationId: string,
        cfg: BackupConfigDto,
        existingOptions: Record<string, any>,
    ): Promise<PolicyConfig | null> {
        const mergedOptions = {
            ...existingOptions,
            enabled: !!cfg.enabled,
            targets: cfg.targets,
            cronExpr: cfg.schedule === "cron" ? cfg.cronExpr ?? null : null,
            cron_expr: cfg.schedule === "cron" ? cfg.cronExpr ?? null : null,
            encrypt: !!cfg.encrypt,
            notifications: cfg.notifications ?? {},
        };
        if (mergedOptions.cronExpr == null) delete (mergedOptions as any).cronExpr;
        if (mergedOptions.cron_expr == null) delete (mergedOptions as any).cron_expr;
        const inserted = await this.db.query<{ id: string }>(
            `INSERT INTO backup_policies (
                 organization_id,
                 name,
                 description,
                 schedule,
                 retention,
                 destination_id,
                 target_type,
                 target_id,
                 options,
                 is_default)
             VALUES (
                 $1,
                 $2,
                 $3,
                 $4,
                 $5::jsonb,
                 $6,
                 'organization',
                 NULL,
                 $7::jsonb,
                 TRUE)
             ON CONFLICT (organization_id, name)
             DO UPDATE SET
                 description = EXCLUDED.description,
                 schedule = EXCLUDED.schedule,
                 retention = EXCLUDED.retention,
                 destination_id = EXCLUDED.destination_id,
                 target_type = EXCLUDED.target_type,
                 target_id = EXCLUDED.target_id,
                 options = EXCLUDED.options,
                 is_default = TRUE,
                 updated_at = NOW()
             RETURNING id`,
            [
                orgId,
                "Default Backup Policy",
                "Normalized default backups policy",
                cfg.schedule,
                JSON.stringify({ days: cfg.retentionDays }),
                destinationId,
                JSON.stringify(mergedOptions),
            ]
        );
        const policyId = inserted.rows[0]?.id;
        if (!policyId) {
            return null;
        }

        const detail = await this.db.query<PolicyRow>(
            `SELECT p.id,
                    p.schedule,
                    p.retention,
                    p.options,
                    p.destination_id,
                    d.provider AS destination_provider,
                    d.configuration AS destination_configuration
               FROM backup_policies p
          LEFT JOIN backup_destinations d ON d.id = p.destination_id
              WHERE p.id = $1`,
            [policyId]
        );
        return this.parsePolicy(detail.rows[0] ?? null);
    }

    private async ensurePolicyAndDestination(cfg?: BackupConfigDto): Promise<PolicyConfig | null> {
        if (!cfg) {
            return this.fetchDefaultPolicy();
        }
        const orgId = await this.orgId();
        const currentRow = await this.fetchDefaultPolicyRow();
        const existingOptions =
            currentRow && currentRow.options && typeof currentRow.options === "object"
                ? currentRow.options
                : {};

        const destination = await this.upsertDestination(orgId, cfg.destination);
        return this.upsertPolicy(orgId, destination.id, cfg, existingOptions);
    }

    /* ---------------- Permissions (UI helper) --------------- */
    async getPermissions() {
        // Controller derives real booleans via RBAC; keep this as a safe default fallback.
        return { restore: true, download: true };
    }

    /* ---------------- Config --------------------- */
    async getConfig() {
        const policy = await this.fetchDefaultPolicy();
        if (!policy) {
            return {
                enabled: false,
                targets: ["users", "roles", "devices", "settings"],
                schedule: "daily",
                cronExpr: "0 3 * * *",
                retentionDays: 30,
                encrypt: true,
                destination: { kind: "local", path: "/var/remoteiq/backups" },
                notifications: { email: false, webhook: false, slack: false },
            };
        }

        return {
            enabled: policy.enabled,
            targets: policy.targets,
            schedule: policy.schedule as any,
            cronExpr: policy.cronExpr,
            retentionDays: policy.retentionDays,
            encrypt: policy.encrypt,
            destination: policy.destination ?? { kind: "local", path: "/var/remoteiq/backups" },
            notifications: policy.notifications,
        };
    }

    validateDestination(dest: any) {
        if (!dest || typeof dest !== "object" || !dest.kind) {
            throw new BadRequestException("Destination required");
        }
        switch (dest.kind) {
            case "local":
                sanitizeLocalPath(String(dest.path || ""));
                break;
            case "s3":
            case "nextcloud":
            case "gdrive":
            case "remote":
                if (!dest.connectionId || !/^[0-9a-f-]{36}$/i.test(dest.connectionId)) {
                    throw new BadRequestException("Valid connectionId required");
                }
                if (dest.kind === "nextcloud") {
                    const p = String(dest.path || "");
                    if (!p.startsWith("/"))
                        throw new BadRequestException("Nextcloud path must start with '/'");
                }
                if (dest.kind === "remote") {
                    const p = String(dest.path || "");
                    if (!isAbsolutePath(p))
                        throw new BadRequestException("Remote path must be absolute");
                }
                break;
            default:
                throw new BadRequestException("Unsupported destination");
        }
    }

    async saveConfig(cfg: BackupConfigDto) {
        if (cfg.schedule === "cron" && !cfg.cronExpr) {
            throw new BadRequestException("cronExpr required for schedule=cron");
        }
        const policy = await this.ensurePolicyAndDestination(cfg);
        return {
            ok: true,
            policyId: policy?.policyId,
        };
    }

    /* ---------------- History -------------------- */
    async listHistory(q: HistoryQueryDto) {
        const pageSize = 50;
        const page = parseCursor(q.cursor);
        const offset = page * pageSize;

        const params: any[] = [];
        const where: string[] = [];

        const policy = await this.fetchDefaultPolicy();
        if (policy?.policyId) {
            params.push(policy.policyId);
            where.push(`(policy_id = $${params.length} OR policy_id IS NULL)`);
        }
        const statusFilter = mapFilterStatus(q.status as any);
        if (statusFilter) {
            params.push(statusFilter);
            where.push(`status = $${params.length}`);
        }
        if (q.q?.trim()) {
            params.push(`%${q.q.trim()}%`);
            where.push(`(id::text ILIKE $${params.length} OR note ILIKE $${params.length})`);
        }
        if (q.from) {
            params.push(q.from);
            where.push(`started_at >= $${params.length}::date`);
        }
        if (q.to) {
            params.push(q.to);
            where.push(`started_at < ($${params.length}::date + INTERVAL '1 day')`);
        }
        const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";

        const sql = `
      SELECT id, started_at, status, note, size_bytes, duration_sec, verified
      FROM backup_jobs
      ${whereSql}
      ORDER BY started_at DESC
      LIMIT ${pageSize + 1}
      OFFSET ${offset}
    `;

        const { rows } = await this.db.query<JobRow>(sql, params);
        const items = rows.slice(0, pageSize).map((r) => ({
            id: r.id,
            at: r.started_at.toISOString().slice(0, 16).replace("T", " "),
            status: projectStatus(r.status),
            note: r.note ?? undefined,
            sizeBytes: r.size_bytes ?? undefined,
            durationSec: r.duration_sec ?? undefined,
            verified: r.verified ?? undefined,
        }));

        const hasMore = rows.length > pageSize;
        return { items, nextCursor: hasMore ? makeCursor(page + 1) : undefined };
    }

    /* ---------------- Scheduler hooks ------------- */
    async markScheduledOnce(now: Date) {
        const policy = await this.fetchDefaultPolicyRow();
        if (!policy) return { updated: false };

        const { rows } = await this.db.query(
            `UPDATE backup_policies
                SET options = jsonb_set(
                    COALESCE(options, '{}'::jsonb),
                    '{lastScheduledAt}',
                    to_jsonb(($2)::timestamptz),
                    true
                )
             WHERE id = $1
               AND (
                    options->>'lastScheduledAt' IS NULL
                 OR (options->>'lastScheduledAt')::timestamptz < ($2)::timestamptz - interval '30 seconds'
               )
             RETURNING 1`,
            [policy.id, now.toISOString()]
        );
        return { updated: rows.length > 0 };
    }

    async kickWorker() {
        await this.worker.runOneIfAny();
    }

    /* ---------------- Actions -------------------- */
    async startBackupNow() {
        const policy = await this.ensurePolicyAndDestination();
        if (!policy) {
            throw new BadRequestException("Backups not configured");
        }
        if (!policy.enabled) {
            throw new BadRequestException("Backups disabled");
        }

        const id = crypto.randomUUID();
        await this.db.query(
            `INSERT INTO backup_jobs (id, policy_id, started_at, status, note)
             VALUES ($1, $2, NOW(), 'running', 'Manual run')`,
            [id, policy.policyId]
        );
        // Start immediately
        await this.worker.runOneIfAny();
        return { id, startedAt: new Date().toISOString() };
    }

    async pruneOld() {
        const policy = await this.fetchDefaultPolicy();
        if (!policy) {
            return { removed: 0 };
        }

        const params: any[] = [String(policy.retentionDays)];
        let sql = `DELETE FROM backup_jobs
             WHERE COALESCE(finished_at, started_at) < (NOW() - ($1 || ' days')::interval)
               AND status IN ('completed','failed','cancelled')`;

        if (policy.policyId) {
            params.push(policy.policyId);
            sql += ` AND (policy_id = $2 OR policy_id IS NULL)`;
        }

        const { rows } = await this.db.query(sql + ` RETURNING 1`, params);
        return { removed: rows.length };
    }

    // Real destination testing (local & S3), probes for others via helper module.
    async testDestination(dest: any) {
        if (dest.kind === "local") {
            sanitizeLocalPath(dest.path);
            const { ensureDir } = await import("./storage-clients");
            const fs = await import("fs/promises");
            const p = require("path").join(dest.path, ".remoteiq_probe.txt");
            await ensureDir(dest.path);
            await fs.writeFile(p, "probe");
            const r = await fs.readFile(p, "utf8");
            await fs.unlink(p);
            return { ok: r === "probe", phases: { write: true, read: r === "probe", delete: true } };
        }

        if (dest.kind === "s3") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='s3'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("S3 connection not found");
            const cfgS3 = { ...(row.config || {}), ...(row.secrets || {}) };
            const bucket = dest.bucket || cfgS3.bucket;
            const prefix = (dest.prefix || cfgS3.prefix || "").replace(/^\/+|\/+$/g, "");
            const key = (prefix ? `${prefix}/` : "") + ".remoteiq_probe.txt";
            const { s3PutObject, s3Head, s3Delete } = await import("./storage-clients");
            await s3PutObject(cfgS3, bucket, key, Buffer.from("probe"));
            const head = await s3Head(cfgS3, bucket, key);
            const ok = !!head;
            await s3Delete(cfgS3, bucket, key);
            return { ok, phases: { write: true, read: ok, delete: true } };
        }

        if (dest.kind === "nextcloud") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='nextcloud'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("Nextcloud connection not found");
            const { webdavProbe } = await import("./storage-clients");
            const url = row.config?.webdavUrl;
            const username = row.config?.username;
            const password = row.secrets?.password;
            const path = dest.path;
            const phases = await webdavProbe({ url, username, password, path });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        if (dest.kind === "remote") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='sftp'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("SFTP connection not found");
            const { sftpProbe } = await import("./storage-clients");
            const host = row.config?.host;
            const port = row.config?.port;
            const username = row.secrets?.username || row.config?.username;
            const password = row.secrets?.password;
            const privateKey = row.secrets?.privateKey;
            const passphrase = row.secrets?.passphrase;
            const phases = await sftpProbe({
                host,
                port,
                username,
                password,
                privateKey,
                passphrase,
                testPath: dest.path,
            });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        if (dest.kind === "gdrive") {
            const cid = dest.connectionId;
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='gdrive'`,
                [cid]
            )).rows[0];
            if (!row) throw new BadRequestException("GDrive connection not found");
            const { gdriveProbe } = await import("./storage-clients");
            const credentialsJson = row.secrets?.serviceAccountJson;
            const folderId = row.config?.folderId || undefined;
            const phases = await gdriveProbe({ credentialsJson, folderId });
            return { ok: phases.write && phases.read && phases.delete, phases };
        }

        throw new BadRequestException("Unsupported destination");
    }

    async testNotification() {
        await this.notifier.send(
            { email: true, slack: true, webhook: true },
            "RemoteIQ Backups: Test",
            "This is a test notification."
        );
        return { sent: true };
    }

    async retryJob(id: string) {
        const { rows } = await this.db.query(
            `UPDATE backup_jobs
         SET status='running', note='Retry queued', finished_at=NULL, cancelled=false
       WHERE id=$1 AND status='failed'
       RETURNING 1`,
            [id]
        );
        if (!rows.length) throw new BadRequestException("Job not in failed state");
        await this.worker.runOneIfAny();
        return { queued: true };
    }

    async cancelJob(id: string) {
        const { rows } = await this.db.query(
            `UPDATE backup_jobs
         SET cancelled=true, status='cancelled', finished_at=NOW(), note='Cancelled by user'
       WHERE id=$1 AND status='running'
       RETURNING 1`,
            [id]
        );
        if (!rows.length) throw new BadRequestException("Job not running");
        return { sent: true };
    }

    async startRestore(id: string) {
        const { rows } = await this.db.query(
            `SELECT id, status FROM backup_jobs WHERE id=$1 LIMIT 1`,
            [id]
        );
        if (!rows.length) throw new NotFoundException("Backup not found");
        if (rows[0].status !== "completed")
            throw new BadRequestException("Backup not successful");

        await this.db.query(
            `INSERT INTO backup_restores (id, backup_job_id, status)
       VALUES ($1, $2, 'running')`,
            [crypto.randomUUID(), id]
        );
        return { started: true };
    }

    /* ---------------- Artifacts ------------------- */
    async openLogStream(id: string): Promise<Readable | null> {
        const { rows } = await this.db.query(
            `SELECT log_text FROM backup_job_logs WHERE job_id=$1`,
            [id]
        );
        if (!rows.length) return null;
        const text: string = rows[0].log_text ?? "";
        return Readable.from(text);
    }

    async getManifest(id: string): Promise<any | null> {
        const { rows } = await this.db.query(
            `SELECT manifest FROM backup_job_manifests WHERE job_id=$1`,
            [id]
        );
        if (!rows.length) return null;
        return rows[0].manifest;
    }

    async getDownload(id: string): Promise<{ presignedUrl?: string; stream?: Readable; filename: string } | null> {
        const { rows } = await this.db.query(
            `SELECT j.status,
                    j.artifact_location,
                    d.configuration AS destination_configuration
               FROM backup_jobs j
          LEFT JOIN backup_policies p ON j.policy_id = p.id
          LEFT JOIN backup_destinations d ON d.id = p.destination_id
              WHERE j.id=$1`,
            [id]
        );
        if (!rows.length) return null;
        if (rows[0].status !== "completed")
            throw new BadRequestException("Backup not successful");

        const loc = rows[0].artifact_location || {};
        if (loc.kind === "local") {
            const fs = await import("fs");
            if (!fs.existsSync(loc.path)) return null;
            const filename = String(loc.path).split(/[\\/]/).pop() || "backup.tar.gz";
            return { filename, stream: fs.createReadStream(loc.path) };
        }
        if (loc.kind === "s3") {
            const destConfig = rows[0].destination_configuration || {};
            const connectionId = loc.connectionId || destConfig.connectionId;
            if (!connectionId) throw new BadRequestException("S3 connection missing");
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='s3'`,
                [connectionId]
            )).rows[0];
            if (!row) throw new BadRequestException("S3 connection missing");
            const s3Cfg = { ...(row.config || {}), ...(row.secrets || {}) };
            const bucket = loc.bucket || destConfig.bucket || s3Cfg.bucket;
            const key = loc.key || destConfig.key;
            if (!bucket || !key) throw new BadRequestException("S3 location incomplete");
            const url = await s3PresignGet(s3Cfg, bucket, key, 60 * 10);
            const filename = String(key || "").split("/").pop() || "backup.tar.gz";
            return { presignedUrl: url, filename };
        }
        if (loc.kind === "nextcloud") {
            const connectionId = loc.connectionId;
            if (!connectionId) throw new BadRequestException("Nextcloud connection missing");
            const row = (await this.db.query(
                `SELECT config, secrets FROM storage_connections WHERE id=$1 AND kind='nextcloud'`,
                [connectionId]
            )).rows[0];
            if (!row) throw new BadRequestException("Nextcloud connection missing");
            const webdavUrl = row.config?.webdavUrl;
            const username = row.config?.username;
            const password = row.secrets?.password;
            const remotePath = loc.path;
            if (!webdavUrl || !username || !password || !remotePath) {
                throw new BadRequestException("Nextcloud location incomplete");
            }
            const buf = await webdavDownloadAsBuffer({ url: webdavUrl, username, password, remotePath });
            const filename = String(remotePath).split("/").pop() || "backup.tar.gz";
            return { filename, stream: Readable.from(buf) };
        }
        return null;
    }
}

----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/backups/dto.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\dto.ts
Size: 2.83 KB
LastWriteTime: 2025-11-05 21:32:36

----- BEGIN CONTENT -----
import {
    IsArray, IsBoolean, IsIn, IsInt, IsNumber, IsOptional, IsString,
    IsUUID, Min, Max, ValidateNested, IsObject, Matches
} from "class-validator";
import { Type } from "class-transformer";

export const SCHEDULES = ["hourly", "daily", "weekly", "cron"] as const;
export type ScheduleKind = typeof SCHEDULES[number];

export type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";
export type Destination =
    | { kind: "local"; path: string }
    | { kind: "s3"; connectionId: string; bucket?: string; prefix?: string }
    | { kind: "nextcloud"; connectionId: string; path: string }
    | { kind: "gdrive"; connectionId: string; subfolder?: string }
    | { kind: "remote"; connectionId: string; path: string };

export class NotificationsDto {
    @IsOptional() @IsBoolean() email?: boolean;
    @IsOptional() @IsBoolean() webhook?: boolean;
    @IsOptional() @IsBoolean() slack?: boolean;
}

export class LocalDestDto {
    @IsIn(["local"]) kind!: "local";
    @IsString() path!: string;
}

export class S3DestDto {
    @IsIn(["s3"]) kind!: "s3";
    @IsUUID() connectionId!: string;
    @IsOptional() @IsString() bucket?: string;
    @IsOptional() @IsString() prefix?: string;
}

export class NextcloudDestDto {
    @IsIn(["nextcloud"]) kind!: "nextcloud";
    @IsUUID() connectionId!: string;
    @IsString() path!: string;
}

export class GDriveDestDto {
    @IsIn(["gdrive"]) kind!: "gdrive";
    @IsUUID() connectionId!: string;
    @IsOptional() @IsString() subfolder?: string;
}

export class RemoteDestDto {
    @IsIn(["remote"]) kind!: "remote";
    @IsUUID() connectionId!: string;
    @IsString() path!: string;
}

export class DestinationDto {
    @IsIn(["local", "s3", "nextcloud", "gdrive", "remote"])
    kind!: Destination["kind"];
}

export class BackupConfigDto {
    @IsBoolean() enabled!: boolean;

    @IsArray() @IsString({ each: true })
    targets!: string[]; // UI-enforced values

    @IsIn(SCHEDULES as unknown as string[]) schedule!: ScheduleKind;

    @IsOptional()
    @Matches(/^(\S+\s+){4}\S+$/)
    cronExpr?: string;

    @IsInt() @Min(1) @Max(3650)
    retentionDays!: number;

    @IsBoolean() encrypt!: boolean;

    @IsObject()
    destination!: Destination;

    @IsOptional() @ValidateNested()
    @Type(() => NotificationsDto)
    notifications?: NotificationsDto;
}

export class HistoryQueryDto {
    @IsOptional() @IsString() cursor?: string;
    @IsOptional() @IsIn(["success", "failed", "running"]) status?: "success" | "failed" | "running";
    @IsOptional() @IsString() q?: string;
    @IsOptional() @Matches(/^\d{4}-\d{2}-\d{2}$/) from?: string;
    @IsOptional() @Matches(/^\d{4}-\d{2}-\d{2}$/) to?: string;
}

export class TestDestinationDto {
    @ValidateNested() @Type(() =>
        Object
    ) destination!: Destination;
}

----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/backups/scheduler.service.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\scheduler.service.ts
Size: 2.59 KB
LastWriteTime: 2025-11-05 23:00:44

----- BEGIN CONTENT -----
import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from "@nestjs/common";
import * as cronParser from "cron-parser";
import { BackupsService } from "./backups.service";
import { WorkerService } from "./worker.service";

@Injectable()
export class SchedulerService implements OnModuleInit, OnModuleDestroy {
    private cronTimer?: NodeJS.Timeout;
    private workerTimer?: NodeJS.Timeout;
    private log = new Logger("BackupsScheduler");

    constructor(
        private readonly svc: BackupsService,
        private readonly worker: WorkerService
    ) { }

    onModuleInit() {
        // Check cron schedule every 30s
        this.cronTimer = setInterval(
            () => this.tickCron().catch((e) => this.log.error(e?.message || e)),
            30_000
        );
        // Worker pump every 5s to process any running jobs
        this.workerTimer = setInterval(
            () => this.worker.runOneIfAny().catch(() => { }),
            5_000
        );
    }

    onModuleDestroy() {
        if (this.cronTimer) clearInterval(this.cronTimer);
        if (this.workerTimer) clearInterval(this.workerTimer);
    }

    private async tickCron() {
        const cfg = await this.svc.getConfig();
        if (!cfg.enabled) return;

        const now = new Date();
        let due = false;

        if (cfg.schedule === "hourly") {
            due = now.getMinutes() === 0;
        } else if (cfg.schedule === "daily") {
            due = now.getHours() === 3 && now.getMinutes() === 0;
        } else if (cfg.schedule === "weekly") {
            due = now.getDay() === 0 && now.getHours() === 3 && now.getMinutes() === 0;
        } else if (cfg.schedule === "cron" && cfg.cronExpr) {
            const parse = (cronParser as any).parseExpression as
                | ((expr: string, opts?: any) => { prev(): { toDate(): Date } })
                | undefined;
            if (typeof parse !== "function") {
                this.log.warn("cron-parser parseExpression not available");
            } else {
                const it = parse(cfg.cronExpr, {
                    tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
                });
                const prev = it.prev().toDate();
                // fire if previous occurrence is within last minute
                due = +now - +prev < 60_000;
            }
        }

        if (!due) return;

        this.log.log("Cron window due → starting backup job");
        await this.svc.startBackupNow();
        // Immediately try to process it
        this.worker.runOneIfAny().catch(() => { });
    }
}

----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/storage/storage.controller.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\storage.controller.ts
Size: 1.61 KB
LastWriteTime: 2025-11-06 17:36:57

----- BEGIN CONTENT -----
import {
    Body,
    Controller,
    Delete,
    Get,
    Param,
    Post,
    Put,
    UseGuards,
} from "@nestjs/common";
import { StorageConnectionsService } from "./storage-connections.service";
import { PermissionsGuard } from "../auth/permissions.guard";
import { RequirePerm } from "../auth/require-perm.decorator";

@Controller("/api/admin/storage")
@UseGuards(PermissionsGuard)
export class StorageController {
    constructor(private readonly svc: StorageConnectionsService) { }

    @Get("connections")
    @RequirePerm("backups.manage")
    async list() {
        return this.svc.list();
    }

    @Post("connections")
    @RequirePerm("backups.manage")
    async create(@Body() body: any) {
        return this.svc.create(body);
    }

    @Put("connections/:id")
    @RequirePerm("backups.manage")
    async update(@Param("id") id: string, @Body() body: any) {
        await this.svc.update(id, body);
        return { ok: true };
    }

    @Delete("connections/:id")
    @RequirePerm("backups.manage")
    async remove(@Param("id") id: string) {
        await this.svc.delete(id);
        return { ok: true };
    }

    @Get("connections/:id/dependents")
    @RequirePerm("backups.manage")
    async dependents(@Param("id") id: string) {
        return this.svc.getDependents(id);
    }

    @Post("test")
    @RequirePerm("backups.manage")
    async test(@Body() body: any) {
        return this.svc.test(body);
    }

    @Post("browse")
    @RequirePerm("backups.manage")
    async browse(@Body() body: any) {
        return this.svc.browseNextcloud(body);
    }
}

----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/storage/storage-connections.service.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\storage-connections.service.ts
Size: 16.38 KB
LastWriteTime: 2025-11-07 14:17:39

----- BEGIN CONTENT -----
import {
    BadRequestException,
    Injectable,
    NotFoundException,
} from "@nestjs/common";
import { PgPoolService } from "./pg-pool.service";
import { OrganizationContextService } from "./organization-context.service";
import { s3PutObject, s3Head, s3Delete, webdavProbe, webdavListDirs, sftpProbe } from "../backups/storage-clients";

type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";

type StorageConnectionRow = {
    id: string;
    organization_id: string;
    name: string;
    kind: StorageKind;
    config: Record<string, any> | null;
    secrets: Record<string, any> | null;
    meta: Record<string, any> | null;
    capabilities: Record<string, any> | null;
    health: Record<string, any> | null;
};

type StorageConnectionDto = {
    id: string;
    name: string;
    kind: StorageKind;
    config: Record<string, any>;
    meta: Record<string, any>;
    capabilities: Record<string, any>;
    health: Record<string, any>;
    hasSecret?: {
        s3Credentials?: boolean;
        nextcloudPassword?: boolean;
        sftpPassword?: boolean;
        sftpPrivateKey?: boolean;
    };
};

type SecretMap = Record<string, any>;

type CreateUpdatePayload = {
    id?: string;
    name: string;
    kind: StorageKind;
    config: Record<string, any>;
    meta?: Record<string, any>;
};

const ALLOWED_KINDS: StorageKind[] = ["s3", "nextcloud", "gdrive", "sftp"];

const DEFAULT_CAPABILITIES = {
    canUse: true,
    canEdit: true,
    canRotate: true,
    canDelete: true,
};

const DEFAULT_HEALTH = { status: "unknown" };

@Injectable()
export class StorageConnectionsService {
    constructor(
        private readonly db: PgPoolService,
        private readonly orgCtx: OrganizationContextService,
    ) { }

    /* ----------------------------- helpers ----------------------------- */
    private async orgId(): Promise<string> {
        return this.orgCtx.getDefaultOrganizationId();
    }

    private ensureKind(kind: string): asserts kind is StorageKind {
        if (!ALLOWED_KINDS.includes(kind as StorageKind)) {
            throw new BadRequestException(`Unsupported storage kind: ${kind}`);
        }
    }

    private clone<T>(value: T): T {
        return value ? JSON.parse(JSON.stringify(value)) : value;
    }

    private withDefaults(meta: Record<string, any> | null | undefined): Record<string, any> {
        const incoming = { ...(meta ?? {}) };
        const defaultFor = {
            backups: false,
            exports: false,
            artifacts: false,
            ...(incoming.defaultFor ?? {}),
        };
        const tags = Array.isArray(incoming.tags) ? incoming.tags : [];
        return {
            // base
            ...incoming,
            // normalized defaults (single definitions; no duplicates)
            environment: incoming.environment ?? "dev",
            defaultFor,
            tags,
            encryptionAtRest: incoming.encryptionAtRest ?? false,
            compression: incoming.compression ?? "none",
        };
    }

    private sanitizeConfig(kind: StorageKind, config: Record<string, any> | null | undefined): Record<string, any> {
        const base = this.clone(config ?? {});
        if (kind === "s3") {
            if (!base.provider) base.provider = "aws";
            if (!base.region) base.region = "us-east-1";
            if (base.pathStyle === undefined) base.pathStyle = false;
            if (!base.sse) base.sse = "none";
        }
        if (kind === "nextcloud") {
            if (!base.path) base.path = "/Backups/RemoteIQ";
        }
        if (kind === "sftp") {
            if (!base.port) base.port = 22;
            if (!base.path) base.path = "/srv/remoteiq/backups";
        }
        return base;
    }

    private buildHasSecret(kind: StorageKind, secrets: SecretMap): StorageConnectionDto["hasSecret"] {
        const map: StorageConnectionDto["hasSecret"] = {};
        if (kind === "s3") {
            map.s3Credentials = Boolean(
                secrets.accessKeyId || secrets.secretAccessKey || secrets.roleArn,
            );
        }
        if (kind === "nextcloud") {
            map.nextcloudPassword = Boolean(secrets.password);
        }
        if (kind === "sftp") {
            map.sftpPassword = Boolean(secrets.password);
            map.sftpPrivateKey = Boolean(secrets.privateKeyPem);
        }
        return map;
    }

    private partitionSecrets(
        kind: StorageKind,
        configInput: Record<string, any>,
        existingSecrets: SecretMap = {},
    ): { config: Record<string, any>; secrets: SecretMap } {
        const config = this.clone(configInput ?? {});
        const secrets = { ...existingSecrets };

        const take = (key: string) => {
            if (!(key in config)) return;
            const value = config[key];
            if (value === undefined || value === null || value === "") {
                delete secrets[key];
            } else {
                secrets[key] = value;
            }
            delete config[key];
        };

        if (kind === "s3") {
            ["accessKeyId", "secretAccessKey", "roleArn", "externalId"].forEach(take);
        }
        if (kind === "nextcloud") {
            ["password"].forEach(take);
        }
        if (kind === "gdrive") {
            ["serviceAccountJson", "refreshToken", "clientSecret"].forEach(take);
        }
        if (kind === "sftp") {
            ["password", "privateKeyPem", "passphrase"].forEach(take);
        }

        return { config, secrets };
    }

    private rowToDto(row: StorageConnectionRow): StorageConnectionDto {
        const config = this.sanitizeConfig(row.kind, row.config);
        const meta = this.withDefaults(row.meta);
        const capabilities = { ...DEFAULT_CAPABILITIES, ...(row.capabilities ?? {}) };
        const health = { ...DEFAULT_HEALTH, ...(row.health ?? {}) };
        const secrets = row.secrets ?? {};
        const hasSecret = this.buildHasSecret(row.kind, secrets);

        return {
            id: row.id,
            name: row.name,
            kind: row.kind,
            config,
            meta,
            capabilities,
            health,
            hasSecret,
        };
    }

    private validatePayload(body: CreateUpdatePayload) {
        if (!body) throw new BadRequestException("Payload required");
        if (!body.name || typeof body.name !== "string" || !body.name.trim()) {
            throw new BadRequestException("Name is required");
        }
        this.ensureKind(body.kind);
        if (!body.config || typeof body.config !== "object") {
            throw new BadRequestException("Config object required");
        }

        if (body.kind === "s3") {
            if (!body.config.bucket || !String(body.config.bucket).trim()) {
                throw new BadRequestException("S3 bucket is required");
            }
            if (body.config.sse === "aws:kms" && !body.config.kmsKeyId) {
                throw new BadRequestException("KMS Key ID required for aws:kms");
            }
            if (body.config.sessionDurationSec) {
                const dur = Number(body.config.sessionDurationSec);
                if (!Number.isFinite(dur) || dur < 900 || dur > 43200) {
                    throw new BadRequestException(
                        "STS session duration must be between 900 and 43200 seconds",
                    );
                }
            }
        }

        if (body.kind === "nextcloud") {
            if (!body.config.webdavUrl || typeof body.config.webdavUrl !== "string") {
                throw new BadRequestException("Nextcloud WebDAV URL is required");
            }
            if (!body.config.username || !String(body.config.username).trim()) {
                throw new BadRequestException("Nextcloud username is required");
            }
            if (!body.config.path || !String(body.config.path).startsWith("/")) {
                throw new BadRequestException("Nextcloud folder path must start with '/'");
            }
        }

        if (body.kind === "gdrive") {
            if (!body.config.folderId || !String(body.config.folderId).trim()) {
                throw new BadRequestException("Google Drive folderId is required");
            }
        }

        if (body.kind === "sftp") {
            if (!body.config.host || !String(body.config.host).trim()) {
                throw new BadRequestException("SFTP host is required");
            }
            if (!body.config.username || !String(body.config.username).trim()) {
                throw new BadRequestException("SFTP username is required");
            }
            if (!body.config.path || !String(body.config.path).trim()) {
                throw new BadRequestException("SFTP path is required");
            }
        }
    }

    /* ----------------------------- queries ----------------------------- */

    async list(): Promise<{ items: StorageConnectionDto[] }> {
        const orgId = await this.orgId();
        const { rows } = await this.db.query<StorageConnectionRow>(
            `SELECT id, organization_id, name, kind, config, secrets, meta, capabilities, health
             FROM storage_connections
             WHERE organization_id = $1
             ORDER BY name ASC`,
            [orgId],
        );
        return { items: rows.map((row) => this.rowToDto(row)) };
    }

    async create(body: CreateUpdatePayload): Promise<{ id: string }> {
        this.validatePayload(body);
        const orgId = await this.orgId();
        const { config, secrets } = this.partitionSecrets(body.kind, body.config);
        const meta = this.withDefaults(body.meta ?? {});
        const capabilities = DEFAULT_CAPABILITIES;
        const health = DEFAULT_HEALTH;

        const result = await this.db.query<{ id: string }>(
            `INSERT INTO storage_connections (organization_id, name, kind, config, secrets, meta, capabilities, health)
             VALUES ($1, $2, $3, $4::jsonb, $5::jsonb, $6::jsonb, $7::jsonb, $8::jsonb)
             RETURNING id`,
            [
                orgId,
                body.name.trim(),
                body.kind,
                JSON.stringify(config),
                JSON.stringify(secrets),
                JSON.stringify(meta),
                JSON.stringify(capabilities),
                JSON.stringify(health),
            ],
        );

        return { id: result.rows[0].id };
    }

    async update(id: string, body: CreateUpdatePayload): Promise<void> {
        if (!id || id.length !== 36) throw new BadRequestException("Valid id required");
        this.validatePayload(body);
        const orgId = await this.orgId();

        const existing = await this.db.query<StorageConnectionRow>(
            `SELECT id, organization_id, name, kind, config, secrets, meta, capabilities, health
             FROM storage_connections
             WHERE id=$1 AND organization_id=$2`,
            [id, orgId],
        );
        const row = existing.rows[0];
        if (!row) throw new NotFoundException("Connection not found");

        this.ensureKind(body.kind);
        const { config, secrets } = this.partitionSecrets(body.kind, body.config, row.secrets ?? {});
        const meta = this.withDefaults(body.meta ?? {});

        await this.db.query(
            `UPDATE storage_connections
             SET name=$2,
                 kind=$3,
                 config=$4::jsonb,
                 secrets=$5::jsonb,
                 meta=$6::jsonb,
                 updated_at=NOW()
             WHERE id=$1 AND organization_id=$7`,
            [
                id,
                body.name.trim(),
                body.kind,
                JSON.stringify(config),
                JSON.stringify(secrets),
                JSON.stringify(meta),
                orgId,
            ],
        );
    }

    async delete(id: string): Promise<void> {
        if (!id || id.length !== 36) throw new BadRequestException("Valid id required");
        const orgId = await this.orgId();

        const deps = await this.getDependents(id);
        const inUse = deps.features.flatMap((f) => f.ids ?? []);
        if (inUse.length) {
            throw new BadRequestException("Connection still referenced by other features");
        }

        const result = await this.db.query<{ id: string }>(
            `DELETE FROM storage_connections
             WHERE id=$1 AND organization_id=$2
             RETURNING id`,
            [id, orgId],
        );
        if (!result.rows.length) throw new NotFoundException("Connection not found");
    }

    async getDependents(id: string): Promise<{ features: { name: string; ids: string[] }[] }> {
        const orgId = await this.orgId();
        const deps: { name: string; ids: string[] }[] = [];

        const policies = await this.db.query<{ id: string }>(
            `SELECT id
             FROM backup_destinations
             WHERE organization_id=$1 AND configuration ->> 'connectionId' = $2`,
            [orgId, id],
        );
        if (policies.rows.length) {
            deps.push({ name: "backup_destinations", ids: policies.rows.map((r) => r.id) });
        }

        return { features: deps };
    }

    /**
     * Real connection test.
     * Uses only the provided body.config (does not persist anything).
     * Returns per-phase booleans so the UI can show where it failed.
     */
    async test(body: { kind: StorageKind; config: Record<string, any> }): Promise<{ ok: boolean; phases: Record<string, boolean> }> {
        this.ensureKind(body.kind);
        this.validatePayload({ name: "test", kind: body.kind, config: body.config });

        if (body.kind === "s3") {
            // Try to write/read/delete a small object
            const bucket = body.config.bucket;
            const prefix = (body.config.prefix || "").replace(/^\/+|\/+$/g, "");
            const key = (prefix ? `${prefix}/` : "") + `.remoteiq_probe_${Date.now()}.txt`;
            const secret = {
                region: body.config.region,
                endpoint: body.config.endpoint,
                accessKeyId: body.config.accessKeyId,
                secretAccessKey: body.config.secretAccessKey,
                forcePathStyle: !!body.config.pathStyle,
            };
            await s3PutObject(secret, bucket, key, Buffer.from("probe"));
            const head = await s3Head(secret, bucket, key);
            const ok = !!head;
            await s3Delete(secret, bucket, key);
            return { ok, phases: { validate: true, write: true, read: ok, delete: true } };
        }

        if (body.kind === "nextcloud") {
            const phases = await webdavProbe({
                url: body.config.webdavUrl,
                username: body.config.username,
                password: body.config.password,
                path: body.config.path,
            });
            return { ok: phases.write && phases.read && phases.delete, phases: { validate: true, ...phases } };
        }

        if (body.kind === "sftp") {
            const phases = await sftpProbe({
                host: body.config.host,
                port: body.config.port ?? 22,
                username: body.config.username,
                password: body.config.password,
                privateKey: body.config.privateKeyPem,
                passphrase: body.config.passphrase,
                testPath: body.config.path,
            });
            return { ok: phases.write && phases.read && phases.delete, phases: { validate: true, ...phases } };
        }

        // gdrive test still handled from backups.service (needs server-managed secrets)
        return { ok: true, phases: { validate: true, connect: true } };
    }

    async browseNextcloud(body: { config: Record<string, any>; path: string }): Promise<{ ok: boolean; dirs: string[] }> {
        if (!body?.path || !String(body.path).startsWith("/")) {
            throw new BadRequestException("Path must start with '/'");
        }
        if (!body.config?.webdavUrl) {
            throw new BadRequestException("webdavUrl required");
        }
        const dirs = await webdavListDirs({
            url: body.config.webdavUrl,
            username: body.config.username,
            password: body.config.password,
            basePath: body.path,
        });
        return { ok: true, dirs };
    }
}








----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/storage/storage.module.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\storage\storage.module.ts
Size: 0.85 KB
LastWriteTime: 2025-11-06 17:36:57

----- BEGIN CONTENT -----
//backend\src\storage\storage.module.ts

import { Module } from "@nestjs/common";
import { Reflector } from "@nestjs/core";
import { PermissionsGuard } from "../auth/permissions.guard";
import { PgBootstrap } from "./pg.bootstrap";
import { OrganizationContextService } from "./organization-context.service";
import { PgPoolService } from "./pg-pool.service";
import { StorageConnectionsService } from "./storage-connections.service";
import { StorageController } from "./storage.controller";

@Module({
    controllers: [StorageController],
    providers: [
        PgPoolService,
        PgBootstrap,
        OrganizationContextService,
        StorageConnectionsService,
        PermissionsGuard,
        Reflector,
    ],
    exports: [PgPoolService, OrganizationContextService, StorageConnectionsService],
})
export class StorageModule { }

----- END CONTENT -----


====================================================================================================
=  FRONTEND (must-have)
====================================================================================================


====================================================================================================
=  FILE: remoteiq-frontend/app/administration/tabs/StorageTab.tsx
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-frontend\app\administration\tabs\StorageTab.tsx
Size: 78.1 KB
LastWriteTime: 2025-11-05 16:48:49

----- BEGIN CONTENT -----
/* remoteiq-frontend/app/administration/tabs/StorageTab.tsx */
"use client";

import * as React from "react";
import {
    Card,
    CardHeader,
    CardTitle,
    CardDescription,
    CardContent,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { TabsContent } from "@/components/ui/tabs";
import {
    Select,
    SelectTrigger,
    SelectValue,
    SelectContent,
    SelectItem,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import {
    Cloud,
    Plus,
    Save,
    Trash2,
    RefreshCcw,
    Cable,
    Database,
    Copy,
    Upload,
    Download as DownloadIcon,
    ShieldCheck,
    AlertTriangle,
} from "lucide-react";
import { LabeledInput, LabeledNumber, CheckToggle } from "../helpers";
import { jfetch } from "@/lib/api";
import { useToast } from "@/components/ui/use-toast";
import { Skeleton } from "@/components/ui/skeleton";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from "@/components/ui/alert-dialog";

import {
    listStorageConnections,
    type StorageConnection,
    type S3ConnConfig,
    type NextcloudConnConfig,
    type GDriveConnConfig,
    type SftpConnConfig,
    type DependentsResp,
} from "@/lib/storage";

// --- Toast helper: auto-dismiss + (optional) dedupe by id ---
type ToastOpts = Parameters<ReturnType<typeof useToast>["toast"]>[0];
function toastWithDefaults(
    t: ReturnType<typeof useToast>["toast"],
    opts: ToastOpts
) {
    t({ duration: 6000, ...opts } as any); // 6s default
}

/* ----------------------------- Local type aliases (no conflicts) ----------------------------- */
type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";
type Env = "dev" | "staging" | "prod";

/* ----------------------------- Helpers ----------------------------- */
function looksLikeUrl(u: string) {
    try {
        const url = new URL(u);
        return !!url.protocol && !!url.host;
    } catch {
        return false;
    }
}
function isAbsPath(p: string) {
    return p.startsWith("/") || /^[A-Za-z]:\\/.test(p);
}
function toCsv(arr?: string[]) {
    return (arr ?? []).join(", ");
}
function fromCsv(s: string) {
    return s
        .split(",")
        .map((x) => x.trim())
        .filter(Boolean);
}

/* ----------------------------- Component ----------------------------- */
export default function StorageTab() {
    const { toast } = useToast();

    /* Prevent StrictMode double-invoke in dev from firing refresh() twice */
    const didInitRef = React.useRef(false);

    const [loading, setLoading] = React.useState(true);
    const [saving, setSaving] = React.useState(false);
    const [testing, setTesting] = React.useState(false);
    const [browsing, setBrowsing] = React.useState<null | "nextcloud">(null);

    const [connections, setConnections] = React.useState<StorageConnection[]>([]);
    const [selectedId, setSelectedId] = React.useState<string | null>(null);

    /* delete confirm */
    const [confirmDeleteOpen, setConfirmDeleteOpen] = React.useState(false);

    /* last validation errors for inline display */
    const [errors, setErrors] = React.useState<string[]>([]);

    const [draft, setDraft] = React.useState<StorageConnection>({
        id: "",
        name: "",
        kind: "s3",
        config: {
            provider: "aws",
            region: "us-east-1",
            bucket: "",
            prefix: "",
            pathStyle: false,
            sse: "none",
        } as S3ConnConfig,
        meta: {
            environment: "dev",
            tags: [],
            defaultFor: { backups: false, exports: false, artifacts: false },
            encryptionAtRest: false,
            compression: "none",
        },
        capabilities: {
            canUse: true,
            canEdit: true,
            canRotate: true,
            canDelete: true,
        },
        health: { status: "unknown" },
    });

    const selected = React.useMemo(
        () => connections.find((c) => c.id === selectedId) ?? null,
        [connections, selectedId]
    );

    const refresh = React.useCallback(async () => {
        setLoading(true);
        try {
            const { items } = await listStorageConnections();
            const list = items ?? [];
            setConnections(list);
            setSelectedId((prev) => prev ?? (list[0]?.id ?? null));
        } catch (err: any) {
            setConnections([]);
            setSelectedId(null);
            toastWithDefaults(toast, {
                id: "storage-unreachable",
                title: "Storage API unreachable",
                description:
                    err?.message ?? "Could not load connections. Check backend URL / auth.",
                variant: "destructive",
                kind: "destructive",
            });
        } finally {
            setLoading(false);
        }
    }, [toast]);

    React.useEffect(() => {
        if (didInitRef.current) return; // prevents StrictMode double call
        didInitRef.current = true;
        refresh();
    }, [refresh]);

    React.useEffect(() => {
        if (!selected) return;
        const cfg = { ...(selected.config as any) };
        if (selected.kind === "nextcloud") cfg.password = "";
        if (selected.kind === "sftp") {
            cfg.password = "";
            cfg.privateKeyPem = "";
            cfg.passphrase = "";
        }
        if (selected.kind === "s3") {
            cfg.accessKeyId = "";
            cfg.secretAccessKey = "";
        }

        setDraft({
            id: selected.id,
            name: selected.name,
            kind: selected.kind,
            config: cfg,
            meta:
                selected.meta ?? {
                    environment: "dev",
                    tags: [],
                    defaultFor: { backups: false, exports: false, artifacts: false },
                    encryptionAtRest: false,
                    compression: "none",
                },
            capabilities:
                selected.capabilities ?? {
                    canUse: true,
                    canEdit: true,
                    canRotate: true,
                    canDelete: true,
                },
            health: selected.health ?? { status: "unknown" },
            hasSecret: selected.hasSecret,
        });
        setErrors([]);
    }, [selected]);

    function resetToNew(kind: StorageKind = "s3") {
        setSelectedId(null);
        const base: StorageConnection = {
            id: "",
            name: "",
            kind,
            config: {} as any,
            meta: {
                environment: "dev",
                tags: [],
                defaultFor: { backups: false, exports: false, artifacts: false },
                encryptionAtRest: false,
                compression: "none",
            },
            capabilities: {
                canUse: true,
                canEdit: true,
                canRotate: true,
                canDelete: true,
            },
            health: { status: "unknown" },
        };
        if (kind === "s3") {
            base.config = {
                provider: "aws",
                region: "us-east-1",
                bucket: "",
                prefix: "",
                pathStyle: false,
                sse: "none",
                kmsKeyId: "",
                accessKeyId: "",
                secretAccessKey: "",
                roleArn: "",
                externalId: "",
                sessionDurationSec: 3600,
            } as S3ConnConfig;
        } else if (kind === "nextcloud") {
            base.config = {
                webdavUrl: "",
                username: "",
                password: "",
                path: "/Backups/RemoteIQ",
            } as NextcloudConnConfig;
        } else if (kind === "gdrive") {
            base.config = {
                folderId: "",
                accountEmail: "",
                authMode: undefined,
            } as GDriveConnConfig;
        } else {
            base.config = {
                host: "",
                port: 22,
                username: "",
                password: "",
                privateKeyPem: "",
                passphrase: "",
                hostKeyFingerprint: "",
                path: "/srv/remoteiq/backups",
            } as SftpConnConfig;
        }
        setDraft(base);
        setErrors([]);
    }

    function validate(): string[] {
        const errs: string[] = [];
        if (!draft.name.trim()) errs.push("Name is required.");
        if (draft.kind === "s3") {
            const c = draft.config as S3ConnConfig;
            if (!c.bucket?.trim()) errs.push("S3 bucket is required.");
            if (c.sse === "aws:kms" && !c.kmsKeyId?.trim())
                errs.push("KMS Key ID is required for aws:kms.");
            if (
                c.sessionDurationSec &&
                (c.sessionDurationSec < 900 || c.sessionDurationSec > 43200)
            ) {
                errs.push("STS session duration must be between 900 and 43200 seconds.");
            }
        }
        if (draft.kind === "nextcloud") {
            const c = draft.config as NextcloudConnConfig;
            if (!looksLikeUrl(c.webdavUrl || "")) errs.push("WebDAV URL looks invalid.");
            if (!c.username?.trim()) errs.push("Nextcloud username is required.");
            if (!c.path?.trim() || !c.path.startsWith("/"))
                errs.push("Nextcloud folder path must start with '/'.");
        }
        if (draft.kind === "gdrive") {
            const c = draft.config as GDriveConnConfig;
            if (!c.folderId?.trim()) errs.push("Google Drive Folder ID is required.");
        }
        if (draft.kind === "sftp") {
            const c = draft.config as SftpConnConfig;
            if (!c.host?.trim()) errs.push("SFTP host is required.");
            if (!c.username?.trim()) errs.push("SFTP username is required.");
            if (!c.path?.trim() || !isAbsPath(c.path))
                errs.push("SFTP path must be an absolute path.");
            if (c.privateKeyPem && c.privateKeyPem.length < 64)
                errs.push("SFTP private key looks too short.");
            if (
                c.hostKeyFingerprint &&
                !/^SHA256:[A-Za-z0-9+/=]+$/.test(c.hostKeyFingerprint)
            ) {
                errs.push("Host key fingerprint must look like 'SHA256:xxxx'.");
            }
        }
        return errs;
    }

    /* prevent editing when !canEdit without needing readOnly props on helpers */
    const canEdit = draft.capabilities?.canEdit !== false;
    const canDelete = draft.capabilities?.canDelete !== false;
    const onIfEditable =
        <T,>(fn: (v: T) => void) =>
            (v: T) => {
                if (canEdit) fn(v);
            };

    async function saveDraft(asCopy = false) {
        const errs = validate();
        setErrors(errs);
        if (errs.length) {
            errs.forEach((e) =>
                toast({
                    title: e,
                    variant: "destructive",
                    kind: "destructive",
                })
            );
            return;
        }
        setSaving(true);
        try {
            const cfg: any = { ...(draft.config as any) };
            if (draft.kind === "nextcloud" && !cfg.password) delete cfg.password;
            if (draft.kind === "sftp") {
                if (!cfg.password) delete cfg.password;
                if (!cfg.privateKeyPem) delete cfg.privateKeyPem;
                if (!cfg.passphrase) delete cfg.passphrase;
            }
            if (draft.kind === "s3") {
                if (!cfg.accessKeyId) delete cfg.accessKeyId;
                if (!cfg.secretAccessKey) delete cfg.secretAccessKey;
                if (!cfg.roleArn) delete cfg.roleArn;
                if (!cfg.externalId) delete cfg.externalId;
                if (!cfg.sessionDurationSec) delete cfg.sessionDurationSec;
            }

            const payload = {
                id: asCopy ? undefined : draft.id || undefined,
                name: asCopy ? `${draft.name} (copy)` : draft.name.trim(),
                kind: draft.kind,
                config: cfg,
                meta: draft.meta,
            };

            const path =
                !asCopy && draft.id
                    ? `/api/admin/storage/connections/${draft.id}`
                    : "/api/admin/storage/connections";
            await jfetch(path, {
                method: !asCopy && draft.id ? "PUT" : "POST",
                headers: { "Content-Type": "application/json" },
                body: payload,
            });

            toast({
                title: asCopy ? "Connection duplicated" : "Connection saved",
                variant: "success",
                kind: "success",
            });
            await refresh();

            setDraft((d) => {
                const clean = { ...d };
                if (clean.kind === "nextcloud")
                    (clean.config as NextcloudConnConfig).password = "";
                if (clean.kind === "sftp") {
                    (clean.config as SftpConnConfig).password = "";
                    (clean.config as SftpConnConfig).privateKeyPem = "";
                    (clean.config as SftpConnConfig).passphrase = "";
                }
                if (clean.kind === "s3") {
                    (clean.config as S3ConnConfig).accessKeyId = "";
                    (clean.config as S3ConnConfig).secretAccessKey = "";
                }
                return clean;
            });
            setErrors([]);
        } catch (e: any) {
            toast({
                title: e?.message ?? "Save failed",
                variant: "destructive",
                kind: "destructive",
            });
        } finally {
            setSaving(false);
        }
    }

    async function testDraft() {
        const errs = validate();
        setErrors(errs);
        if (errs.length) {
            errs.forEach((e) =>
                toast({
                    title: e,
                    variant: "destructive",
                    kind: "destructive",
                })
            );
            return;
        }
        setTesting(true);
        try {
            const cfg: any = { ...(draft.config as any) };
            if (draft.kind === "nextcloud" && !cfg.password) delete cfg.password;
            if (draft.kind === "sftp") {
                if (!cfg.password) delete cfg.password;
                if (!cfg.privateKeyPem) delete cfg.privateKeyPem;
                if (!cfg.passphrase) delete cfg.passphrase;
            }
            if (draft.kind === "s3") {
                if (!cfg.accessKeyId) delete cfg.accessKeyId;
                if (!cfg.secretAccessKey) delete cfg.secretAccessKey;
            }

            const res = await jfetch<{
                ok: boolean;
                phases?: Record<string, boolean>;
                detail?: string;
            }>("/api/admin/storage/test", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: {
                    kind: draft.kind,
                    config: cfg,
                    meta: draft.meta,
                    probe: "write-read-delete",
                },
            });
            const detail = res?.phases
                ? ` (${Object.entries(res.phases)
                    .map(([k, v]) => `${k}:${v ? "ok" : "fail"}`)
                    .join(", ")})`
                : res?.detail || "";
            toast({
                title: res?.ok ? "Connection healthy" : "Connection check failed",
                description: detail,
                variant: res?.ok ? "success" : "destructive",
                kind: res?.ok ? "success" : "destructive",
            });
            refresh();
        } catch (e: any) {
            toast({
                title: e?.message ?? "Test failed",
                variant: "destructive",
                kind: "destructive",
            });
        } finally {
            setTesting(false);
        }
    }

    async function removeSelected() {
        if (!selected) return;
        try {
            let deps: DependentsResp | null = null;
            try {
                deps = await jfetch<DependentsResp>(
                    `/api/admin/storage/connections/${selected.id}/dependents`
                );
            } catch { }
            const used = (deps?.features ?? []).filter((f) => (f.ids?.length ?? 0) > 0);
            if (used.length > 0) {
                const lines = used
                    .map(
                        (f) => `${f.name}${f.ids && f.ids.length ? ` (${f.ids.length})` : ""}`
                    )
                    .join(", ");
                toast({
                    title: "Cannot delete: connection in use",
                    description: `Remove usages first: ${lines}`,
                    variant: "destructive",
                    kind: "destructive",
                });
                return;
            }
            await jfetch(`/api/admin/storage/connections/${selected.id}`, {
                method: "DELETE",
            });
            toast({
                title: "Connection deleted",
                variant: "default",
                kind: "default",
            });
            await refresh();
            setSelectedId((prev) => {
                const list = connections.filter((c) => c.id !== selected.id);
                return list[0]?.id ?? null;
            });
        } catch (e: any) {
            toast({
                title: e?.message ?? "Delete failed",
                variant: "destructive",
                kind: "destructive",
            });
        }
    }

    function exportJson() {
        const out = { ...draft, config: { ...(draft.config as any) } };
        if (out.kind === "nextcloud") delete (out.config as any).password;
        if (out.kind === "sftp") {
            delete (out.config as any).password;
            delete (out.config as any).privateKeyPem;
            delete (out.config as any).passphrase;
        }
        if (out.kind === "s3") {
            delete (out.config as any).accessKeyId;
            delete (out.config as any).secretAccessKey;
        }
        const blob = new Blob([JSON.stringify(out, null, 2)], {
            type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${draft.name || "connection"}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }
    function importFile(e: React.ChangeEvent<HTMLInputElement>) {
        const file = e.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            try {
                const obj = JSON.parse(String(reader.result));
                if (obj.kind === "nextcloud" && obj.config) obj.config.password = "";
                if (obj.kind === "sftp" && obj.config) {
                    obj.config.password = "";
                    obj.config.privateKeyPem = "";
                    obj.config.passphrase = "";
                }
                if (obj.kind === "s3" && obj.config) {
                    obj.config.accessKeyId = "";
                    obj.config.secretAccessKey = "";
                }
                setDraft(obj);
                setErrors([]);
                toast({
                    title: "Imported",
                    variant: "success",
                    kind: "success",
                });
            } catch (err: any) {
                toast({
                    title: "Invalid JSON",
                    description: err?.message,
                    variant: "destructive",
                    kind: "destructive",
                });
            }
        };
        reader.readAsText(file);
        e.currentTarget.value = "";
    }

    async function browseNextcloud() {
        if (draft.kind !== "nextcloud") return;
        setBrowsing("nextcloud");
        try {
            const cfg: any = { ...(draft.config as any) };
            if (!cfg.password) delete cfg.password;
            const res = await jfetch<{
                ok: boolean;
                dirs?: string[];
                error?: string;
            }>("/api/admin/storage/browse", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: {
                    kind: "nextcloud",
                    config: cfg,
                    path: (draft.config as NextcloudConnConfig).path || "/",
                },
            });
            const dirs = res?.dirs ?? [];
            setDraft((d) => ({
                ...d,
                config: { ...(d.config as NextcloudConnConfig), _browse: dirs },
            }));
            if (!res?.ok) throw new Error(res?.error || "Browse failed");
        } catch (e: any) {
            toast({
                title: e?.message ?? "Browse failed",
                variant: "destructive",
                kind: "destructive",
            });
        } finally {
            setBrowsing(null);
        }
    }

    const healthColor =
        draft.health?.status === "healthy"
            ? "bg-emerald-500"
            : draft.health?.status === "unhealthy"
                ? "bg-red-500"
                : "bg-zinc-400";

    const hasBlockingErrors = errors.length > 0;

    return (
        <TabsContent value="storage" className="mt-0">
            <Card>
                <CardHeader>
                    <CardTitle className="flex items-center gap-2">
                        <Cloud className="h-5 w-5" />
                        Storage
                        <Badge variant="secondary" className="ml-1">
                            Connections
                        </Badge>
                        <span
                            className={`inline-block h-2 w-2 rounded-full ${healthColor}`}
                            title={`Health: ${draft.health?.status || "unknown"}`}
                        />
                        <span className="text-xs text-muted-foreground">
                            {draft.health?.lastCheckedAt
                                ? `Last checked: ${(draft.health.lastCheckedAt || "")
                                    .replace("T", " ")
                                    .slice(0, 16)}`
                                : "Not checked"}
                        </span>
                        {draft.health?.lastResult && (
                            <span className="text-xs text-muted-foreground">
                                · {draft.health.lastResult}
                            </span>
                        )}
                    </CardTitle>
                    <CardDescription>
                        Define reusable storage connections. Backups/Exports/Artifacts
                        reference a connection by name so credentials remain centralized and
                        secure.
                    </CardDescription>
                </CardHeader>

                {/* More breathing room */}
                <CardContent className="space-y-8">
                    {/* Global validation callout (if any) */}
                    {errors.length > 0 && (
                        <div className="rounded-md border border-red-300/60 bg-red-50/40 p-3 text-sm text-red-700 dark:border-red-900/50 dark:bg-red-950/30 dark:text-red-300">
                            <div className="font-medium mb-1">Please fix the following:</div>
                            <ul className="list-disc ml-5 space-y-0.5">
                                {errors.map((e, i) => (
                                    <li key={i}>{e}</li>
                                ))}
                            </ul>
                        </div>
                    )}

                    {/* Connections row */}
                    <div className="rounded-md border p-4 space-y-4 bg-muted/30">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <Database className="h-4 w-4" />
                                <div className="font-medium">Connections</div>
                            </div>
                            <div className="flex items-center gap-2">
                                <Button
                                    type="button"
                                    variant="outline"
                                    size="sm"
                                    onClick={() => refresh()}
                                >
                                    <RefreshCcw className="h-4 w-4 mr-2" /> Refresh
                                </Button>
                                <Button
                                    type="button"
                                    size="sm"
                                    onClick={() => resetToNew("s3")}
                                    disabled={!canEdit}
                                >
                                    <Plus className="h-4 w-4 mr-2" /> New
                                </Button>
                                <Button
                                    type="button"
                                    size="sm"
                                    variant="outline"
                                    onClick={() => saveDraft(true)}
                                    disabled={!canEdit}
                                >
                                    <Copy className="h-4 w-4 mr-2" /> Save as copy
                                </Button>
                                <Button
                                    type="button"
                                    size="sm"
                                    variant="outline"
                                    onClick={exportJson}
                                >
                                    <DownloadIcon className="h-4 w-4 mr-2" /> Export JSON
                                </Button>
                                <label
                                    className={`inline-flex items-center gap-2 text-sm px-3 py-2 rounded-md border ${canEdit ? "cursor-pointer" : "opacity-60 cursor-not-allowed"
                                        }`}
                                >
                                    <Upload className="h-4 w-4" />
                                    Import JSON
                                    <input
                                        type="file"
                                        accept="application/json"
                                        onChange={canEdit ? importFile : undefined}
                                        className="hidden"
                                        disabled={!canEdit}
                                    />
                                </label>
                            </div>
                        </div>

                        <div className="grid gap-4 md:grid-cols-12 items-start">
                            {/* Left cluster */}
                            <div className="md:col-span-9">
                                <div className="grid gap-3 md:grid-cols-12 items-start">
                                    {/* Edit existing */}
                                    <div className="md:col-span-4 self-start">
                                        <Label className="text-sm">Edit existing connection</Label>
                                        {loading ? (
                                            <Skeleton className="h-9 w-full" />
                                        ) : (
                                            <Select
                                                value={selectedId ?? ""}
                                                onValueChange={onIfEditable<string | "">((v) =>
                                                    setSelectedId(v || null)
                                                )}
                                            >
                                                <SelectTrigger>
                                                    <SelectValue
                                                        placeholder={
                                                            connections.length
                                                                ? "Choose to edit…"
                                                                : "No connections yet"
                                                        }
                                                    />
                                                </SelectTrigger>
                                                <SelectContent>
                                                    {connections.map((c) => (
                                                        <SelectItem key={c.id} value={c.id}>
                                                            {c.name}{" "}
                                                            <span className="text-muted-foreground">· {c.kind}</span>
                                                        </SelectItem>
                                                    ))}
                                                    {connections.length === 0 && (
                                                        <SelectItem value="__none" disabled>
                                                            No connections
                                                        </SelectItem>
                                                    )}
                                                </SelectContent>
                                            </Select>
                                        )}
                                    </div>

                                    {/* Kind */}
                                    <div className="md:col-span-4 self-start">
                                        <Label className="text-sm">Kind</Label>
                                        <Select
                                            value={draft.kind}
                                            onValueChange={onIfEditable<StorageKind>((v) => resetToNew(v))}
                                        >
                                            <SelectTrigger>
                                                <SelectValue placeholder="Select kind" />
                                            </SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="s3">S3 / MinIO</SelectItem>
                                                <SelectItem value="nextcloud">Nextcloud (WebDAV)</SelectItem>
                                                <SelectItem value="gdrive">Google Drive</SelectItem>
                                                <SelectItem value="sftp">Remote SFTP</SelectItem>
                                            </SelectContent>
                                        </Select>
                                    </div>

                                    {/* Name */}
                                    <div className="md:col-span-4 self-start">
                                        <LabeledInput
                                            label="Name"
                                            value={draft.name}
                                            onChange={onIfEditable<string>((v) =>
                                                setDraft((d) => ({ ...d, name: v }))
                                            )}
                                            placeholder="e.g. Prod S3, Offsite Nextcloud"
                                        />
                                    </div>

                                    {/* Env */}
                                    <div className="md:col-span-4 self-start">
                                        <Label className="text-sm">Environment</Label>
                                        <Select
                                            value={draft.meta?.environment ?? "dev"}
                                            onValueChange={onIfEditable<Env>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: { ...(d.meta || {}), environment: v },
                                                }))
                                            )}
                                        >
                                            <SelectTrigger>
                                                <SelectValue />
                                            </SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="dev">Dev</SelectItem>
                                                <SelectItem value="staging">Staging</SelectItem>
                                                <SelectItem value="prod">Prod</SelectItem>
                                            </SelectContent>
                                        </Select>
                                    </div>

                                    {/* Tags */}
                                    <div className="md:col-span-8 self-start">
                                        <LabeledInput
                                            label="Tags (comma-separated)"
                                            value={toCsv(draft.meta?.tags)}
                                            onChange={onIfEditable<string>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: { ...(d.meta || {}), tags: fromCsv(v) },
                                                }))
                                            )}
                                            placeholder="backup, offsite, cost-optimized"
                                        />
                                    </div>

                                    {/* Helper text row */}
                                    <div className="md:col-span-12">
                                        <p className="text-xs text-muted-foreground">
                                            Backups choose a connection in the{" "}
                                            <span className="font-medium">Backups</span> tab. This
                                            selector is only for editing/testing saved connections.
                                        </p>
                                    </div>
                                </div>
                            </div>

                            {/* Defaults panel */}
                            <div className="md:col-span-3 md:self-stretch">
                                <div className="rounded-md border p-3 h-full">
                                    <div className="text-xs font-medium uppercase text-muted-foreground tracking-wide">
                                        Defaults
                                    </div>
                                    <div className="mt-2 space-y-2">
                                        <CheckToggle
                                            label="Default for Backups"
                                            checked={!!draft.meta?.defaultFor?.backups}
                                            onChange={onIfEditable<boolean>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: {
                                                        ...(d.meta || {}),
                                                        defaultFor: {
                                                            ...(d.meta?.defaultFor || {}),
                                                            backups: v,
                                                        },
                                                    },
                                                }))
                                            )}
                                        />
                                        <CheckToggle
                                            label="Default for Exports"
                                            checked={!!draft.meta?.defaultFor?.exports}
                                            onChange={onIfEditable<boolean>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: {
                                                        ...(d.meta || {}),
                                                        defaultFor: {
                                                            ...(d.meta?.defaultFor || {}),
                                                            exports: v,
                                                        },
                                                    },
                                                }))
                                            )}
                                        />
                                        <CheckToggle
                                            label="Default for Artifacts"
                                            checked={!!draft.meta?.defaultFor?.artifacts}
                                            onChange={onIfEditable<boolean>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    meta: {
                                                        ...(d.meta || {}),
                                                        defaultFor: {
                                                            ...(d.meta?.defaultFor || {}),
                                                            artifacts: v,
                                                        },
                                                    },
                                                }))
                                            )}
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Per-kind form in a soft panel */}
                    <div className="rounded-md border p-4 bg-muted/20 space-y-6">
                        {draft.kind === "s3" && (
                            <div className="space-y-6">
                                <div className="grid gap-4 md:grid-cols-3">
                                    <div className="grid gap-1">
                                        <Label className="text-sm">Provider</Label>
                                        <Select
                                            value={(draft.config as S3ConnConfig)?.provider ?? "aws"}
                                            onValueChange={onIfEditable<"aws" | "minio" | "wasabi" | "other">(
                                                (v) =>
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: { ...(d.config as S3ConnConfig), provider: v },
                                                    }))
                                            )}
                                        >
                                            <SelectTrigger>
                                                <SelectValue />
                                            </SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="aws">AWS S3</SelectItem>
                                                <SelectItem value="minio">MinIO</SelectItem>
                                                <SelectItem value="wasabi">Wasabi</SelectItem>
                                                <SelectItem value="other">Other</SelectItem>
                                            </SelectContent>
                                        </Select>
                                    </div>

                                    <LabeledInput
                                        label="Region"
                                        value={(draft.config as S3ConnConfig)?.region ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), region: v },
                                            }))
                                        )}
                                    />
                                    <div className="grid gap-1">
                                        <LabeledInput
                                            label="Bucket"
                                            value={(draft.config as S3ConnConfig)?.bucket ?? ""}
                                            onChange={onIfEditable<string>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    config: { ...(d.config as S3ConnConfig), bucket: v },
                                                }))
                                            )}
                                        />
                                        {!errors.length &&
                                            !((draft.config as S3ConnConfig)?.bucket ?? "").trim() && (
                                                <span className="text-[11px] text-muted-foreground">
                                                    Required for S3 connections.
                                                </span>
                                            )}
                                    </div>
                                    <LabeledInput
                                        label="Endpoint (MinIO/Other)"
                                        value={(draft.config as S3ConnConfig)?.endpoint ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), endpoint: v },
                                            }))
                                        )}
                                    />
                                    <LabeledInput
                                        label="Key prefix (optional)"
                                        value={(draft.config as S3ConnConfig)?.prefix ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), prefix: v },
                                            }))
                                        )}
                                    />
                                    <div className="flex items-center gap-4 mt-6">
                                        <CheckToggle
                                            label="Path-style access"
                                            checked={!!(draft.config as S3ConnConfig)?.pathStyle}
                                            onChange={onIfEditable<boolean>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    config: { ...(d.config as S3ConnConfig), pathStyle: v },
                                                }))
                                            )}
                                        />
                                    </div>
                                </div>

                                <Separator />

                                <div className="grid gap-4 md:grid-cols-3">
                                    <div className="grid gap-1">
                                        <Label className="text-sm">Server-side encryption</Label>
                                        <Select
                                            value={((draft.config as S3ConnConfig)?.sse as any) ?? "none"}
                                            onValueChange={onIfEditable<"none" | "AES256" | "aws:kms">(
                                                (v) =>
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: { ...(d.config as S3ConnConfig), sse: v },
                                                    }))
                                            )}
                                        >
                                            <SelectTrigger>
                                                <SelectValue />
                                            </SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="none">None</SelectItem>
                                                <SelectItem value="AES256">AES256</SelectItem>
                                                <SelectItem value="aws:kms">AWS KMS</SelectItem>
                                            </SelectContent>
                                        </Select>
                                    </div>
                                    {(draft.config as S3ConnConfig)?.sse === "aws:kms" && (
                                        <div className="grid gap-1">
                                            <LabeledInput
                                                label="KMS Key ID (ARN)"
                                                value={(draft.config as S3ConnConfig)?.kmsKeyId ?? ""}
                                                onChange={onIfEditable<string>((v) =>
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: { ...(d.config as S3ConnConfig), kmsKeyId: v },
                                                    }))
                                                )}
                                            />
                                            {!errors.length &&
                                                (draft.config as S3ConnConfig)?.sse === "aws:kms" &&
                                                !((draft.config as S3ConnConfig)?.kmsKeyId ?? "").trim() && (
                                                    <span className="text-[11px] text-muted-foreground">
                                                        Required when using AWS KMS.
                                                    </span>
                                                )}
                                        </div>
                                    )}
                                </div>

                                <Separator />

                                <div className="grid gap-4 md:grid-cols-3">
                                    <LabeledInput
                                        label="Access Key ID (optional)"
                                        value={(draft.config as S3ConnConfig)?.accessKeyId ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), accessKeyId: v },
                                            }))
                                        )}
                                        placeholder={draft.hasSecret?.s3Credentials ? "•••••••• (set)" : ""}
                                    />
                                    <LabeledInput
                                        label="Secret Access Key (optional)"
                                        type="password"
                                        value={(draft.config as S3ConnConfig)?.secretAccessKey ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as S3ConnConfig),
                                                    secretAccessKey: v,
                                                },
                                            }))
                                        )}
                                        placeholder={draft.hasSecret?.s3Credentials ? "•••••••• (set)" : ""}
                                    />
                                    <LabeledInput
                                        label="Assume Role ARN (optional)"
                                        value={(draft.config as S3ConnConfig)?.roleArn ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), roleArn: v },
                                            }))
                                        )}
                                        placeholder="arn:aws:iam::123456789012:role/RemoteIQBackupRole"
                                    />
                                    <LabeledInput
                                        label="External ID (optional)"
                                        value={(draft.config as S3ConnConfig)?.externalId ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as S3ConnConfig), externalId: v },
                                            }))
                                        )}
                                    />
                                    <LabeledNumber
                                        label="STS Session Duration (sec)"
                                        value={(draft.config as S3ConnConfig)?.sessionDurationSec ?? 3600}
                                        onChange={onIfEditable<string | number>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as S3ConnConfig),
                                                    sessionDurationSec: v === "" ? 3600 : Number(v),
                                                },
                                            }))
                                        )}
                                    />
                                </div>

                                {(draft.config as S3ConnConfig)?.bucketLifecycleSummary && (
                                    <div className="flex items-center gap-2 text-xs text-muted-foreground">
                                        <ShieldCheck className="h-3.5 w-3.5" />
                                        Lifecycle: {(draft.config as S3ConnConfig).bucketLifecycleSummary}
                                    </div>
                                )}
                            </div>
                        )}

                        {draft.kind === "nextcloud" && (
                            <div className="space-y-4">
                                <div className="grid gap-4 md:grid-cols-3">
                                    <LabeledInput
                                        label="WebDAV URL"
                                        value={(draft.config as NextcloudConnConfig)?.webdavUrl ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as NextcloudConnConfig),
                                                    webdavUrl: v,
                                                },
                                            }))
                                        )}
                                        placeholder="https:/*cloud.example.com/remote.php/dav/files/username/"
                                    />
                                    <LabeledInput
                                        label="Username"
                                        value={(draft.config as NextcloudConnConfig)?.username ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as NextcloudConnConfig),
                                                    username: v,
                                                },
                                            }))
                                        )}
                                    />
                                    <LabeledInput
                                        label="Password"
                                        type="password"
                                        value={(draft.config as NextcloudConnConfig)?.password ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as NextcloudConnConfig),
                                                    password: v,
                                                },
                                            }))
                                        )}
                                        placeholder={draft.hasSecret?.nextcloudPassword ? "•••••••• (set)" : ""}
                                    />
                                    <LabeledInput
                                        label="Folder path"
                                        value={(draft.config as NextcloudConnConfig)?.path ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as NextcloudConnConfig), path: v },
                                            }))
                                        )}
                                        placeholder="/Backups/RemoteIQ"
                                    />
                                </div>

                                <div className="flex items-center gap-2">
                                    <Button
                                        type="button"
                                        variant="outline"
                                        size="sm"
                                        onClick={browseNextcloud}
                                        disabled={browsing === "nextcloud" || !canEdit}
                                    >
                                        <RefreshCcw className="h-4 w-4 mr-2" />
                                        {browsing === "nextcloud" ? "Browsing…" : "Browse folders"}
                                    </Button>
                                    <span className="text-xs text-muted-foreground">
                                        Fetches subfolders via WebDAV PROPFIND.
                                    </span>
                                </div>

                                {!!(draft.config as NextcloudConnConfig)?._browse?.length && (
                                    <div className="text-xs">
                                        <div className="mb-1 text-muted-foreground">Pick a folder:</div>
                                        <div className="flex flex-wrap gap-2">
                                            {(draft.config as NextcloudConnConfig)._browse!.map((dir) => (
                                                <button
                                                    key={dir}
                                                    type="button"
                                                    onClick={() => {
                                                        if (!canEdit) return;
                                                        setDraft((d) => ({
                                                            ...d,
                                                            config: {
                                                                ...(d.config as NextcloudConnConfig),
                                                                path: dir,
                                                            },
                                                        }));
                                                    }}
                                                    className={`rounded border px-2 py-1 hover:bg-muted ${!canEdit ? "opacity-60 cursor-not-allowed" : ""
                                                        }`}
                                                >
                                                    {dir}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {draft.kind === "gdrive" && (
                            <div className="grid gap-4 md:grid-cols-3">
                                <LabeledInput
                                    label="Folder ID"
                                    value={(draft.config as GDriveConnConfig)?.folderId ?? ""}
                                    onChange={onIfEditable<string>((v) =>
                                        setDraft((d) => ({
                                            ...d,
                                            config: { ...(d.config as GDriveConnConfig), folderId: v },
                                        }))
                                    )}
                                    placeholder="1aBcD2EfGhIjKlMnOpQrStUvWxYz"
                                />
                                <div className="grid gap-1">
                                    <Label className="text-sm">Connected account</Label>
                                    <Input
                                        value={(draft.config as GDriveConnConfig)?.accountEmail ?? ""}
                                        readOnly
                                        placeholder="(server provided)"
                                    />
                                </div>
                                <div className="grid gap-1">
                                    <Label className="text-sm">Auth mode</Label>
                                    <Input
                                        value={(draft.config as GDriveConnConfig)?.authMode ?? ""}
                                        readOnly
                                        placeholder="(server provided)"
                                    />
                                </div>
                                <p className="text-xs text-muted-foreground md:col-span-3">
                                    OAuth / Service Account is managed server-side. This connection
                                    points to a Drive folder ID.
                                </p>
                            </div>
                        )}

                        {draft.kind === "sftp" && (
                            <div className="space-y-4">
                                <div className="grid gap-4 md:grid-cols-3">
                                    <LabeledInput
                                        label="Host / IP"
                                        value={(draft.config as SftpConnConfig)?.host ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as SftpConnConfig), host: v },
                                            }))
                                        )}
                                    />
                                    <LabeledNumber
                                        label="Port"
                                        value={(draft.config as SftpConnConfig)?.port ?? 22}
                                        onChange={onIfEditable<string | number>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as SftpConnConfig),
                                                    port: v === "" ? 22 : Number(v),
                                                },
                                            }))
                                        )}
                                    />
                                    <LabeledInput
                                        label="Username"
                                        value={(draft.config as SftpConnConfig)?.username ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as SftpConnConfig),
                                                    username: v,
                                                },
                                            }))
                                        )}
                                    />
                                    <LabeledInput
                                        label="Password (optional)"
                                        type="password"
                                        value={(draft.config as SftpConnConfig)?.password ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as SftpConnConfig),
                                                    password: v,
                                                },
                                            }))
                                        )}
                                        placeholder={draft.hasSecret?.sftpPassword ? "•••••••• (set)" : ""}
                                    />
                                    <div className="md:col-span-3 grid md:grid-cols-3 gap-4">
                                        <div className="grid gap-1 md:col-span-2">
                                            <Label className="text-sm">Private key (PEM, optional)</Label>
                                            <textarea
                                                className="h-28 w-full rounded-md border bg-background px-3 py-2 text-sm"
                                                placeholder={
                                                    draft.hasSecret?.sftpPrivateKey
                                                        ? "•••••••• (set)"
                                                        : "-----BEGIN OPENSSH PRIVATE KEY-----"
                                                }
                                                value={(draft.config as SftpConnConfig)?.privateKeyPem ?? ""}
                                                onChange={(e) =>
                                                    canEdit &&
                                                    setDraft((d) => ({
                                                        ...d,
                                                        config: {
                                                            ...(d.config as SftpConnConfig),
                                                            privateKeyPem: e.target.value,
                                                        },
                                                    }))
                                                }
                                            />
                                        </div>
                                        <LabeledInput
                                            label="Passphrase (optional)"
                                            type="password"
                                            value={(draft.config as SftpConnConfig)?.passphrase ?? ""}
                                            onChange={onIfEditable<string>((v) =>
                                                setDraft((d) => ({
                                                    ...d,
                                                    config: { ...(d.config as SftpConnConfig), passphrase: v },
                                                }))
                                            )}
                                        />
                                    </div>
                                    <LabeledInput
                                        label="Host key fingerprint (pin, optional)"
                                        value={(draft.config as SftpConnConfig)?.hostKeyFingerprint ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: {
                                                    ...(d.config as SftpConnConfig),
                                                    hostKeyFingerprint: v,
                                                },
                                            }))
                                        )}
                                        placeholder="SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                                    />
                                    <LabeledInput
                                        label="Directory (absolute)"
                                        value={(draft.config as SftpConnConfig)?.path ?? ""}
                                        onChange={onIfEditable<string>((v) =>
                                            setDraft((d) => ({
                                                ...d,
                                                config: { ...(d.config as SftpConnConfig), path: v },
                                            }))
                                        )}
                                        placeholder="/srv/remoteiq/backups"
                                    />
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Performance & cost */}
                    <div className="rounded-md border p-4">
                        <div className="grid gap-4 md:grid-cols-4">
                            <LabeledNumber
                                label="Bandwidth limit (MB/s, optional)"
                                value={draft.meta?.bandwidthLimitMBps ?? ""}
                                onChange={onIfEditable<string | number>((v) =>
                                    setDraft((d) => ({
                                        ...d,
                                        meta: {
                                            ...(d.meta || {}),
                                            bandwidthLimitMBps: v === "" ? undefined : Number(v),
                                        },
                                    }))
                                )}
                            />
                            <LabeledNumber
                                label="Concurrency (optional)"
                                value={draft.meta?.concurrency ?? ""}
                                onChange={onIfEditable<string | number>((v) =>
                                    setDraft((d) => ({
                                        ...d,
                                        meta: {
                                            ...(d.meta || {}),
                                            concurrency: v === "" ? undefined : Number(v),
                                        },
                                    }))
                                )}
                            />
                            <div className="grid gap-1">
                                <Label className="text-sm">Compression</Label>
                                <Select
                                    value={draft.meta?.compression ?? "none"}
                                    onValueChange={onIfEditable<"none" | "gzip" | "zstd">((v) =>
                                        setDraft((d) => ({
                                            ...d,
                                            meta: { ...(d.meta || {}), compression: v },
                                        }))
                                    )}
                                >
                                    <SelectTrigger>
                                        <SelectValue />
                                    </SelectTrigger>
                                    <SelectContent>
                                        <SelectItem value="none">None</SelectItem>
                                        <SelectItem value="gzip">Gzip</SelectItem>
                                        <SelectItem value="zstd">Zstd</SelectItem>
                                    </SelectContent>
                                </Select>
                            </div>
                            <div className="flex items-end">
                                <CheckToggle
                                    label="Pipeline encryption at rest"
                                    checked={!!draft.meta?.encryptionAtRest}
                                    onChange={onIfEditable<boolean>((v) =>
                                        setDraft((d) => ({
                                            ...d,
                                            meta: { ...(d.meta || {}), encryptionAtRest: v },
                                        }))
                                    )}
                                />
                            </div>
                        </div>

                        {(draft.meta?.createdBy ||
                            draft.meta?.updatedBy ||
                            draft.meta?.createdAt ||
                            draft.meta?.updatedAt) && (
                                <div className="flex flex-wrap gap-3 text-xs text-muted-foreground mt-3">
                                    {draft.meta?.createdBy && (
                                        <span>Created by: {draft.meta.createdBy}</span>
                                    )}
                                    {draft.meta?.createdAt && (
                                        <span>
                                            at {(draft.meta.createdAt || "").replace("T", " ").slice(0, 16)}
                                        </span>
                                    )}
                                    {draft.meta?.updatedBy && (
                                        <span>· Updated by: {draft.meta.updatedBy}</span>
                                    )}
                                    {draft.meta?.updatedAt && (
                                        <span>
                                            at {(draft.meta.updatedAt || "").replace("T", " ").slice(0, 16)}
                                        </span>
                                    )}
                                </div>
                            )}

                        <div className="mt-4 flex items-center justify-end gap-2">
                            <Button variant="outline" onClick={testDraft} disabled={testing || !canEdit}>
                                <RefreshCcw className="h-4 w-4 mr-2" />
                                {testing ? "Testing…" : "Test connection"}
                            </Button>

                            {selected && (
                                <>
                                    <Button
                                        variant="destructive"
                                        onClick={() => setConfirmDeleteOpen(true)}
                                        disabled={!canDelete}
                                    >
                                        <Trash2 className="h-4 w-4 mr-2" /> Delete
                                    </Button>
                                    <AlertDialog
                                        open={confirmDeleteOpen}
                                        onOpenChange={setConfirmDeleteOpen}
                                    >
                                        <AlertDialogContent>
                                            <AlertDialogHeader>
                                                <AlertDialogTitle>Delete connection?</AlertDialogTitle>
                                                <AlertDialogDescription>
                                                    This action cannot be undone. Any features that use{" "}
                                                    <span className="font-medium">{selected?.name}</span> will
                                                    stop working until you reconfigure them.
                                                </AlertDialogDescription>
                                            </AlertDialogHeader>
                                            <AlertDialogFooter>
                                                <AlertDialogCancel>Cancel</AlertDialogCancel>
                                                <AlertDialogAction
                                                    onClick={removeSelected}
                                                    className="bg-red-600 text-white hover:bg-red-700"
                                                >
                                                    Delete
                                                </AlertDialogAction>
                                            </AlertDialogFooter>
                                        </AlertDialogContent>
                                    </AlertDialog>
                                </>
                            )}

                            {!canEdit && (
                                <span className="text-xs text-muted-foreground flex items-center gap-1">
                                    <AlertTriangle className="h-3.5 w-3.5" /> You don’t have edit permission.
                                </span>
                            )}
                            <Button onClick={() => saveDraft(false)} disabled={saving || !canEdit || hasBlockingErrors}>
                                <Save className="h-4 w-4 mr-2" />
                                {saving ? "Saving…" : "Save connection"}
                            </Button>
                        </div>
                    </div>

                    {/* Guidance */}
                    <div className="rounded-md border p-3">
                        <div className="flex items-center gap-2 text-sm font-medium">
                            <Cable className="h-4 w-4" /> How it integrates
                        </div>
                        <p className="text-sm text-muted-foreground mt-2">
                            Features reference a <span className="font-medium">connection name</span>, not raw
                            credentials. This centralizes secrets, enables rotation &amp; RBAC,
                            and keeps the UI safer.
                        </p>
                    </div>
                </CardContent>
            </Card>
        </TabsContent>
    );
}

----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-frontend/lib/storage.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-frontend\lib\storage.ts
Size: 4.29 KB
LastWriteTime: 2025-11-05 16:37:32

----- BEGIN CONTENT -----
// lib/storage.ts
import { jfetch } from "@/lib/api";

/* ===== Shared types for Storage ===== */
export type StorageKind = "s3" | "nextcloud" | "gdrive" | "sftp";
export type Env = "dev" | "staging" | "prod";

export type Capabilities = {
    canUse?: boolean;
    canEdit?: boolean;
    canRotate?: boolean;
    canDelete?: boolean;
};
export type Health = {
    status?: "healthy" | "unhealthy" | "unknown";
    lastCheckedAt?: string;
    lastResult?: string;
};

export type ConnectionMeta = {
    environment?: Env;
    tags?: string[];
    defaultFor?: { backups?: boolean; exports?: boolean; artifacts?: boolean };
    bandwidthLimitMBps?: number;
    concurrency?: number;
    compression?: "none" | "gzip" | "zstd";
    encryptionAtRest?: boolean;
    createdBy?: string;
    updatedBy?: string;
    createdAt?: string;
    updatedAt?: string;
};

export type S3ConnConfig = {
    provider: "aws" | "minio" | "wasabi" | "other";
    region: string;
    bucket: string;
    endpoint?: string;
    prefix?: string;
    pathStyle?: boolean;
    sse?: "none" | "AES256" | "aws:kms";
    kmsKeyId?: string;
    accessKeyId?: string;
    secretAccessKey?: string;
    roleArn?: string;
    externalId?: string;
    sessionDurationSec?: number;
    bucketLifecycleSummary?: string;
};
export type NextcloudConnConfig = {
    webdavUrl: string;
    username: string;
    password?: string;
    path: string;
    _browse?: string[];
};
export type GDriveConnConfig = {
    folderId: string;
    accountEmail?: string;
    authMode?: "OAuth" | "ServiceAccount";
};
export type SftpConnConfig = {
    host: string;
    port: number;
    username: string;
    password?: string;
    privateKeyPem?: string;
    passphrase?: string;
    hostKeyFingerprint?: string;
    path: string;
};

export type StorageConnection = {
    id: string;
    name: string;
    kind: StorageKind;
    config: S3ConnConfig | NextcloudConnConfig | GDriveConnConfig | SftpConnConfig;
    meta?: ConnectionMeta;
    health?: Health;
    capabilities?: Capabilities;
    hasSecret?: {
        s3Credentials?: boolean;
        nextcloudPassword?: boolean;
        sftpPassword?: boolean;
        sftpPrivateKey?: boolean;
    };
};

export type ListResp = { items: StorageConnection[] };
export type DependentsResp = { features: { name: string; ids?: string[] }[] };

/* ===== API helpers ===== */
export async function listStorageConnections(): Promise<ListResp> {
    return await jfetch<ListResp>("/api/admin/storage/connections");
}

export async function createStorageConnection(payload: {
    name: string;
    kind: StorageKind;
    config: StorageConnection["config"];
    meta?: ConnectionMeta;
}): Promise<{ id: string }> {
    return await jfetch("/api/admin/storage/connections", {
        method: "POST",
        body: payload,
    });
}

export async function updateStorageConnection(
    id: string,
    payload: {
        name: string;
        kind: StorageKind;
        config: StorageConnection["config"];
        meta?: ConnectionMeta;
    }
): Promise<void> {
    await jfetch(`/api/admin/storage/connections/${encodeURIComponent(id)}`, {
        method: "PUT",
        body: payload,
    });
}

export async function deleteStorageConnection(id: string): Promise<void> {
    await jfetch(`/api/admin/storage/connections/${encodeURIComponent(id)}`, {
        method: "DELETE",
    });
}

export async function getStorageDependents(id: string): Promise<DependentsResp> {
    return await jfetch(
        `/api/admin/storage/connections/${encodeURIComponent(id)}/dependents`
    );
}

export async function testStorageConnection(body: {
    kind: StorageKind;
    config: StorageConnection["config"];
    meta?: ConnectionMeta;
    probe?: "write-read-delete" | "read";
}): Promise<{ ok: boolean; phases?: Record<string, boolean>; detail?: string }> {
    return await jfetch("/api/admin/storage/test", {
        method: "POST",
        body,
    });
}

export async function browseNextcloud(body: {
    config: NextcloudConnConfig;
    path: string;
}): Promise<{ ok: boolean; dirs?: string[]; error?: string }> {
    return await jfetch("/api/admin/storage/browse", {
        method: "POST",
        body: { kind: "nextcloud", ...body },
    });
}

----- END CONTENT -----


====================================================================================================
=  OPTIONAL (nice-to-have)
====================================================================================================


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/backups/notifier.service.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\backups\notifier.service.ts
Size: 1.73 KB
LastWriteTime: 2025-11-05 22:25:57

----- BEGIN CONTENT -----
import { Injectable, Logger } from "@nestjs/common";
import nodemailer from "nodemailer";
import axios from "axios";

type Channels = { email?: boolean; slack?: boolean; webhook?: boolean };

@Injectable()
export class NotifierService {
    private log = new Logger("BackupsNotifier");

    async send(channels: Channels, subject: string, body: string) {
        const promises: Promise<any>[] = [];
        if (channels.email) promises.push(this.sendEmail(subject, body));
        if (channels.slack) promises.push(this.sendSlack(body));
        if (channels.webhook) promises.push(this.sendWebhook({ subject, body }));
        await Promise.allSettled(promises);
    }

    private async sendEmail(subject: string, body: string) {
        const { SMTP_HOST, SMTP_PORT, SMTP_SECURE, SMTP_USER, SMTP_PASS, SMTP_FROM, SMTP_TO } = process.env as any;
        if (!SMTP_HOST || !SMTP_FROM || !SMTP_TO) return;
        const transporter = nodemailer.createTransport({
            host: SMTP_HOST,
            port: Number(SMTP_PORT ?? 587),
            secure: String(SMTP_SECURE ?? "false") === "true",
            auth: SMTP_USER && SMTP_PASS ? { user: SMTP_USER, pass: SMTP_PASS } : undefined,
        });
        await transporter.sendMail({
            from: SMTP_FROM,
            to: SMTP_TO,
            subject,
            text: body,
        });
    }

    private async sendSlack(text: string) {
        const url = process.env.SLACK_WEBHOOK_URL;
        if (!url) return;
        await axios.post(url, { text });
    }

    private async sendWebhook(payload: any) {
        const url = process.env.BACKUPS_WEBHOOK_URL;
        if (!url) return;
        await axios.post(url, payload, { timeout: 5000 });
    }
}

----- END CONTENT -----


====================================================================================================
=  FILE: remoteiq-minimal-e2e/backend/src/common/types.ts
====================================================================================================

Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V7 - Ticketing\remoteiq-minimal-e2e\backend\src\common\types.ts
Size: 0.58 KB
LastWriteTime: 2025-10-15 16:39:42

----- BEGIN CONTENT -----
export type WSIncoming =
  | { t: "hello"; agentId: string; capabilities: string[]; os: string; arch: string; hostname: string; version: string }
  | { t: "hb"; at: string; metrics?: { cpu?: number; mem?: number } }
  | { t: "job_result"; jobId: string; exitCode: number; stdout: string; stderr: string; startedAt: string; finishedAt: string };

export type WSOutgoing =
  | { t: "ack"; id: string }
  | {
    t: "job_run_script";
    jobId: string;
    language: "powershell" | "bash";
    scriptText: string;
    args?: string[];
    env?: Record<string, string>;
    timeoutSec?: number;
  };

----- END CONTENT -----

End of bundle.
